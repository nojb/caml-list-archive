Return-Path: <rich@annexia.org>
X-Original-To: caml-list@sympa.inria.fr
Delivered-To: caml-list@sympa.inria.fr
Received: from mail3-relais-sop.national.inria.fr (mail3-relais-sop.national.inria.fr [192.134.164.104])
	by sympa.inria.fr (Postfix) with ESMTPS id DAFE87F61E
	for <caml-list@sympa.inria.fr>; Sat,  4 Nov 2017 19:44:03 +0100 (CET)
Authentication-Results: mail3-smtp-sop.national.inria.fr; spf=None smtp.pra=rich@annexia.org; spf=Pass smtp.mailfrom=rich@annexia.org; spf=Pass smtp.helo=postmaster@annexia.org
Received-SPF: None (mail3-smtp-sop.national.inria.fr: no sender
  authenticity information available from domain of
  rich@annexia.org) identity=pra; client-ip=80.68.91.176;
  receiver=mail3-smtp-sop.national.inria.fr;
  envelope-from="rich@annexia.org";
  x-sender="rich@annexia.org"; x-conformance=sidf_compatible
Received-SPF: Pass (mail3-smtp-sop.national.inria.fr: domain of
  rich@annexia.org designates 80.68.91.176 as permitted sender)
  identity=mailfrom; client-ip=80.68.91.176;
  receiver=mail3-smtp-sop.national.inria.fr;
  envelope-from="rich@annexia.org";
  x-sender="rich@annexia.org"; x-conformance=sidf_compatible;
  x-record-type="v=spf1"
Received-SPF: Pass (mail3-smtp-sop.national.inria.fr: domain of
  postmaster@annexia.org designates 80.68.91.176 as permitted
  sender) identity=helo; client-ip=80.68.91.176;
  receiver=mail3-smtp-sop.national.inria.fr;
  envelope-from="rich@annexia.org";
  x-sender="postmaster@annexia.org";
  x-conformance=sidf_compatible; x-record-type="v=spf1"
IronPort-PHdr: =?us-ascii?q?9a23=3AA7yZLhRS4aKMpybEg13XICqi1tpsv+yvbD5Q0YIu?=
 =?us-ascii?q?jvd0So/mwa64ZBKN2/xhgRfzUJnB7Loc0qyN7PCmBDRIyK3CmU5BWaQEbwUCh8?=
 =?us-ascii?q?QSkl5oK+++Imq/EsTXaTcnFt9JTl5v8iLzG0FUHMHjew+a+SXqvnY6Uy/yPgtt?=
 =?us-ascii?q?J+nzBpWaz4Huj7jzqNXvZFACvDehfb5oZDzw5TjLtcQaiI8oYvIpwwbToXZEcu?=
 =?us-ascii?q?B+ymZhJFbVlBH5sJSe5plmpm5quvkh/tRMGZq8WuJwb7teAS9sezQv5cbrnRDF?=
 =?us-ascii?q?Swaf53JaVX8ZxEkbSzPZ5Q33C8+i+hDxsfBwjWzDZZX7?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AVAwAMCv5Z/7BbRFBcGgEBAQECAQEBA?=
 =?us-ascii?q?QgBAQEBgzSBUiedN0MBAQaBMZhXCoQmAYEUAoRXQxQBAQEBAQEBAQEBaiiCOAU?=
 =?us-ascii?q?BHgEFgj0BBScTPxALGAkTEg8tGwYTGol8EapcOosIAQsBJYMuggeBDD2FHYsIB?=
 =?us-ascii?q?YomjmCJCAKUbZNBlhaBOTYhgWyBBwhJgmSEX0E2ixOBVQEBAQ?=
X-IPAS-Result: =?us-ascii?q?A0AVAwAMCv5Z/7BbRFBcGgEBAQECAQEBAQgBAQEBgzSBUie?=
 =?us-ascii?q?dN0MBAQaBMZhXCoQmAYEUAoRXQxQBAQEBAQEBAQEBaiiCOAUBHgEFgj0BBScTP?=
 =?us-ascii?q?xALGAkTEg8tGwYTGol8EapcOosIAQsBJYMuggeBDD2FHYsIBYomjmCJCAKUbZN?=
 =?us-ascii?q?BlhaBOTYhgWyBBwhJgmSEX0E2ixOBVQEBAQ?=
X-IronPort-AV: E=Sophos;i="5.44,343,1505772000"; 
   d="scan'208";a="243421639"
Received: from annexia.org ([80.68.91.176])
  by mail3-smtp-sop.national.inria.fr with ESMTP/TLS/AES256-GCM-SHA384; 04 Nov 2017 19:44:03 +0100
Received: from rich by annexia.org with local (Exim 4.89)
	(envelope-from <rich@annexia.org>)
	id 1eB3QI-0004Mm-1V; Sat, 04 Nov 2017 18:44:02 +0000
Date: Sat, 4 Nov 2017 18:44:01 +0000
From: "Richard W.M. Jones" <rich@annexia.org>
To: "Petter A. Urkedal" <paurkedal@gmail.com>
Cc: caml-list <caml-list@inria.fr>
Message-ID: <20171104184401.3el2vbha2tgpvse5@annexia.org>
References: <86o9p2ywgc.fsf@gmail.com>
 <E51C5B015DBD1348A1D85763337FB6D9016D523CA2@Remus.metastack.local>
 <CALdWJ+zsx4vNWj8_32rev9pKt2j6yacGhai6UJQ7tsGVVLqYCg@mail.gmail.com>
 <20171020113815.GD32138@nunchakus.loria.fr>
 <20171024133026.uovvzdbnamnzoknv@annexia.org>
 <CALa9pHRjKeOijkos8ffCrc6PaNiiPHWk2dBSJotPK1HHv2ORLg@mail.gmail.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <CALa9pHRjKeOijkos8ffCrc6PaNiiPHWk2dBSJotPK1HHv2ORLg@mail.gmail.com>
User-Agent: NeoMutt/20170113 (1.7.2)
Subject: Re: [Caml-list] What if exn was not an open type?

On Tue, Oct 24, 2017 at 09:02:55PM +0200, Petter A. Urkedal wrote:
> On 24 October 2017 at 15:30, Richard W.M. Jones <rich@annexia.org> wrote:
> > Since I first used OCaml I have wished for a simple (and type safe)
> > return statement.
> 
> It's possible to wrap a bit type (and exception) safety about
> exceptions used for return:
> 
>   val with_return : (('a -> 'b) -> 'a) -> 'a
> 
>   let with_return (type b) f =
>     let exception Return of b in
>     try f (fun y -> raise (Return y)) with Return y -> y
> 
> E.g.
> 
>   with_return (fun return -> List.iter (function 0 -> () | i -> return
> i) [0; 0; 24; 0]; -1);;

As promised, I tried rewriting some code with this style.  The
good news is that it does look a lot more like the original C code.

The bad news is that with_return as defined above doesn't really work
like the C return statement, as in the small example below.  The
example is very contrived but it reflects a problem that I found in
real code.

The problem is that the return statement could be called from many
contexts, all with different types.  The compiler expects to unify all
these types (as the same type 'b) which is not possible.

It wasn't immediately clear to me if this was solvable.

Rich.

----------------------------------------------------------------------

let with_return (type b) f =
  let exception Return of b in
  try f (fun y -> raise (Return y)) with Return y -> y

let f () =
  with_return (fun return ->
      if false then return "error";
      let a =
        match Some "abc" with
        | None -> return "another error"
        | Some a -> a in
      a
  )



-- 
Richard Jones
