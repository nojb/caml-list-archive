Received: (from weis@localhost) by pauillac.inria.fr (8.7.6/8.7.3) id IAA27986 for caml-redistribution; Tue, 9 Mar 1999 08:42:31 +0100 (MET)
Received: from nez-perce.inria.fr (nez-perce.inria.fr [192.93.2.78]) by pauillac.inria.fr (8.7.6/8.7.3) with ESMTP id EAA05199 for <caml-list@pauillac.inria.fr>; Tue, 9 Mar 1999 04:24:51 +0100 (MET)
Received: from marr.ius.cs.cmu.edu (MARR.IUS.CS.CMU.EDU [128.2.242.179])
	by nez-perce.inria.fr (8.8.7/8.8.7) with SMTP id EAA10443;
	Tue, 9 Mar 1999 04:24:49 +0100 (MET)
Date: Mon,  8 Mar 1999 22:24:39 -0500 (EST)
From: mahamud@cs.cmu.edu
To: Xavier Leroy <Xavier.Leroy@inria.fr>, caml-list@inria.fr
Subject: Re: bug in floating point implementation ?
In-Reply-To: <19990225131027.37364@pauillac.inria.fr>
References: <199902250043.BAA21786@nez-perce.inria.fr>
	<19990225131027.37364@pauillac.inria.fr>
X-Mailer: VM 6.43 under 20.4 "Emerald" XEmacs  Lucid
Message-ID: <14052.37294.255759.752432@marr.ius.cs.cmu.edu>
Mime-Version: 1.0 (generated by tm-edit 7.108)
Content-Type: text/plain; charset=US-ASCII
Sender: weis

>>>>> "Xavier" == Xavier Leroy <Xavier.Leroy@inria.fr> writes:

    Xavier> The Intel x86 has an interesting quirk: it computes
    Xavier> internally in extended precision (80 bits), and rounds to
    Xavier> double precision (64 bits) only when storing a result in
    Xavier> memory.  This means that in a piece of code such as

    Xavier>         let x = a * b + c

    Xavier> the virtual machine will compute a * b, round it (by
    Xavier> storing it in memory), add c, and round the result.  While
    Xavier> the native-code compiler will compute a * b, keep the
    Xavier> result in extended precision in the top float register,
    Xavier> then add c, then round the result.

    Xavier> In extreme cases (badly conditioned algorithm, computation
    Xavier> of errors), you may thus get different results.

sorry about the late reply. but i was hung up with other stuff.
thanx for the explanation. i've found out that indeed my computation
was ill-conditioned and have fixed it now. 
in fact, were it not for this intel quirkiness, i might have
overlooked the bug for some-time. this definitely tops my 
list of ways i've debugged code! 

before i was able to spot the problem with my code, i tried
downloading the src on a different architecture. however, it
seems that the tar file is broken, since it creates files when it should
be creating dirs. i never faced this problem for my linux box since 
i downloaded the binary rpms. anyway it does'nt matter for now since
i know what the problem is. but in future it might be useful to
compile ocaml on a different architecture (i had tried both 2.01 &
2.02). 

- shyjan
carnegie mellon university



