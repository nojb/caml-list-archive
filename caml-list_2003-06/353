Received: (from majordomo@localhost) by pauillac.inria.fr (8.7.6/8.7.3) id LAA18718; Mon, 23 Jun 2003 11:06:58 +0200 (MET DST)
X-Authentication-Warning: pauillac.inria.fr: majordomo set sender to owner-caml-list@pauillac.inria.fr using -f
Received: from concorde.inria.fr (concorde.inria.fr [192.93.2.39]) by pauillac.inria.fr (8.7.6/8.7.3) with ESMTP id LAA18930 for <caml-list@pauillac.inria.fr>; Mon, 23 Jun 2003 11:06:57 +0200 (MET DST)
Received: from pareto.inria.fr.inria.fr (lamarck.inria.fr [128.93.1.21])
	by concorde.inria.fr (8.11.1/8.11.1) with ESMTP id h5N96sH22057;
	Mon, 23 Jun 2003 11:06:54 +0200 (MET DST)
Date: Mon, 23 Jun 2003 11:03:09 +0200
Message-ID: <lwel1lqi7m.wl@inria.fr>
From: Jun.Furuse@inria.fr
To: John Skaller <skaller@ozemail.com.au>
Cc: caml-list@inria.fr
Subject: Re: [Caml-list] First order compile time functorial polymorphism in Ocaml
In-Reply-To: <3EF5F48E.6010209@ozemail.com.au>
References: <3EF5F48E.6010209@ozemail.com.au>
User-Agent: Wanderlust/2.10.0 (Venus) SEMI/1.14.4 (Hosorogi) FLIM/1.14.4
 (=?ISO-8859-4?Q?Kashiharajing=FE-mae?=) APEL/10.5 MULE XEmacs/21.4 (patch
 12) (Portable Code) (i386-debian-linux)
MIME-Version: 1.0 (generated by SEMI 1.14.4 - "Hosorogi")
Content-Type: text/plain; charset=US-ASCII
X-Spam: no; 0.00; furuse:01 caml-list:01 functorial:01 reuse:01 generic:01 haskell:01 generics:01 g'caml:01 n-ary:01 ocaml:01 caml:01 constructors:01 trivial:01 compile:02 objects:02 
Sender: owner-caml-list@pauillac.inria.fr
Precedence: bulk

Hello,

At Mon, 23 Jun 2003 04:25:18 +1000,
John Skaller wrote:
> 
> In ML style functional programming languages like Ocaml,
> we have what is termed data polymorphism. This provides
> a kind of code reuse we're all familiar with.
> 
> However, there is another kind of polymophism
> which Ocaml does not provide. Two things to consider here:
> 
> 1. Every data structure has a map function.
> 2. User defined algebraic type require a hand written map function

Yes, I agree that writing map or fold function over again and again is 
trivial and boring.

Your approach reminds me polytypic programming or so-called 
"generic programming"[1] in Haskell. I have also considered a bit about 
the possibility of this "generic programming" in O'Caml. Actually, 
I think our "generics" (= G'Caml) has already had allmost of all 
the internal functionalities for so-called "generics" in Haskell
community. Only one possible problem of "generics" on Caml is that
type constructors of Caml is not so "mathematically pure" as Haskell.
I still do not have clear idea how to declare generic case for n-ary
tuples, objects and labeled function types of Caml...

Anyway, "generics" are too general solution for your purpose.
This is not something I can prepare for you in this week. :-)

[1]: Generic Haskell project
	http://www.cs.uu.nl/research/projects/generic-haskell/

--
Jun

-------------------
To unsubscribe, mail caml-list-request@inria.fr Archives: http://caml.inria.fr
Bug reports: http://caml.inria.fr/bin/caml-bugs FAQ: http://caml.inria.fr/FAQ/
Beginner's list: http://groups.yahoo.com/group/ocaml_beginners

