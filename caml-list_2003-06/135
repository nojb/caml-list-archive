Received: (from majordomo@localhost) by pauillac.inria.fr (8.7.6/8.7.3) id QAA00323; Sat, 7 Jun 2003 16:48:21 +0200 (MET DST)
X-Authentication-Warning: pauillac.inria.fr: majordomo set sender to owner-caml-list@pauillac.inria.fr using -f
Received: from concorde.inria.fr (concorde.inria.fr [192.93.2.39]) by pauillac.inria.fr (8.7.6/8.7.3) with ESMTP id QAA00712 for <caml-list@pauillac.inria.fr>; Sat, 7 Jun 2003 16:48:20 +0200 (MET DST)
Received: from pareto.inria.fr.inria.fr (lamarck.inria.fr [128.93.1.21])
	by concorde.inria.fr (8.11.1/8.11.1) with ESMTP id h57EmDH22378;
	Sat, 7 Jun 2003 16:48:13 +0200 (MET DST)
Date: Sat, 07 Jun 2003 16:44:48 +0200
Message-ID: <lwof1agd5r.wl@inria.fr>
From: Jun.Furuse@inria.fr
To: brogoff@speakeasy.net
Cc: Pierre Weis <pierre.weis@inria.fr>, Oleg Trott <oleg_trott@columbia.edu>,
        John Max Skaller <skaller@ozemail.com.au>,
        "caml-list@inria.fr" <caml-list@inria.fr>
Subject: Re: easy print and read (was: [Caml-list] Why are arithmetic functions not polymorph?)
In-Reply-To: <Pine.LNX.4.44.0306060909340.6703-100000@grace.speakeasy.net>
References: <20030606124626.A27959@pauillac.inria.fr>
	<Pine.LNX.4.44.0306060909340.6703-100000@grace.speakeasy.net>
User-Agent: Wanderlust/2.10.0 (Venus) SEMI/1.14.4 (Hosorogi) FLIM/1.14.4
 (=?ISO-8859-4?Q?Kashiharajing=FE-mae?=) APEL/10.4 MULE XEmacs/21.4 (patch
 12) (Portable Code) (i386-debian-linux)
MIME-Version: 1.0 (generated by SEMI 1.14.4 - "Hosorogi")
Content-Type: text/plain; charset=US-ASCII
X-Spam: no; 0.00; furuse:01 caml-list:01 generic:01 inferred:01 g'caml:01 inefficient:01 int:01 arithmetic:01 restrict:02 float:02 typing:03 recursive:03 btw:03 infinite:05 functions:05 
Sender: owner-caml-list@pauillac.inria.fr
Precedence: bulk

Hello,

> BTW, someone (Brian Hurt?) brought up a nice simple example of where the 
> current generic polymorphism seems a bit weak
> 
> generic one = | int => 1 | float => 1.0 ;;
> generic two = | int => 2 | float => 2.0 ;;
> generic plus = | float -> float -> float => (+.) | int -> int -> int => (+);;
> 
> plus one two;; (* Can't determine plus without at least one type annotation *)
> 
> and it would be nice if in such situations the correct plus could be inferred. 

Yes, in this case, it is easy to tell that there is only one
applicable typing for plus one two, that is plus : float -> float -> float.
But in general, nubmer of type case combinations may increase quite
easily and searching applicable typing from them becomes quite inefficient.
Moreover, when we have recursive generic values, the search space may
be infinite! Therefore, we must restrict the search space of type case
combinations in some manner (otherwise, typing may never terminates). 

The restriciton in the G'Caml implementation is quite simple, 
therefore you may feel some inconvenience: the type of plus one two 
is not inferred automatically, for example.
 
--
Jun

-------------------
To unsubscribe, mail caml-list-request@inria.fr Archives: http://caml.inria.fr
Bug reports: http://caml.inria.fr/bin/caml-bugs FAQ: http://caml.inria.fr/FAQ/
Beginner's list: http://groups.yahoo.com/group/ocaml_beginners

