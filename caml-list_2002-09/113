Received: (from majordomo@localhost) by pauillac.inria.fr (8.7.6/8.7.3) id XAA16710; Fri, 6 Sep 2002 23:15:47 +0200 (MET DST)
X-Authentication-Warning: pauillac.inria.fr: majordomo set sender to owner-caml-list@pauillac.inria.fr using -f
Received: from concorde.inria.fr (concorde.inria.fr [192.93.2.39]) by pauillac.inria.fr (8.7.6/8.7.3) with ESMTP id XAA16974 for <caml-list@pauillac.inria.fr>; Fri, 6 Sep 2002 23:15:47 +0200 (MET DST)
Received: from wetware.wetware.com (wetware.wetware.com [199.108.16.1])
	by concorde.inria.fr (8.11.1/8.11.1) with ESMTP id g86LFj116393
	for <caml-list@inria.fr>; Fri, 6 Sep 2002 23:15:46 +0200 (MET DST)
Received: from kallisti.local.(ra02.wetware.com[199.108.16.82]) (2414 bytes) by wetware.wetware.com
	via sendmail with P:esmtp/R:bind_hosts/T:inet_zone_bind_smtp
	(sender: <jhw@wetware.com>) 
	id <m17nQS7-002zPEC@wetware.wetware.com>
	for <caml-list@inria.fr>; Fri, 6 Sep 2002 14:15:43 -0700 (PDT)
	(Smail-3.2.0.114 2001-Aug-6 #1 built 2002-Sep-2)
Date: Fri, 6 Sep 2002 14:15:39 -0700
Subject: Re: [Caml-list] Allow declaring classes "final" so self type has no type variables?
Content-Type: text/plain; charset=US-ASCII; format=flowed
Mime-Version: 1.0 (Apple Message framework v543)
Cc: Ocaml <caml-list@inria.fr>
To: Alessandro Baretta <alex@baretta.com>
From: james woodyatt <jhw@wetware.com>
In-Reply-To: <3D79125F.1090005@baretta.com>
Message-Id: <CB78D5D0-C1DD-11D6-8D7B-000393BA7EBA@wetware.com>
Content-Transfer-Encoding: 7bit
X-Mailer: Apple Mail (2.543)
Sender: owner-caml-list@pauillac.inria.fr
Precedence: bulk

On Friday, Sep 6, 2002, at 13:38 US/Pacific, Alessandro Baretta wrote:
> james woodyatt wrote:
>> On Friday, Sep 6, 2002, at 12:12 US/Pacific, Tim Freeman wrote:
>>>
>>> Any comments on whether this is a good idea?
>>
>> Hide the class with a module signature.  Publish only the class type 
>> and one or more functions for constructing objects.
>
> I don't think this is what he meant. I think he would like to 
> "finalize" a class for efficiency purposes as opposed to "safety" 
> purposes. He is asking for some compiler magic.

The opportunity to optimize method dispatch simply isn't there.  The 
reason is that two objects with identical class types need not have 
methods with the same definition.

> 	# class a = object method f = print_string "a\n" end;;
> 	class a : object method f : unit end
> 	# class b = object method f = print_string "b\n" end;;
> 	class b : object method f : unit end
> 	# let print (p : a) = p#f;;
> 	val print : a -> unit = <fun>
> 	# print (new b);;
> 	b
> 	- : unit = ()

In the above excerpt, class a and class b are different classes with 
equivalent class types.  The function 'print' may look like it requires 
objects constructed of class a, but all it really requires is objects 
of class type a (and since class type b is equivalent to class type a, 
objects of class b will work just as well).

And anyway... last I checked, method dispatch was not the low-hanging 
fruit for optimizing Ocaml code with objects and classes.  The size of 
class initializers (generated by the compiler and executed in enclosing 
module initializers) are where it seems to me the big opportunities are 
to be had.


-- 
j h woodyatt <jhw@wetware.com>
markets are only free to the people who own them.

-------------------
To unsubscribe, mail caml-list-request@inria.fr Archives: http://caml.inria.fr
Bug reports: http://caml.inria.fr/bin/caml-bugs FAQ: http://caml.inria.fr/FAQ/
Beginner's list: http://groups.yahoo.com/group/ocaml_beginners

