Received: (from weis@localhost) by pauillac.inria.fr (8.7.6/8.7.3) id WAA18337 for caml-redistribution@pauillac.inria.fr; Sat, 15 Apr 2000 22:37:47 +0200 (MET DST)
Resent-Message-Id: <200004152037.WAA18337@pauillac.inria.fr>
Received: from nez-perce.inria.fr (nez-perce.inria.fr [192.93.2.78]) by pauillac.inria.fr (8.7.6/8.7.3) with ESMTP id TAA29174 for <caml-list@pauillac.inria.fr>; Thu, 13 Apr 2000 19:04:44 +0200 (MET DST)
Received: from suburbia.net (suburbia.net [203.4.184.1])
	by nez-perce.inria.fr (8.8.7/8.8.7) with ESMTP id TAA13742;
	Thu, 13 Apr 2000 19:04:39 +0200 (MET DST)
Received: by suburbia.net (Postfix, from userid 110)
	id 15BF36C4C3; Fri, 14 Apr 2000 03:04:24 +1000 (EST)
Sender: proff@suburbia.net
To: Pierre Weis <Pierre.Weis@inria.fr>
Cc: "Dennis (Gang) Chen" <Dennis.G.Chen@motorola.com>, caml-list@inria.fr
Subject: Re: When functional languages can be accepted by industry?
References: <38E7F364.5D24BB7C@motorola.com> <14572.49274.910966.673172@cylinder.csl.sri.com> <38ED71B6.30118608@motorola.com> <14574.1721.508470.790475@cylinder.csl.sri.com> <38F270CF.221F5BD0@motorola.com> <20000411195808.62154@pauillac.inria.fr> <38F3D520.9CD19485@motorola.com> <20000413090550.25014@pauillac.inria.fr>
Cc: proff@iq.org
From: Julian Assange <proff@iq.org>
Date: 14 Apr 2000 03:04:23 +1000
In-Reply-To: Pierre Weis's message of "Thu, 13 Apr 2000 09:05:50 +0200"
Message-ID: <wxg0sq53vs.fsf@suburbia.net>
User-Agent: Gnus/5.0802 (Gnus v5.8.2) XEmacs/21.1 (Big Bend)
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Resent-From: weis@pauillac.inria.fr
Resent-Date: Sat, 15 Apr 2000 22:37:47 +0200
Resent-To: caml-redistribution@pauillac.inria.fr

Pierre Weis <Pierre.Weis@inria.fr> writes:

> concisely express a solution to a difficult problem. Although
> we base most of our command and control software in Java, ML
> is still the choice for modeling and graph theory. 

Speaking of graph theory, does anyone know of a collection of
*caml code to deal with least path, clustering, etc?

-- 
Stefan Kahrs in [Kah96] discusses the
   notion of completeness--programs which never go wrong can be
   type-checked--which complements Milner's notion of
   soundness--type-checked programs never go wrong [Mil78].


