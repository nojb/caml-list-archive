Received: (from weis@localhost) by pauillac.inria.fr (8.7.6/8.7.3) id NAA06054 for caml-redistribution; Tue, 7 Apr 1998 13:24:39 +0200 (MET DST)
Received: from concorde.inria.fr (concorde.inria.fr [192.93.2.39]) by pauillac.inria.fr (8.7.6/8.7.3) with ESMTP id SAA27061 for <caml-list@pauillac.inria.fr>; Mon, 6 Apr 1998 18:57:25 +0200 (MET DST)
Received: from pauillac.inria.fr (pauillac.inria.fr [128.93.11.35])
	by concorde.inria.fr (8.8.7/8.8.5) with ESMTP id SAA12464;
	Mon, 6 Apr 1998 18:57:17 +0200 (MET DST)
Received: (from remy@localhost) by pauillac.inria.fr (8.7.6/8.7.3) id SAA26885; Mon, 6 Apr 1998 18:57:17 +0200 (MET DST)
Message-Id: <199804061657.SAA26885@pauillac.inria.fr>
Subject: Re: dynamic method look-up?
To: sumii@lute.is.s.u-tokyo.ac.jp (Eijiro Sumii)
Date: Mon, 6 Apr 1998 18:57:17 +0200 (MET DST)
Cc: caml-list@inria.fr, sumii@lute.is.s.u-tokyo.ac.jp
In-Reply-To: <199804021049.TAA20435@lute.is.s.u-tokyo.ac.jp> from "Eijiro Sumii" at Apr 2, 98 07:49:36 pm
From: Didier.Remy@inria.fr (Didier Remy)
Reply-to: Didier.Remy@inria.fr
Organization: INRIA, BP 105, F-78153 Le Chesnay Cedex
Phone: (33) 1 3963 5317 -- Sec: (33) 1 3963 5570 -- Fax: (33) 1 3963 5684
Web: http://pauillac.inria.fr/~remy
X-Mailer: ELM [version 2.4 PL24 ME8]
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Sender: weis

> the assembly code generated by ocamlopt seems to contain an ascii
> string "foo" and to use it at runtime.  

Yes it does.  But the string "foo" is only used at load time to create some
runtime tables.

> Is the method `foo' dynamically looked up before its invocation?  

1. The offset at which the method is stored is not always known statically
(this is difficult with multiple inheritance and separate compilation).

2. However, there are just a few (fix number) of indirections through a
dictionary to find the exact code to execute. (This is nothing like
searching for the method in an A-list.)

> If it is, isn't there a
> more efficient way than dynamic method look-up to implement method
> invocation?  

The actual schema is not inefficient.  It could still be improved using
static analyses to find methods calls to objects whose classes are
statically known (as is currently done for functions).

> (something like index passing in Ohori's polymorphic
> record calculus [1], 

The compilation method of [1] relies on the types of records to uniquely
determine their representation.  It does not apply to Ocaml that also allows
subtyping.  Subtyping changes the types of objects without changing their
representation in a way that contradicts the previous condition.  Roughtly,
({a = 1; b = 2} :> {a : int}) has the same time as {a = 1} but should
clearly have a different representation.

Indeed, it is important that subtyping behaves as the identity to keep
sharing, since in particular objects may have mutable fields. 

> or implicitly generating and passing some
> fuctions like a coercion function and a put function in Hofmann &
> Pierce's positive subtyping [2])

I am not sure that [2] can help here.  Moreover, we just do not want to pass
coercion functions, which would destroy sharing.

    Didier.




