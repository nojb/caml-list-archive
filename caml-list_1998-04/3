Received: (from weis@localhost) by pauillac.inria.fr (8.7.6/8.7.3) id MAA18814 for caml-redistribution; Fri, 3 Apr 1998 12:28:17 +0200 (MET DST)
Received: from nez-perce.inria.fr (nez-perce.inria.fr [192.93.2.78]) by pauillac.inria.fr (8.7.6/8.7.3) with ESMTP id MAA08002 for <caml-list@pauillac.inria.fr>; Thu, 2 Apr 1998 12:49:43 +0200 (MET DST)
Received: from lute.is.s.u-tokyo.ac.jp (lute.is.s.u-tokyo.ac.jp [133.11.12.76])
	by nez-perce.inria.fr (8.8.7/8.8.5) with ESMTP id MAA29779
	for <caml-list@inria.fr>; Thu, 2 Apr 1998 12:49:40 +0200 (MET DST)
Received: from cube.is.s.u-tokyo.ac.jp (cube.is.s.u-tokyo.ac.jp [133.11.12.30])
	by lute.is.s.u-tokyo.ac.jp (8.8.8/3.6Wbeta7) with ESMTP id TAA20435;
	Thu, 2 Apr 1998 19:49:37 +0900 (JST)
Message-Id: <199804021049.TAA20435@lute.is.s.u-tokyo.ac.jp>
To: caml-list@inria.fr
cc: sumii@lute.is.s.u-tokyo.ac.jp
Subject: dynamic method look-up?
Mime-Version: 1.0 (generated by tm-edit 7.106)
Content-Type: text/plain; charset=US-ASCII
Date: Thu, 02 Apr 1998 19:49:36 +0900
From: Eijiro Sumii <sumii@lute.is.s.u-tokyo.ac.jp>
Sender: weis

Hello, everyone.  I'm sorry that I don't write French version.  I know
very little about French language.  (Though I'm not very good at
English, either.)

I have a question about the implementation of method invocation in
ocaml.  Whenever I compile a tiny program like the following one by
ocamlopt with `-S' option (on any platform),

    let invoke_foo obj = obj # foo;;
  	
    class c1 () =
      method foo = 123
    end;;
    
    class c2 () =
      method foo = 456
      method bar = "abc"
    end;;
    
    let o1 = new c1 ();;
    let o2 = new c2 ();;
    
    print_int ((invoke_foo o1) + (invoke_foo o2));;
    print_newline ();;

the assembly code generated by ocamlopt seems to contain an ascii
string "foo" and to use it at runtime.  Is the method `foo'
dynamically looked up before its invocation?  If it is, isn't there a
more efficient way than dynamic method look-up to implement method
invocation?  (something like index passing in Ohori's polymorphic
record calculus [1], or implicitly generating and passing some
fuctions like a coercion function and a put function in Hofmann &
Pierce's positive subtyping [2])

// Eijiro Sumii <sumii@yl.is.s.u-tokyo.ac.jp>
// 
// Kobayashi Laboratory, Department of Information Science,
// Faculty of Science, University of Tokyo

[1] Atsushi Ohori. A polymorphic record calculus and its
compilation. ACM Transactions on Programming Languages and Systems,
Vol 17, No 6, Pages 844-895.

[2] @inproceedings   (HofmannPierce94a,
author       =   "Martin Hofmann and Benjamin Pierce" ,
title        =   "Positive Subtyping",
booktitle    =   "Proceedings of Twenty-Second Annual ACM Symposium on
                  Principles of Programming Languages",
year         =   "1995" ,
month        =   jan,
publisher    =   "ACM" ,
pages        =   "186--197",
note         =   "Full version in {\em Information and Computation}, 
                  volume 126, number 1, April 1996. 
                  Also available as University of Edinburgh technical
                  report ECS-LFCS-94-303, September 1994."
)




