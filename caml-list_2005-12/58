Return-Path: <weis@pauillac.inria.fr>
X-Original-To: caml-list@yquem.inria.fr
Delivered-To: caml-list@yquem.inria.fr
Received: from concorde.inria.fr (concorde.inria.fr [192.93.2.39])
	by yquem.inria.fr (Postfix) with ESMTP id 22D86BB81
	for <caml-list@yquem.inria.fr>; Sun,  4 Dec 2005 03:29:02 +0100 (CET)
Received: from pauillac.inria.fr (pauillac.inria.fr [128.93.11.35])
	by concorde.inria.fr (8.13.0/8.13.0) with ESMTP id jB42T1O3018779
	for <caml-list@yquem.inria.fr>; Sun, 4 Dec 2005 03:29:01 +0100
Received: from nez-perce.inria.fr (nez-perce.inria.fr [192.93.2.78]) by pauillac.inria.fr (8.7.6/8.7.3) with ESMTP id DAA24604 for <caml-list@pauillac.inria.fr>; Sun, 4 Dec 2005 03:29:00 +0100 (MET)
Received: from kfep10.dion.ne.jp (kfep10.dion.ne.jp [203.181.105.172])
	by nez-perce.inria.fr (8.13.0/8.13.0) with ESMTP id jB42Swl1006440
	for <caml-list@inria.fr>; Sun, 4 Dec 2005 03:29:00 +0100
Received: from wednesday.local.local ([58.92.65.141]) by kfep10.dion.ne.jp
          with ESMTP id <20051204022857329.PRQN@kfep10.dion.ne.jp>;
          Sun, 4 Dec 2005 11:28:57 +0900
Date: Sun, 04 Dec 2005 11:28:32 +0900
Message-ID: <87iru5egtr.wl%osiire@k8.dion.ne.jp>
From: osiire <osiire@k8.dion.ne.jp>
To: caml-list@inria.fr
Subject: Re: [Caml-list] Are unreachable threads garbage collected?
In-Reply-To: <20051204001629.39621.qmail@web34610.mail.mud.yahoo.com>
References: <ad8cfe7e0512031554g73aaf5f8w142196c4f9c939c0@mail.gmail.com>
	<20051204001629.39621.qmail@web34610.mail.mud.yahoo.com>
User-Agent: Wanderlust/2.10.1
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=US-ASCII
X-Miltered: at concorde with ID 4392546D.001 by Joe's j-chkmail (http://j-chkmail.ensmp.fr)!
X-Miltered: at nez-perce with ID 4392546A.000 by Joe's j-chkmail (http://j-chkmail.ensmp.fr)!
X-Spam: no; 0.00; caml-list:01 threads:01 garbage:01 reworking:01 buffered:01 rec:01 printf:01 printf:01 stdout:01 wrote:01 thread:02 thread:02 pattern:03 pattern:03 flush:03 
X-Spam-Checker-Version: SpamAssassin 3.0.3 (2005-04-27) on yquem.inria.fr
X-Spam-Level: 
X-Spam-Status: No, score=0.0 required=5.0 tests=none autolearn=disabled 
	version=3.0.3


On Sat, 3 Dec 2005 16:16:29 -0800 (PST)
In <20051204001629.39621.qmail@web34610.mail.mud.yahoo.com>
Ker Lutyn <ker527mail@yahoo.com> wrote:
> Here's my reworking of this example to make the thread go away if the buffered
> channel becomes "unreachable". The strategy is to allocate the channel object
> at the very end and associate a Gc.finalise function with it that syncs an
> event on a kill channel with the thread.

> Does this look like a reasonable design pattern for this?

I think the strategy is reasonable. But the pattern can be more simple.

let make_gc_event v =
  let gc_channel = new_channel () in
  let gc_send () = sync (send gc_channel ()) in
  let finalise _ = ignore (Thread.create gc_send ()) in
  Gc.finalise finalise v;
  wrap (receive gc_channel)

usage is as follow:

  let bc = i, o in
  let gc = make_gc_event bc in
  let rec loop q =
    select [
      wrap (receive i) (fun x -> let ... in loop q);
      wrap (send o v) (fun _ -> loop q);
      gc (fun () -> Printf.printf "killed\n"; flush stdout; ())
    ]
  in
  ignore (Thread.create loop q);
  bc

----
 osiire

