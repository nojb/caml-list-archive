Return-Path: <a.baretta@barettadeit.com>
X-Original-To: caml-list@yquem.inria.fr
Delivered-To: caml-list@yquem.inria.fr
Received: from concorde.inria.fr (concorde.inria.fr [192.93.2.39])
	by yquem.inria.fr (Postfix) with ESMTP id CCB9EBB9C
	for <caml-list@yquem.inria.fr>; Mon,  5 Dec 2005 10:05:42 +0100 (CET)
Received: from mail.barettadeit.com (h213-255-109-130.albacom.net [213.255.109.130] (may be forged))
	by concorde.inria.fr (8.13.0/8.13.0) with ESMTP id jB595gRT017485
	for <caml-list@yquem.inria.fr>; Mon, 5 Dec 2005 10:05:42 +0100
Received: from [10.0.0.10] (alex.barettalocal.com [10.0.0.10])
	by mail.barettadeit.com (Postfix) with ESMTP id 7040B367B99;
	Mon,  5 Dec 2005 10:06:42 +0100 (CET)
Message-ID: <439402F2.60708@barettadeit.com>
Date: Mon, 05 Dec 2005 10:05:54 +0100
From: Alessandro Baretta <a.baretta@barettadeit.com>
User-Agent: Debian Thunderbird 1.0.7 (X11/20051017)
X-Accept-Language: en-us, en
MIME-Version: 1.0
To: skaller <skaller@users.sourceforge.net>
Cc: caml-list@yquem.inria.fr
Subject: Re: [Caml-list] Another nasty with ocamlyacc: magic needed?
References: <1133760933.8957.125.camel@rosella>	<4393E75C.9000608@barettadeit.com> <1133772769.8957.168.camel@rosella>
In-Reply-To: <1133772769.8957.168.camel@rosella>
Content-Type: text/plain; charset=ISO-8859-1; format=flowed
Content-Transfer-Encoding: 7bit
X-Miltered: at concorde with ID 439402E6.000 by Joe's j-chkmail (http://j-chkmail.ensmp.fr)!
X-Spam: no; 0.00; baretta:01 baretta:01 barettadeit:01 caml-list:01 ocamlyacc:01 parser:01 parser:01 grammar:01 lexer:01 mli:01 ocamlc:01 ml':01 ocamlyacc:01 functor:01 whereby:01 
X-Spam-Checker-Version: SpamAssassin 3.0.3 (2005-04-27) on yquem.inria.fr
X-Spam-Level: 
X-Spam-Status: No, score=0.1 required=5.0 tests=FORGED_RCVD_HELO 
	autolearn=disabled version=3.0.3

skaller wrote:

> I do. It is useful. But the secondary parser is an RD parser
> interpreter. The idea isn't to allow arbitrary grammar
> extensions .. only to make particular yacc productions
> open-recursive closed by the dynamically built table
> of extensions.
> 
> Thus the RD parser calls back into yacc entry points,
> and, the yacc productions call into the RD parser entry
> points. This is organised via the lexer.

By applying the 'ocamlyacc parser.mly; rm parser.mli; ocamlc -i parser.ml' 
approach, you can enclose the code generated by ocamlyacc into a structure. I 
used this approach when I was young and inexperienced to generate a functor from 
a parser definition, whereby the parser actions called a bunch of functions 
passed as parameters to the functor. I can also imagine that, possibly with some 
help from pa_ocamllex, you can define a pair of mutually recursive lexer and 
parser modules, which is about as far as you think about going with the yacc 
architecture.

All this does require some "black magic", but no Obj.magic, which is rather neat.

Alex

-- 
*********************************************************************
http://www.barettadeit.com/
Baretta DE&IT
A division of Baretta SRL

tel. +39 02 370 111 55
fax. +39 02 370 111 54

Our technology:

The Application System/Xcaml (AS/Xcaml)
<http://www.asxcaml.org/>

The FreerP Project
<http://www.freerp.org/>

