Received: (from weis@localhost) by pauillac.inria.fr (8.7.6/8.7.3) id NAA05702 for caml-red; Mon, 2 Oct 2000 13:29:37 +0200 (MET DST)
Received: from nez-perce.inria.fr (nez-perce.inria.fr [192.93.2.78]) by pauillac.inria.fr (8.7.6/8.7.3) with ESMTP id LAA01365 for <caml-list@pauillac.inria.fr>; Mon, 2 Oct 2000 11:23:36 +0200 (MET DST)
Received: from beaune.inria.fr (beaune.inria.fr [128.93.8.3])
	by nez-perce.inria.fr (8.10.0/8.10.0) with ESMTP id e929Nan07723
	for <caml-list@inria.fr>; Mon, 2 Oct 2000 11:23:36 +0200 (MET DST)
Received: by beaune.inria.fr (8.8.8/1.1.22.3/14Sep99-0328PM)
	id LAA0000023984; Mon, 2 Oct 2000 11:23:36 +0200 (MET DST)
Date: Mon, 2 Oct 2000 11:23:36 +0200 (MET DST)
From: Damien Doligez <Damien.Doligez@inria.fr>
Message-Id: <200010020923.LAA0000023984@beaune.inria.fr>
To: caml-list@inria.fr
Subject: Re:  Garbage collection in OCaml
Sender: weis@pauillac.inria.fr

>From: "David McClain" <dmcclain@azstarnet.com>

>I have a long running analysis program written in compiled OCaml (ocamlopt).
>If I let it run without interference it gradually allocates more and more
>memory until the system swap space is exhausted. At that point the program
>bombs off with an "out of memory" errror - probably generated by the OCaml
>array management routines.

Most likely, a fragmentation problem.  If you're using a lot of arrays
or strings with different sizes, it can happen.


>OTOH, I found by tinkering that placing a Gc.compact() in a periodically
>performed place, I manage to keep the entire system running within about 70
>MBytes. (My machines all have 256 MB RAM or more).

Thus we know for sure it was a fragmentation problem.


>I have found that placing a Gc.full_major() does virtually nothing to
>prevent the exhaustion of memory, although it slows it down ever so
>slightly.

Gc.full_major() is not going to help, that's normal.


>The program was compiled to run with the default GC settings (whatever those
>are). That is to say, I did nothing to configure the GC system at program
>startup.
>
>Is this behavior normal? Must I plant strategic Gc.compact() in my code? I
>would have thought the GC would be more self monitoring.

Calling Gc.compact() is one solution.  You could also try setting
max_overhead in the Gc.control record.  For example, if you do:

  Gc.set { (Gc.get ()) with Gc.max_overhead = 200 }

then Gc.compact() will get called automatically when the free memory
is 200% the size of the live data.  This setting is not activated by
default because compaction is not incremental, so it introduces a long
pause in the computation, which would be annoying for an interactive
program.

-- Damien


