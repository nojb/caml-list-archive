Received: (from majordomo@localhost) by pauillac.inria.fr (8.7.6/8.7.3) id MAA31470; Fri, 14 Mar 2003 12:20:42 +0100 (MET)
X-Authentication-Warning: pauillac.inria.fr: majordomo set sender to owner-caml-list@pauillac.inria.fr using -f
Received: from nez-perce.inria.fr (nez-perce.inria.fr [192.93.2.78]) by pauillac.inria.fr (8.7.6/8.7.3) with ESMTP id MAA30989 for <caml-list@pauillac.inria.fr>; Fri, 14 Mar 2003 12:20:41 +0100 (MET)
Received: from nexus.stwing.upenn.edu (NEXUS.STWING.UPENN.EDU [165.123.132.61])
	by nez-perce.inria.fr (8.11.1/8.11.1) with ESMTP id h2EBKeX20317
	for <caml-list@inria.fr>; Fri, 14 Mar 2003 12:20:40 +0100 (MET)
Received: from force.stwing.upenn.edu (daemon@force.stwing.upenn.edu [165.123.132.65])
	by nexus.stwing.upenn.edu (8.12.8/8.12.8) with ESMTP id h2EBKcBD017093
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=OK)
	for <caml-list@inria.fr>; Fri, 14 Mar 2003 06:20:39 -0500 (EST)
Received: (from wlovas@localhost)
	by force.stwing.upenn.edu (8.12.8/8.12.8) id h2EBKcHE001808
	for caml-list@inria.fr; Fri, 14 Mar 2003 06:20:38 -0500 (EST)
Date: Fri, 14 Mar 2003 06:20:37 -0500
From: William Lovas <wlovas@stwing.upenn.edu>
To: Caml-list <caml-list@inria.fr>
Subject: Re: [Caml-list] poll - need for a good introductory OCaml book (LONG)
Message-ID: <20030314112037.GA1373@force.stwing.upenn.edu>
Mail-Followup-To: Caml-list <caml-list@inria.fr>
References: <20030314095135.84497.qmail@web41204.mail.yahoo.com> <20030314103626.84986.qmail@web11008.mail.yahoo.com>
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20030314103626.84986.qmail@web11008.mail.yahoo.com>
User-Agent: Mutt/1.4i
X-Spam: no; 0.00; lovas:01 wlovas:01 stwing:01 caml-list:01 introductory:99 sergey:99 restate:01 beginner's:01 haskell:01 languages':01 non-trivial:01 o'caml's:01 hooks:01 segue:99 ocaml:01 
Sender: owner-caml-list@pauillac.inria.fr
Precedence: bulk

On Fri, Mar 14, 2003 at 02:36:26AM -0800, Sergey Goldgaber wrote:
> Now, it's probably the case that once I know one functional
> language others will be easy to pick up.  But why should I have to
> learn two languages if I'm really only going to be focussing on
> one of them?  One of them will likely go to waste (along with the
> tons of other languages I've already learned).

What do you mean by "go to waste"?  If learning language B was the
key factor in your learning of language A, did language B really go
to waste?

I know you've heard this before, but let me restate it again in this
context: to really learn O'Caml, you have to learn the core ideas of
functional programming, and these core ideas are nearly identical in
all functional programming languages.

So if you happen to find the perfect beginner's Haskell tutorial out
there, don't fret -- have a look!  You'll have to learn a bit of new
syntax here and there, but when you come to understand O'Caml -- and
i mean *really* understand O'Caml -- it will be more than worth your
while.

[things get pretty meta after this point -- reader beware.]

Let me go out on a limb here and say that everytime we learn something
new, we do so by association with something we already know.  That's
why once you know one conventional programming language, it's easy to
pick up another.  That's also why so many programming language tutorials
look alike -- the author hopes to leverage your implicit knowledge of
the subject to teach you his particular instance.  The reason O'Caml
is hard to learn -- and the reason it has no tutorial similar to more
conventional programming languages' -- is that it's fundamentally
different in a non-trivial way: it strongly encourages the functional
style of programming.

Unfortunately for O'Caml's popularity, people who want to learn O'Caml
have to, in essence, re-learn programming, because the basic concepts
of functional programming do not map cleanly onto the basic concepts of
typical imperative programming.  So far, O'Caml has survived through a
vociferous userbase trying to convince people that the effort invested
is *worth it*, because functional programming is fundamentally *better*
(in some sense) than conventional imperative programming.  (Well, more
than just that *grin*, but it helps, i'm sure.)

Maybe i'm being too idealistic here, but i think a "perfect" tutorial
for O'Caml should focus on the ways it's different from other programming
languages, not the ways it's the same.  Perhaps such a tutorial (if it
doesn't exist already) could be prefaced by a number of "O'Caml for the
X programmer" hooks, for each conventional popular language X, just to
get programmers well-versed in X excited about O'Caml, at which point
they can segue into this "perfect" tutorial and learn what functional
programming is all about. :)

cheers,
William

-------------------
To unsubscribe, mail caml-list-request@inria.fr Archives: http://caml.inria.fr
Bug reports: http://caml.inria.fr/bin/caml-bugs FAQ: http://caml.inria.fr/FAQ/
Beginner's list: http://groups.yahoo.com/group/ocaml_beginners

