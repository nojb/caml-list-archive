Received: (from majordomo@localhost) by pauillac.inria.fr (8.7.6/8.7.3) id NAA00582; Fri, 14 Mar 2003 13:16:43 +0100 (MET)
X-Authentication-Warning: pauillac.inria.fr: majordomo set sender to owner-caml-list@pauillac.inria.fr using -f
Received: from nez-perce.inria.fr (nez-perce.inria.fr [192.93.2.78]) by pauillac.inria.fr (8.7.6/8.7.3) with ESMTP id NAA00758 for <caml-list@pauillac.inria.fr>; Fri, 14 Mar 2003 13:16:41 +0100 (MET)
X-SPAM-Warning: Sending machine is listed in blackholes.five-ten-sg.com
Received: from web11008.mail.yahoo.com (web11008.mail.yahoo.com [216.136.131.58])
	by nez-perce.inria.fr (8.11.1/8.11.1) with SMTP id h2ECGeX22210
	for <caml-list@inria.fr>; Fri, 14 Mar 2003 13:16:40 +0100 (MET)
Message-ID: <20030314121639.96651.qmail@web11008.mail.yahoo.com>
Received: from [24.189.36.21] by web11008.mail.yahoo.com via HTTP; Fri, 14 Mar 2003 04:16:39 PST
Date: Fri, 14 Mar 2003 04:16:39 -0800 (PST)
From: Sergey Goldgaber <sgoldgaber@yahoo.com>
Subject: Re: [Caml-list] poll - need for a good introductory OCaml book (LONG)
To: William Lovas <wlovas@stwing.upenn.edu>, Caml-list <caml-list@inria.fr>
In-Reply-To: <20030314112037.GA1373@force.stwing.upenn.edu>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
X-Spam: no; 0.00; sergey:99 caml-list:01 introductory:99 lovas:01 wlovas:01 stwing:01 relearning:01 restate:01 beginner's:01 haskell:01 sicp:01 teaches:99 nonetheless:01 o'caml's:01 intuitively:01 
Sender: owner-caml-list@pauillac.inria.fr
Precedence: bulk

--- William Lovas <wlovas@stwing.upenn.edu> wrote:
>
> What do you mean by "go to waste"?  If learning language B was the
> key factor in your learning of language A, did language B really go
> to waste?

Of course not.  It's not a complete waste that I once learned BASIC
and Logo.  But I haven't used them in twenty years and am probably
never going to use them again (well, I might use Logo again if I am
to teach programming, but that would really require relearning it
anyway).

> I know you've heard this before, but let me restate it again in this
> context: to really learn O'Caml, you have to learn the core ideas of
> functional programming, and these core ideas are nearly identical in
> all functional programming languages.

Yes.  I recognize that.  But why can't I learn those ideas in OCaml?
Why must I learn yet another language?

> So if you happen to find the perfect beginner's Haskell tutorial out
> there, don't fret -- have a look!  You'll have to learn a bit of new
> syntax here and there, but when you come to understand O'Caml -- and
> i mean *really* understand O'Caml -- it will be more than worth your
> while.

I am open to just such an approach.  In fact, I have been slowly
going through the SICP, which teaches Scheme, and am going to have a
look at Noel Welsh's recommendation as well.  Nonetheless, I know it
will take twice the time and effor to learn two languages than one
(well, maybe 1.5 times the effort), and one of them I'll likely
never use again once it's helped me to learn the one I'm really
after: OCaml (at this point).  So while it won't be a complete
waste, there will be at least some redundancy involved.

> Unfortunately for O'Caml's popularity, people who want to learn
> O'Caml have to, in essence, re-learn programming, because the
> basic concepts of functional programming do not map cleanly onto
> the basic concepts of typical imperative programming.

Yes, I think part of the reason is that functional programming is
"just different" from imperative programming.  However, an
additional reason may be that imperative programming is just
intuitively easier to grasp.  I have yet to hear about or from
people for whom a functional language was their first and they found
learning it as easy as do people who learn an imperative language as
their first language.  That is, unless they are already familiar
with Lambda calculus, which seems to figure greatly in functional
programming.

> Maybe i'm being too idealistic here, but i think a "perfect" tutorial
> for O'Caml should focus on the ways it's different from other
> programming languages, not the ways it's the same.

I think those distinctions are definately crucial to really
understanding OCaml.  In fact, it is precisely in those aspects of
the language which are very different from the imperative style that
I'm used to, that I am having the most trouble.  So a tuturial that
did a great job explaining and teaching those aspects would be
great.

But I'm not sure that those difficult aspects should be the very
first thing that a newbie should encounter.  I think a more fruitful
approach would be to show them first that the language can be useful
in very similar ways to ways they are used to (OCaml's imperative
features).  They will thus more quickly grasp the syntax, become
comfortable with the compiler/toplevel and should be able to slowly,
one at a time start to apply what they learn concerning the more
difficult aspects.

Not that any tutorial jumps right out and tries to teach the newbie
difficult idioms, but they usually leave the imperative aspects
of the language 'till later, which I think is a mistake.

I don't share your, implied, fear that someone might get turned off
if a tutorial starts off by showing only language features which
will be familiar to imperative language programmers.  If they're
learning OCaml then they know the language is different and they
know it has all of these magical features.  Just because they don't
learn the magic right away doesn't mean that they'll abandon the
quest.

In fact, I think they'll be heartened to see that the language is
learnable, in contrast to the reaction they'd likely have to a
trial-by-fire, throw them in the deep-end approach that would show
them the language is different, all right...  But it will be
frustrating, and they'll have a very hard time making sense of it,
and especially applying what they've learned.

> Perhaps such a tutorial (if it doesn't exist already) could be
> prefaced by a number of "O'Caml for the X programmer" hooks,
> for each conventional popular language X, just to
> get programmers well-versed in X excited about O'Caml, at which point
> they can segue into this "perfect" tutorial and learn what functional
> programming is all about. :)

Yes.  In fact, there's already a short "C++/Java programmer's
introduction to Objective Caml".  I don't know either language, so I
can't really comment on that.  But I think the important thing is to
go from imperative to functional style, rather than a particular
language.  I just picked C in my earlier post because it was so
widespread and most everyone will be able to understand if OCaml is
juxtaposed with it.


  --Sergey


__________________________________________________
Do you Yahoo!?
Yahoo! Web Hosting - establish your business online
http://webhosting.yahoo.com

-------------------
To unsubscribe, mail caml-list-request@inria.fr Archives: http://caml.inria.fr
Bug reports: http://caml.inria.fr/bin/caml-bugs FAQ: http://caml.inria.fr/FAQ/
Beginner's list: http://groups.yahoo.com/group/ocaml_beginners

