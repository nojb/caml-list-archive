Received: (from majordomo@localhost) by pauillac.inria.fr (8.7.6/8.7.3) id PAA25093; Wed, 13 Feb 2002 15:23:02 +0100 (MET)
X-Authentication-Warning: pauillac.inria.fr: majordomo set sender to owner-caml-list@pauillac.inria.fr using -f
Received: from nez-perce.inria.fr (nez-perce.inria.fr [192.93.2.78]) by pauillac.inria.fr (8.7.6/8.7.3) with ESMTP id PAA01122 for <caml-list@pauillac.inria.fr>; Wed, 13 Feb 2002 15:23:01 +0100 (MET)
Received: from indigo.recherche.enac.fr (indigo.recherche.enac.fr [195.220.158.66])
	by nez-perce.inria.fr (8.11.1/8.11.1) with ESMTP id g1DEN0r27961
	for <caml-list@inria.fr>; Wed, 13 Feb 2002 15:23:00 +0100 (MET)
Received: from mauve.recherche.enac.fr (mail@mauve.recherche.enac.fr [10.31.3.2]) by indigo.recherche.enac.fr (8.8.6 (PHNE_14041)/8.6.11) with ESMTP id PAA20278 for <caml-list@inria.fr>; Wed, 13 Feb 2002 15:22:59 +0100 (MET)
Received: from sepia.recherche.enac.fr ([10.31.1.82])
	by mauve.recherche.enac.fr with smtp (Exim 3.31 #1 (Debian))
	id 16b0JG-0006jL-00
	for <caml-list@inria.fr>; Wed, 13 Feb 2002 15:22:58 +0100
Received: by sepia.recherche.enac.fr (sSMTP sendmail emulation); Wed, 13 Feb 2002 15:22:57 +0100
Date: Wed, 13 Feb 2002 15:22:57 +0100
From: "Pascal Brisset@sepia" <brisset@recherche.enac.fr>
To: caml-list@inria.fr
Subject: [Caml-list] Bad bad things
Mime-Version: 1.0 (generated by tm-edit 7.106)
Content-Type: text/plain; charset=US-ASCII
Message-Id: <E16b0JG-0006jL-00@mauve.recherche.enac.fr>
Sender: owner-caml-list@pauillac.inria.fr
Precedence: bulk



I'm trying to play with Obj.magic ... and get a segmentation fault.
I know I deserve it but ... maybe someone may help:

I want to store efficiently in a data-structure an update in a array;
I need to store triples (array, index, value) to be able to execute

	array.(index) <- value

I need to store in the same data (i.e. a list) such update
informations for different types.

My first solution was to use closures:

	type t = (unit -> unit) list

and to store (fun () -> array.(index) <- value), a closure which will
be called when necessary

This solution works correctly but my program uses a lot of memory and
investigation about memory (and cpu) consumption of this closure solution
becomes essential.

My second solution is to hack the type-checker using Obj.magic to
store the triple (array, index, value). So I define

	type t = (string array * int * string) list
	let global = ref []

and my store function becomes

	let store array index value =
	  let array = Obj.magic array
	  and value = Obj.magic value in
	  global := (ref, index, value) :: !global

and to restore, I simply do something like

	List.iter (fun (a, i, v) -> a.(i) <- v) !global

This solution works for all my small tests (where GC is not required?)
but ends with a segmentation fault for larger examples.


Should I forget this nasty hack and keep my (expensive ?) closures ?

--Pascal
	

	
-------------------
Bug reports: http://caml.inria.fr/bin/caml-bugs  FAQ: http://caml.inria.fr/FAQ/
To unsubscribe, mail caml-list-request@inria.fr  Archives: http://caml.inria.fr

