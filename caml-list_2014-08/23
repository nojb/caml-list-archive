Return-Path: <trevorsummerssmith@gmail.com>
X-Original-To: caml-list@sympa.inria.fr
Delivered-To: caml-list@sympa.inria.fr
Received: from mail2-relais-roc.national.inria.fr (mail2-relais-roc.national.inria.fr [192.134.164.83])
	by sympa.inria.fr (Postfix) with ESMTPS id C51E27F747
	for <caml-list@sympa.inria.fr>; Fri,  8 Aug 2014 00:06:35 +0200 (CEST)
Received-SPF: None (mail2-smtp-roc.national.inria.fr: no sender
  authenticity information available from domain of
  trevorsummerssmith@gmail.com) identity=pra;
  client-ip=209.85.214.179;
  receiver=mail2-smtp-roc.national.inria.fr;
  envelope-from="trevorsummerssmith@gmail.com";
  x-sender="trevorsummerssmith@gmail.com";
  x-conformance=sidf_compatible
Received-SPF: Pass (mail2-smtp-roc.national.inria.fr: domain of
  trevorsummerssmith@gmail.com designates 209.85.214.179 as
  permitted sender) identity=mailfrom;
  client-ip=209.85.214.179;
  receiver=mail2-smtp-roc.national.inria.fr;
  envelope-from="trevorsummerssmith@gmail.com";
  x-sender="trevorsummerssmith@gmail.com";
  x-conformance=sidf_compatible; x-record-type="v=spf1"
Received-SPF: None (mail2-smtp-roc.national.inria.fr: no sender
  authenticity information available from domain of
  postmaster@mail-ob0-f179.google.com) identity=helo;
  client-ip=209.85.214.179;
  receiver=mail2-smtp-roc.national.inria.fr;
  envelope-from="trevorsummerssmith@gmail.com";
  x-sender="postmaster@mail-ob0-f179.google.com";
  x-conformance=sidf_compatible
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: ArEBABv441PRVdazlGdsb2JhbABRCYNfVwSCK0iteTKZVoFjh0gBgREIFhABAQEBBwsLCRIrhAMBAQEDAQwGEQQZARsSCwEDAQsGAwILDQ0dAgIiAREBBQEKEgYTCAoJB4gLAQMJCA2RTJAhaospgXKDEIo+ChknAwpmhRERAQUOiBCBYYRyVwQHgnmBUgWFAAWJe4YzhmiBVJEqGCmDEByBeCEv
X-IPAS-Result: ArEBABv441PRVdazlGdsb2JhbABRCYNfVwSCK0iteTKZVoFjh0gBgREIFhABAQEBBwsLCRIrhAMBAQEDAQwGEQQZARsSCwEDAQsGAwILDQ0dAgIiAREBBQEKEgYTCAoJB4gLAQMJCA2RTJAhaospgXKDEIo+ChknAwpmhRERAQUOiBCBYYRyVwQHgnmBUgWFAAWJe4YzhmiBVJEqGCmDEByBeCEv
X-IronPort-AV: E=Sophos;i="5.01,820,1400018400"; 
   d="scan'208";a="88651162"
Received: from mail-ob0-f179.google.com ([209.85.214.179])
  by mail2-smtp-roc.national.inria.fr with ESMTP/TLS/RC4-SHA; 08 Aug 2014 00:06:34 +0200
Received: by mail-ob0-f179.google.com with SMTP id wn1so3434539obc.24
        for <caml-list@inria.fr>; Thu, 07 Aug 2014 15:06:33 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20120113;
        h=mime-version:in-reply-to:references:date:message-id:subject:from:to
         :cc:content-type;
        bh=9W9edcWAgXBk2cq2RujP7bvgpi8NtMsCFiT9ynMDpXQ=;
        b=bLe+aqirpKxT9fSzmTt8wCJ1U44fVNZHi0YyLM/n5cHaCLDPuw+KzUvDtadfPDGE2b
         30PI+UqRjYeoWDCYKly4HXRK/YbXS4NtwJny6bPpRKJkbEY9AzSR3mrc/lp7wIV3HiFH
         2GReVvVD9WIscKzHBZEhitc9SmSmZ6eboBijmbiB4bYGdWclp2wSut2Us9kEnnsiTYV0
         u8KzCY3o0iW3IMKFtildJ5ntWg9WoSpeUTGltqbVlJRZ5SLu+uUoDExW92z/2uqiZpgE
         leaRHoCGJPVXT+5JQBp7Pu8ofk3yIB/gQKfAyDRFy/mjzuHR4Yqb2O9qsc+VELTgOw6W
         jxyw==
MIME-Version: 1.0
X-Received: by 10.182.118.193 with SMTP id ko1mr26190478obb.45.1407449193410;
 Thu, 07 Aug 2014 15:06:33 -0700 (PDT)
Received: by 10.182.128.100 with HTTP; Thu, 7 Aug 2014 15:06:33 -0700 (PDT)
In-Reply-To: <53E24B96.8080402@etorok.net>
References: <CAG-KTt_4CUmxmpoww-5aAR_4o5WH7hq_Dah1ENrHzA1ZHq4ogA@mail.gmail.com>
	<53E24B96.8080402@etorok.net>
Date: Thu, 7 Aug 2014 18:06:33 -0400
Message-ID: <CAG-KTt9wSje3EbR2Zzzo3CqB8Lfj4iNS1Ki91u0AEC9HZ6ZdBg@mail.gmail.com>
From: Trevor Smith <trevorsummerssmith@gmail.com>
To: =?UTF-8?B?VMO2csO2ayBFZHdpbg==?= <edwin+ml-ocaml@etorok.net>
Cc: caml-list@inria.fr
Content-Type: multipart/alternative; boundary=089e0115ea303674db0500114dc3
Subject: Re: [Caml-list] Type Constraints and .mli

--089e0115ea303674db0500114dc3
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Edwin,

Thank you for your response.

You are correct that the "val t" in my example should read "type t".

My main goal is one of readability: I want to have large swathes of the
codebase only use the immutable interface. A few, but very few, parts of
the codebase will use the mutable interface. Ideally, I want the developer
reading the .mli files to quickly and easily understand what interfaces do
what. The standard way of adding the type constraints add a lot of syntax
and make it (slightly) harder to read. My entire question is sort of a
nitpick.

I am interested in your use of polymorphic variants to deal with this
issue: that would actually give better compiler errors than what I am
currently implemented. Thank you for the suggestion. I will mull that and
see if I think of any downsides to that approach.

Trevor


On Wed, Aug 6, 2014 at 11:36 AM, T=C3=B6r=C3=B6k Edwin <edwin+ml-ocaml@etor=
ok.net>
wrote:

> On 08/06/2014 03:14 PM, Trevor Smith wrote:
> > Hello,
> >
> > I have a question about using .mli files for increased readability. I
> think my question boils down to: "Can one tersely add type constraints to=
 a
> signature defined in a .mli in that same .mli file?"
> >
> > Detailed problem: You want to have a read interface and a write
> interface for the same implementation.
> >
> > We'll use a trivial example with a character and a name.
> >
> > module type CharacterSig =3D sig
> >   val t
> >   val create : string -> t
> >   val name : t -> string
> > end
> >
> > module type MutableCharacterSig =3D sig
> >   val t
> >   val create : string -> t
> >   val name : t -> string
> >   val set_name : t -> string -> unit
> > end
> >
> > module CharacterImpl =3D struct
> >   type t =3D {name : string ref}
> >   let create name  =3D
> >     {name =3D ref name }
> >   let name c =3D !(c.name <http://c.name/>)
> >   let set_name c name =3D
> >     c.name <http://c.name/> :=3D name
> > end
> >
> > module Character =3D (CharacterImpl : CharacterSig with type t =3D
> CharacterImpl.t)
> > module MutableCharacter =3D (CharacterImpl : MutableCharacterSig with t=
ype
> t =3D CharacterImpl.t)
> >
> > But what I would like is to specify the read and write signatures in
> .mli files for a more readable codebase.
> >
> > So:
> >
> > character.mli:
> >   val t
>
> shouldn't this be a type?
>
> >   val create : string -> t
> >   val name : t -> string
> >
> > mCharacter.mli:
> >   val t
> >   val create : string -> t
> >   val name : t -> string
> >   val set_name : t -> string -> unit
> >
> > characterImpl.ml (* ... implementation as above ... *)
> >
> > However, it is not clear to me that there is a way to attach the type
> constraint to character.mli and mCharacter.mli, while keeping the terse
> readability of the .mli file. One idea for a solution, would be to
> reference a "this" so that the interface could show that it was being
> implemented by CharacterImpl, and include the type constraint.
>
> Not sure I understood exactly what you want to do, but using 'include
> module type of' and 'type t =3D CharacterImpl.t' should work:
>
> character.mli
> type t =3D CharacterImpl.t
> val create : string -> t
> val name : t -> string
>
> character.ml:
> include CharacterImpl
>
> mCharacter.mli:
> include module type of Character
> val set_name : t -> string -> unit
>
> mCharacter.ml:
> include CharacterImpl
>
> characterImpl.ml:
> type t =3D {name : string ref}
> let create name  =3D
>   {name =3D ref name }
> let name c =3D !(c.name)
> let set_name c name =3D
>   c.name :=3D name
>
> However in this case Character.t =3D MCharacter.t =3D CharacterImpl.t, so=
 you
> won't get the type safety you want
> (A Character.t can still be modified by MCharacter.set_name).
>
> Perhaps it'd be better to use different types, though to_character is not
> the identity function:
>
> character.mli:
> type t
> val create : string -> t
> val name : t -> string
>
> mCharacter.mli:
> include module type of Character
> val set_name : t -> string -> unit
> val to_character : t -> Character.t
>
> character.ml:
> include MCharacter
>
> mCharacter.ml:
> type t =3D {name : string ref}
> let create name  =3D
>   {name =3D ref name }
> let name c =3D !(c.name)
> let set_name c name =3D
>   c.name :=3D name
>
> let to_character x =3D Character.create (name x)
>
> In fact you should probably take a look at String and Bytes type in OCaml
> 4.02 (and the ocaml-bytes compatibility lib for <4.0.2).
>
> I'd prefer something simpler though:
>
> character.ml:
> type u =3D {name : string ref}
> type 'a t =3D u
>
> let create name  =3D
>   {name =3D ref name }
> let create_ro =3D create
> let create_rw =3D create
> let name c =3D !(c.name)
> let set_name c name =3D
>   c.name :=3D name
> let readonly x =3D x
>
> character.mli:
> type 'a t constraint 'a =3D [< `W | `R]
> val create_ro : string -> [`R] t
> val create_rw : string -> [`R | `W] t
> val name : 'a t -> string
> val set_name : [> `W] t -> string -> unit
> val readonly : [> `R] t -> [`R] t
>
> Best regards,
> --Edwin
>
> --
> Caml-list mailing list.  Subscription management and archives:
> https://sympa.inria.fr/sympa/arc/caml-list
> Beginner's list: http://groups.yahoo.com/group/ocaml_beginners
> Bug reports: http://caml.inria.fr/bin/caml-bugs
>

--089e0115ea303674db0500114dc3
Content-Type: text/html; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

<div dir=3D"ltr">Edwin,<div><br></div><div>Thank you for your response.</di=
v><div><br></div><div>You are correct that the &quot;val t&quot; in my exam=
ple should read &quot;type t&quot;.</div><div><br></div><div>My main goal i=
s one of readability: I want to have large swathes of the codebase only use=
 the immutable interface. A few, but very few, parts of the codebase will u=
se the mutable interface. Ideally, I want the developer reading the .mli fi=
les to quickly and easily understand what interfaces do what. The standard =
way of adding the type constraints add a lot of syntax and make it (slightl=
y) harder to read. My entire question is sort of a nitpick.</div>

<div><br></div><div>I am interested in your use of polymorphic variants to =
deal with this issue: that would actually give better compiler errors than =
what I am currently implemented. Thank you for the suggestion. I will mull =
that and see if I think of any downsides to that approach.</div>
<div><br></div><div>Trevor</div></div><div class=3D"gmail_extra"><br><br><d=
iv class=3D"gmail_quote">On Wed, Aug 6, 2014 at 11:36 AM, T=C3=B6r=C3=B6k E=
dwin <span dir=3D"ltr">&lt;<a href=3D"mailto:edwin+ml-ocaml@etorok.net" tar=
get=3D"_blank">edwin+ml-ocaml@etorok.net</a>&gt;</span> wrote:<br>
<blockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;border-left:1p=
x #ccc solid;padding-left:1ex"><div class=3D"">On 08/06/2014 03:14 PM, Trev=
or Smith wrote:<br>
&gt; Hello,<br>
&gt;<br>
&gt; I have a question about using .mli files for increased readability. I =
think my question boils down to: &quot;Can one tersely add type constraints=
 to a signature defined in a .mli in that same .mli file?&quot;<br>
&gt;<br>
&gt; Detailed problem: You want to have a read interface and a write interf=
ace for the same implementation.<br>
&gt;<br>
&gt; We&#39;ll use a trivial example with a character and a name.<br>
&gt;<br>
&gt; module type CharacterSig =3D sig<br>
&gt; =C2=A0 val t<br>
&gt; =C2=A0 val create : string -&gt; t<br>
&gt; =C2=A0 val name : t -&gt; string<br>
&gt; end<br>
&gt;<br>
&gt; module type MutableCharacterSig =3D sig<br>
&gt; =C2=A0 val t<br>
&gt; =C2=A0 val create : string -&gt; t<br>
&gt; =C2=A0 val name : t -&gt; string<br>
&gt; =C2=A0 val set_name : t -&gt; string -&gt; unit<br>
&gt; end<br>
&gt;<br>
&gt; module CharacterImpl =3D struct<br>
&gt; =C2=A0 type t =3D {name : string ref}<br>
&gt; =C2=A0 let create name =C2=A0=3D<br>
&gt; =C2=A0 =C2=A0 {name =3D ref name }<br>
</div>&gt; =C2=A0 let name c =3D !(<a href=3D"http://c.name" target=3D"_bla=
nk">c.name</a> &lt;<a href=3D"http://c.name/" target=3D"_blank">http://c.na=
me/</a>&gt;)<br>
<div class=3D"">&gt; =C2=A0 let set_name c name =3D<br>
</div>&gt; =C2=A0 =C2=A0 <a href=3D"http://c.name" target=3D"_blank">c.name=
</a> &lt;<a href=3D"http://c.name/" target=3D"_blank">http://c.name/</a>&gt=
; :=3D name<br>
<div class=3D"">&gt; end<br>
&gt;<br>
&gt; module Character =3D (CharacterImpl : CharacterSig with type t =3D Cha=
racterImpl.t)<br>
&gt; module MutableCharacter =3D (CharacterImpl : MutableCharacterSig with =
type t =3D CharacterImpl.t)<br>
&gt;<br>
&gt; But what I would like is to specify the read and write signatures in .=
mli files for a more readable codebase.<br>
&gt;<br>
&gt; So:<br>
&gt;<br>
&gt; character.mli:<br>
&gt; =C2=A0 val t<br>
<br>
</div>shouldn&#39;t this be a type?<br>
<div class=3D""><br>
&gt; =C2=A0 val create : string -&gt; t<br>
&gt; =C2=A0 val name : t -&gt; string<br>
&gt;<br>
&gt; mCharacter.mli:<br>
&gt; =C2=A0 val t<br>
&gt; =C2=A0 val create : string -&gt; t<br>
&gt; =C2=A0 val name : t -&gt; string<br>
&gt; =C2=A0 val set_name : t -&gt; string -&gt; unit<br>
&gt;<br>
&gt; characterImpl.ml (* ... implementation as above ... *)<br>
&gt;<br>
&gt; However, it is not clear to me that there is a way to attach the type =
constraint to character.mli and mCharacter.mli, while keeping the terse rea=
dability of the .mli file. One idea for a solution, would be to reference a=
 &quot;this&quot; so that the interface could show that it was being implem=
ented by CharacterImpl, and include the type constraint.<br>

<br>
</div>Not sure I understood exactly what you want to do, but using &#39;inc=
lude module type of&#39; and &#39;type t =3D CharacterImpl.t&#39; should wo=
rk:<br>
<br>
character.mli<br>
type t =3D CharacterImpl.t<br>
<div class=3D"">val create : string -&gt; t<br>
val name : t -&gt; string<br>
<br>
</div><a href=3D"http://character.ml" target=3D"_blank">character.ml</a>:<b=
r>
include CharacterImpl<br>
<br>
mCharacter.mli:<br>
include module type of Character<br>
<div class=3D"">val set_name : t -&gt; string -&gt; unit<br>
<br>
</div>mCharacter.ml:<br>
include CharacterImpl<br>
<br>
characterImpl.ml:<br>
<div class=3D"">type t =3D {name : string ref}<br>
let create name =C2=A0=3D<br>
=C2=A0 {name =3D ref name }<br>
let name c =3D !(<a href=3D"http://c.name" target=3D"_blank">c.name</a>)<br>
let set_name c name =3D<br>
=C2=A0 <a href=3D"http://c.name" target=3D"_blank">c.name</a> :=3D name<br>
<br>
</div>However in this case Character.t =3D MCharacter.t =3D CharacterImpl.t=
, so you won&#39;t get the type safety you want<br>
(A Character.t can still be modified by MCharacter.set_name).<br>
<br>
Perhaps it&#39;d be better to use different types, though to_character is n=
ot the identity function:<br>
<br>
character.mli:<br>
<div class=3D"">type t<br>
val create : string -&gt; t<br>
val name : t -&gt; string<br>
<br>
</div>mCharacter.mli:<br>
include module type of Character<br>
<div class=3D"">val set_name : t -&gt; string -&gt; unit<br>
</div>val to_character : t -&gt; Character.t<br>
<br>
<a href=3D"http://character.ml" target=3D"_blank">character.ml</a>:<br>
include MCharacter<br>
<br>
mCharacter.ml:<br>
<div class=3D"">type t =3D {name : string ref}<br>
let create name =C2=A0=3D<br>
=C2=A0 {name =3D ref name }<br>
let name c =3D !(<a href=3D"http://c.name" target=3D"_blank">c.name</a>)<br>
let set_name c name =3D<br>
=C2=A0 <a href=3D"http://c.name" target=3D"_blank">c.name</a> :=3D name<br>
<br>
</div>let to_character x =3D Character.create (name x)<br>
<br>
In fact you should probably take a look at String and Bytes type in OCaml 4=
.02 (and the ocaml-bytes compatibility lib for &lt;4.0.2).<br>
<br>
I&#39;d prefer something simpler though:<br>
<br>
<a href=3D"http://character.ml" target=3D"_blank">character.ml</a>:<br>
type u =3D {name : string ref}<br>
type &#39;a t =3D u<br>
<div class=3D""><br>
let create name =C2=A0=3D<br>
=C2=A0 {name =3D ref name }<br>
</div>let create_ro =3D create<br>
let create_rw =3D create<br>
<div class=3D"">let name c =3D !(<a href=3D"http://c.name" target=3D"_blank=
">c.name</a>)<br>
let set_name c name =3D<br>
=C2=A0 <a href=3D"http://c.name" target=3D"_blank">c.name</a> :=3D name<br>
</div>let readonly x =3D x<br>
<br>
character.mli:<br>
type &#39;a t constraint &#39;a =3D [&lt; `W | `R]<br>
val create_ro : string -&gt; [`R] t<br>
val create_rw : string -&gt; [`R | `W] t<br>
val name : &#39;a t -&gt; string<br>
val set_name : [&gt; `W] t -&gt; string -&gt; unit<br>
val readonly : [&gt; `R] t -&gt; [`R] t<br>
<br>
Best regards,<br>
--Edwin<br>
<span class=3D"HOEnZb"><font color=3D"#888888"><br>
--<br>
Caml-list mailing list. =C2=A0Subscription management and archives:<br>
<a href=3D"https://sympa.inria.fr/sympa/arc/caml-list" target=3D"_blank">ht=
tps://sympa.inria.fr/sympa/arc/caml-list</a><br>
Beginner&#39;s list: <a href=3D"http://groups.yahoo.com/group/ocaml_beginne=
rs" target=3D"_blank">http://groups.yahoo.com/group/ocaml_beginners</a><br>
Bug reports: <a href=3D"http://caml.inria.fr/bin/caml-bugs" target=3D"_blan=
k">http://caml.inria.fr/bin/caml-bugs</a><br>
</font></span></blockquote></div><br></div>

--089e0115ea303674db0500114dc3--
