Return-Path: <weis@pauillac.inria.fr>
X-Original-To: caml-list@yquem.inria.fr
Delivered-To: caml-list@yquem.inria.fr
Received: from concorde.inria.fr (concorde.inria.fr [192.93.2.39])
	by yquem.inria.fr (Postfix) with ESMTP id 583B1BB81
	for <caml-list@yquem.inria.fr>; Fri, 18 Nov 2005 07:01:45 +0100 (CET)
Received: from pauillac.inria.fr (pauillac.inria.fr [128.93.11.35])
	by concorde.inria.fr (8.13.0/8.13.0) with ESMTP id jAI61iVK026957
	for <caml-list@yquem.inria.fr>; Fri, 18 Nov 2005 07:01:44 +0100
Received: from concorde.inria.fr (concorde.inria.fr [192.93.2.39]) by pauillac.inria.fr (8.7.6/8.7.3) with ESMTP id HAA05086 for <caml-list@pauillac.inria.fr>; Fri, 18 Nov 2005 07:01:44 +0100 (MET)
Received: from yl.is.s.u-tokyo.ac.jp (valentine.is.s.u-tokyo.ac.jp [133.11.12.32])
	by concorde.inria.fr (8.13.0/8.13.0) with ESMTP id jAI61ebl026943
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=NO)
	for <caml-list@inria.fr>; Fri, 18 Nov 2005 07:01:43 +0100
Received: from moai.yl.is.s.u-tokyo.ac.jp (tuba.is.s.u-tokyo.ac.jp [133.11.12.102])
	by yl.is.s.u-tokyo.ac.jp (8.13.5/8.13.5) with ESMTP id jAI614fL019862;
	Fri, 18 Nov 2005 15:01:05 +0900 (JST)
Date: Fri, 18 Nov 2005 15:00:54 +0900
Message-ID: <87iruqmr55.wl%furuse@yl.is.s.u-tokyo.ac.jp>
From: Jun Furuse <furuse@yl.is.s.u-tokyo.ac.jp>
To: Matt Gushee <matt@gushee.net>
Cc: caml-list@inria.fr
Subject: Re: [Caml-list] LablTk internals
In-Reply-To: <437CF642.8060302@gushee.net>
References: <437CF642.8060302@gushee.net>
User-Agent: Wanderlust/2.14.0 (Africa) SEMI/1.14.6 (Maruoka) FLIM/1.14.7
 (=?ISO-8859-4?Q?Sanj=F2?=) APEL/10.6 MULE XEmacs/21.4 (patch 17) (Jumbo
 Shrimp) (i386-debian-linux)
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=US-ASCII
X-Miltered: at concorde with ID 437D6E48.000 by Joe's j-chkmail (http://j-chkmail.ensmp.fr)!
X-Miltered: at concorde with ID 437D6E44.002 by Joe's j-chkmail (http://j-chkmail.ensmp.fr)!
X-Spam: no; 0.00; furuse:01 furuse:01 u-tokyo:01 caml-list:01 labltk:01 internals:01 makefile:01 dependencies:01 widget:01 makefiles:01 tkcompiler:01 tkcompiler:01 labltk:01 makefile:01 tokens:01 
X-Spam-Checker-Version: SpamAssassin 3.0.3 (2005-04-27) on yquem.inria.fr
X-Spam-Level: 
X-Spam-Status: No, score=0.0 required=5.0 tests=none autolearn=disabled 
	version=3.0.3

Hi,

>  * How are external support modules associated with modules generated
>    from Widgets.src? If I introduce a new module(s), do I need to modify
>    a Makefile, or are the dependencies all auto-detected? In the latter
>    case, what do I need to do so that
> 
>      option ValidationCommand
>
>    will work in a widget definition, where the ValidationCommand type is
>    defined in an external module?

Dont know... Long long ago we have tried to describe the dependency
information as detailed as possible in Makefiles, and some of them are
automatically created by tkcompiler executed by make. But I forget
this is perfect (i.e. type "make" does all the job) or not. 
I recommend to "make clean all" for sure. It is slow but safe.
  
>  * What do the prefixes 'builtin_', 'builtina_', 'builtinf_', and
>    'builtini_' mean, and why do some of the modules in 'builtin' have
>    these prefixes, while others have no prefix?

Ok, let me look at the source... Well,

builtin* things 
  They are inserted directly into tk.ml by tkcompiler.
  The difference of _, , f_ and i_ indicate where they should go.
  {labltk,camltk}/Makefile.gen:

  builtin: 
	Primitive definition of built-in types which are hard to describe
	inside Widgets.src. Such types are declared as external 
	in Widgets.src. Ex:

	type Index external % builtin_index.ml

  builtini:
	*i*nterface between Tk and Caml for the built-in types,
	for translation of tokens such as cCAMLtoTK* and cTKtoCAML*
	functions.

  builtinf:
	*f*unctioni definitions which are hard to write inside 
	Widgets.src. They will be available inside Tk module, so
	non-widget specific command should come here, such as
	bind command.

  builtina_empty: what's this ? I do not remember... Ignore it. :-)

non builtin* things
  They are usually defines widget class specific functions hard to
  describe in Widgets.src. To be incorporated to the module, these 
  external definition files must be declared using external keyword
  like:

	module Optionmenu {
	  external create "builtin/optionmenu"
        }

  In the above, the function create must be defined inside 
  builtin/optionmenu.ml.	

Best,
--
Jun

