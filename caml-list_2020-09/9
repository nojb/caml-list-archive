Return-Path: <SRS0=B7Tq=CR=polytechnique.org=alan.schmitt@bounces.m4x.org>
X-Original-To: caml-list@sympa.inria.fr
Delivered-To: caml-list@sympa.inria.fr
Received: from mail2-relais-roc.national.inria.fr (mail2-relais-roc.national.inria.fr [192.134.164.83])
	by sympa.inria.fr (Postfix) with ESMTPS id C9EBDE00D5
	for <caml-list@sympa.inria.fr>; Tue,  8 Sep 2020 15:11:21 +0200 (CEST)
Authentication-Results: mail2-smtp-roc.national.inria.fr; spf=Pass smtp.pra=alan.schmitt@polytechnique.org; spf=Pass smtp.mailfrom=SRS0=B7Tq=CR=polytechnique.org=alan.schmitt@bounces.m4x.org; spf=Pass smtp.helo=postmaster@mx1.polytechnique.org
Received-SPF: Pass (mail2-smtp-roc.national.inria.fr: domain of
  alan.schmitt@polytechnique.org designates 129.104.30.34 as
  permitted sender) identity=pra; client-ip=129.104.30.34;
  receiver=mail2-smtp-roc.national.inria.fr;
  envelope-from="SRS0=B7Tq=CR=polytechnique.org=alan.schmitt@bounces.m4x.org";
  x-sender="alan.schmitt@polytechnique.org";
  x-conformance=sidf_compatible; x-record-type="spf2.0"
Received-SPF: Pass (mail2-smtp-roc.national.inria.fr: domain of
  SRS0=B7Tq=CR=polytechnique.org=alan.schmitt@bounces.m4x.org
  designates 129.104.30.34 as permitted sender)
  identity=mailfrom; client-ip=129.104.30.34;
  receiver=mail2-smtp-roc.national.inria.fr;
  envelope-from="SRS0=B7Tq=CR=polytechnique.org=alan.schmitt@bounces.m4x.org";
  x-sender="SRS0=B7Tq=CR=polytechnique.org=alan.schmitt@bounces.m4x.org";
  x-conformance=sidf_compatible; x-record-type="spf2.0"
Received-SPF: Pass (mail2-smtp-roc.national.inria.fr: domain of
  postmaster@mx1.polytechnique.org designates 129.104.30.34 as
  permitted sender) identity=helo; client-ip=129.104.30.34;
  receiver=mail2-smtp-roc.national.inria.fr;
  envelope-from="SRS0=B7Tq=CR=polytechnique.org=alan.schmitt@bounces.m4x.org";
  x-sender="postmaster@mx1.polytechnique.org";
  x-conformance=sidf_compatible; x-record-type="v=spf1"
IronPort-PHdr: =?us-ascii?q?9a23=3AgWePLxUwcxmeDH5R565lOtSlfOTV8LGtZVwlr6E/?=
 =?us-ascii?q?grcLSJyIuqrYZRaPu6dThVPEFb/W9+hDw7KP9fy5BypZu8rK4ClKWacPfidNsd?=
 =?us-ascii?q?8RkQ0kDZzNImzAB9muURYHGt9fXkRu5XCxPBsdMs//Y1rPvi/6tmZKSV3wOgVv?=
 =?us-ascii?q?O+v6BJPZgdip2OCu4Z3TZBhDiCagbb9oIxi6sATcutMLjYd8Jas9xRjErmZVcO?=
 =?us-ascii?q?lK2G1kIk6ekQzh7cmq5p5j9CpQu/Ml98FeVKjxYro1Q79FAjk4Km45/MLkuwXN?=
 =?us-ascii?q?QguJ/XscT34ZkgFUDAjf7RH1RYn+vy3nvedgwiaaPMn2TbcpWTS+6qpgVRHlhD?=
 =?us-ascii?q?sbOzM/7WrYjdF+jL9AoBK5uRNw35LUbo+SNPp7ZKzdfNUaTndFUsteUyFNB4Wx?=
 =?us-ascii?q?Y4sMAeoHI+ZYrpL9p1oVohu6GwanGe3uyjhShnDrxq0xzuAtHA/a0AAlGd8FrX?=
 =?us-ascii?q?bao8jvNKoKUe670rTGwzvAYfxZxTjw85LHfgw7rPyWQb58bcjcxE8yHA3FlFWQ?=
 =?us-ascii?q?ronlMiuJ2+QJqWeb6fdrW/+zhG4nrgFxoySvxtsxgYTOnI0VzkrL9SNjzIYuOd?=
 =?us-ascii?q?K4SEt7Yd+4EJtMrCyaL4x2QsciQmF0pik11r0GuZi6fCgT1ZQo2QTTa/udc4iH?=
 =?us-ascii?q?+x/uUvuaLjhkinx/Yr2/mwqy/la6yu36TsS51FJHozdFnNTPuH0A2R7e5tSHR/?=
 =?us-ascii?q?Zy/kms1jSC2QDd5O9LJU05l7fWJ4IhzLIukpcfr0rNEzL4lkj3gqKaaFkp9+61?=
 =?us-ascii?q?4OrpZbXmo4WTN45yigzmKqQhhNC/AeUkMgcQR2ib/uG81Lj98kHjRrVFkOE2nr?=
 =?us-ascii?q?HesJ/GP8sbo6q5DxVS0oY55BazFzam0NICnXkGNl1JYhyHj5LxN1HBIfD4Efe/?=
 =?us-ascii?q?g0m3nztx2//GObjhDo3CLnjCjLfhfat95FVGxAoyytBT/51UCrAdIPLzR0/+r8?=
 =?us-ascii?q?bUAgU4Mwyz2+rnCs9y1oUAVmKUHq+ZKr3dvkGU5u41P+aMY4oVtC78K/c45//u?=
 =?us-ascii?q?iXs5lUUafamz0psabm2zEPd+I0iBfHbgnNMMHX0XsgYiQ+HmklOPXSJJa3u8UK?=
 =?us-ascii?q?8w/iw3BYy7AYvZWIyggLOM0D2mEpFKfGxKF1KBHWvueo6ZQfkDcjiSLdVkkjEc?=
 =?us-ascii?q?VbiuVYsh1Ra2uQ//xLtrM/DY+jUftZLn1Nl1+/Pcmg0y9TxyDsSdynyNQH9ukm?=
 =?us-ascii?q?MPXT8207hzoU17ylidzah1m+FUGcJX6v9TTws2KZHRw/Z0BtzuQA7McNiERE6j?=
 =?us-ascii?q?Qtq8ADExStwxw8UJY0Z4A9iskwzN0Te2D7INirGGBoI68rvE0nXvO8hw027G1K?=
 =?us-ascii?q?4lj1gmXstAK3Gphq559wjSHo7JjluWm7ytdaQG0y7A7H2MzW6Us0FeSgJwSrnK?=
 =?us-ascii?q?XXAaZkvXsdT5+ljPQKSpCbQ6NAtO1dCNKrBQZt3sglhHS+3vONPEY2K+g2uwHw?=
 =?us-ascii?q?qHxquQbIr2fGUQxDnSB1IBkwAX5HqGMQk+Bjy9o2/FFzxvFVfvY1v2/uVkqXO7?=
 =?us-ascii?q?SFU0zwCQYEF72bq14E1dufvJAfcM2PhM7CM+rR1wA1D72d/KXZ7I7QF+eu8UKY?=
 =?us-ascii?q?c2/1Fv0WPCqxc7P5CxK6QkgUQRJUA/tErr01BzC55cuckstnIjigRobeqT11ZZ?=
 =?us-ascii?q?XzeZxozrfLrNIGju9RShbL6Q10yN/syR//Im7P0+427ovASoClZqp3xj2t8TyH?=
 =?us-ascii?q?Cc45TWECIKVpbgTks89x57vqzXJC4n6NWHhjVXLaCov2qaiJoSD+w/x0P/Lo4O?=
 =?us-ascii?q?YpPBLxf7FoghP+brLeUrn1azaRddY7JY87MyNM69Mf7ayOisJukyxWv731QC25?=
 =?us-ascii?q?h01we3zwQ5SuPM2MxekfSIh02fUDPtkFqqssb2gJ1JIzYIETjmkHS2NMtqfqR3?=
 =?us-ascii?q?OL0zJyK2OcTul4dmgJr8R3NT9FiiHk4LnsizdkjLYg=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0BPBAAtzUdffSIeaIFgHgEBCxIMggyBI?=
 =?us-ascii?q?YEYAV5VMiyEN4kBiT2CEIU/jV+EA4FkEAEDAQwYAQ4FAQIEAQGETAKCSQIdBgE?=
 =?us-ascii?q?FMxMCEAEBBQEBAQIBAwMEARMBAQsUCIVfCCUMQxYBgV0MDAMDgyUBGAEIBAY6K?=
 =?us-ascii?q?yMDFAEGAwIRARcBFAoXARIUBoMNgnwFCpc1mjYZNXZ/M4Q7AQMDhGqBQg0CE4E?=
 =?us-ascii?q?WAYVHS4MBgnOBHg+BTT+BEYISSQdsgkUMCwEBAQEBgRkOARECAQghLYJhgmAEj?=
 =?us-ascii?q?00pBCQCAZMYknUqB4JmgQoEC4ZNgQCGKySELIZtgweBJoQbhCeTViGQAIIrh2k?=
 =?us-ascii?q?HdgiBXYYBileEUIFBKoEKPwEbAgwHMxowQ4I1ATMJYA1YgmaKagMXg06BPoEmg?=
 =?us-ascii?q?XU7hUEDPzMCAQEHLAIGAQkBAQMJdQEBBRMLAYsihCQBAQ?=
X-IPAS-Result: =?us-ascii?q?A0BPBAAtzUdffSIeaIFgHgEBCxIMggyBIYEYAV5VMiyEN4k?=
 =?us-ascii?q?BiT2CEIU/jV+EA4FkEAEDAQwYAQ4FAQIEAQGETAKCSQIdBgEFMxMCEAEBBQEBA?=
 =?us-ascii?q?QIBAwMEARMBAQsUCIVfCCUMQxYBgV0MDAMDgyUBGAEIBAY6KyMDFAEGAwIRARc?=
 =?us-ascii?q?BFAoXARIUBoMNgnwFCpc1mjYZNXZ/M4Q7AQMDhGqBQg0CE4EWAYVHS4MBgnOBH?=
 =?us-ascii?q?g+BTT+BEYISSQdsgkUMCwEBAQEBgRkOARECAQghLYJhgmAEj00pBCQCAZMYknU?=
 =?us-ascii?q?qB4JmgQoEC4ZNgQCGKySELIZtgweBJoQbhCeTViGQAIIrh2kHdgiBXYYBileEU?=
 =?us-ascii?q?IFBKoEKPwEbAgwHMxowQ4I1ATMJYA1YgmaKagMXg06BPoEmgXU7hUEDPzMCAQE?=
 =?us-ascii?q?HLAIGAQkBAQMJdQEBBRMLAYsihCQBAQ?=
X-IronPort-AV: E=Sophos;i="5.76,359,1592863200"; 
   d="scan'208,217";a="466611667"
X-MGA-submission: =?us-ascii?q?MDH7XDFDOxRx/OmgHE8bqDTpDmfwWw38crCuHG?=
 =?us-ascii?q?jSq2LcRWu4kkFZw1mniIrdRh7BlLGOt0KpPORwyM+ui3+ontOEa6jc4B?=
 =?us-ascii?q?unC8zumDp8EoL6bGZoBiiNhixKubfAOkAjWTZU/W8LfZ1A1qkkGATKgq?=
 =?us-ascii?q?ZgqI0VEaGZwiV0mwDbYkpjlw=3D=3D?=
Received: from mx1.polytechnique.org ([129.104.30.34])
  by mail2-smtp-roc.national.inria.fr with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 08 Sep 2020 15:11:19 +0200
Received: from set (set.irisa.fr [131.254.10.170])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by ssl.polytechnique.org (Postfix) with ESMTPSA id 18B2C5605E0;
	Tue,  8 Sep 2020 15:11:18 +0200 (CEST)
From: Alan Schmitt <alan.schmitt@polytechnique.org>
To: "lwn" <lwn@lwn.net>, "cwn"  <cwn@lists.idyll.org>, caml-list@inria.fr,
 comp@lists.orbitalfox.eu
Date: Tue, 08 Sep 2020 15:11:17 +0200
Message-ID: <877dt4xvka.fsf@m4x.org>
MIME-Version: 1.0
Content-Type: multipart/alternative; boundary="=-=-="
X-AV-Checked: ClamAV using ClamSMTP at svoboda.polytechnique.org (Tue Sep  8 15:11:18 2020 +0200 (CEST))
X-Spam-Flag: No, tests=bogofilter, spamicity=0.000367, queueID=6965F5611D7
X-Org-Mail: alan.schmitt.1995@polytechnique.org
Subject: [Caml-list] Attn: Development Editor, Latest OCaml Weekly News

--=-=-=
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: quoted-printable

Hello

Here is the latest OCaml Weekly News, for the week of September 01 to
08, 2020.

Table of Contents
=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=
=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=
=80

OCaml 4.11.1: early bugfix release
textmate-language 0.1.0
Batteries v3.1.0
Job offer in Paris - Be Sport
Some SIMD in your OCaml
A PPX Rewriter approach to ocaml-migrate-parsetree
telltime - when is when exactly?
Ocamlunit emacs minor-mode
Sihl 0.1.0
promise_jsoo 0.1.0
Other OCaml News
Old CWN


OCaml 4.11.1: early bugfix release
=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=
=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=
=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=
=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=
=95=90

  Archive:
  <https://discuss.ocaml.org/t/ocaml-4-11-1-early-bugfix-release/6337/1>


octachron announced
=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=
=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=
=80=E2=94=80=E2=94=80

  A serious bug has been discovered last week in OCaml 4.11.0: explicit
  polymorphic annotations are checked too permissively.  Some incorrect
  programs (possibly segfaulting) are accepted by the compiler in
  4.11.0.

  Programs accepted by OCaml 4.10 are unchanged.

  We are thus releasing OCaml 4.11.1 as an early bugfix version.  You
  are advised to upgrade to this new version if you were using OCaml
  4.11.0.

  It is (or soon will be) available as a set of OPAM switches with
  =E2=94=8C=E2=94=80=E2=94=80=E2=94=80=E2=94=80
  =E2=94=82 opam switch create 4.11.1
  =E2=94=94=E2=94=80=E2=94=80=E2=94=80=E2=94=80

  and as a source download here:
    <https://caml.inria.fr/pub/distrib/ocaml-4.11/>

  This bug was introduced when making polymorphic recursion easier to
  use. We are working on making the typechecker more robust and more
  exhaustively tested to avoid such issues in the future.


Bug fixes:
=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=
=95=8C=E2=95=8C

  =E2=80=A2 [#9856], [#9857]: Prevent polymorphic type annotations from
    generalizing weak polymorphic variables. (Leo White, report by
    Thierry Martinez, review by Jacques Garrigue)

  =E2=80=A2 [#9859], [#9862]: Remove an erroneous assertion when inferred
    function types appear in the right hand side of an explicit :>
    coercion (Florian Angeletti, report by Jerry James, review by Thomas
    Refis)


[#9856] <https://github.com/ocaml/ocaml/issues/9856>

[#9857] <https://github.com/ocaml/ocaml/issues/9857>

[#9859] <https://github.com/ocaml/ocaml/issues/9859>

[#9862] <https://github.com/ocaml/ocaml/issues/9862>


Rwmjones then said
=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=
=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=
=80=E2=94=80

  We've now got 4.11.1 in Fedora 33 & Fedora 34.  No apparent problems
  so far.


textmate-language 0.1.0
=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=
=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=
=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90

  Archive:
  <https://discuss.ocaml.org/t/ann-textmate-language-0-1-0/6339/1>


dosaylazy announced
=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=
=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=
=80=E2=94=80=E2=94=80

  I am pleased to announce [textmate-language 0.1.0]. Textmate-language
  is a library for tokenizing code using TextMate grammars. Therefore,
  it may be useful for implementing syntax highlighters. Please report
  any bugs or API inconveniences you find.


[textmate-language 0.1.0]
<https://opam.ocaml.org/packages/textmate-language/textmate-language.0.1.0/>


Batteries v3.1.0
=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=
=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90

  Archive: <https://discuss.ocaml.org/t/batteries-v3-1-0/6347/1>


UnixJunkie announced
=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=
=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=
=80=E2=94=80=E2=94=80=E2=94=80

  OCaml Batteries Included is a community-maintained extended standard
  library for OCaml.

  The latest API can be found here:
  <https://ocaml-batteries-team.github.io/batteries-included/hdoc2/>

  This minor release adds support for OCaml 4.11.  It has been available
  in opam for some days.

  Special thanks to all the contributors!

  The changelog follows:

  =E2=80=A2 Compatibility fixes for OCaml-4.11 [#962] (Jerome Vouillon)
  =E2=80=A2 BatEnum: added combination [#518] (Chimrod, review by hcarty)
  =E2=80=A2 fix benchmarks [#956] (Cedric Cellier)
  =E2=80=A2 BatFile: added count_lines [#953] (Francois Berenger, review by
    Cedric Cellier)
  =E2=80=A2 BatArray: use unsafe_get and unsafe_set more often [#947] (Fran=
cois
    Berenger, review by Cedric Cellier)
  =E2=80=A2 fix some tests for ocaml-4.10.0 [#944] (kit-ty-kate)
  =E2=80=A2 BatResult: BatPervasives.result is now equal to Stdlib.result
    instead of sharing constructors without being the same type [#939],
    [#957] (Cl=C3=A9ment Busschaert, Cedric Cellier).


[#962]
<https://github.com/ocaml-batteries-team/batteries-included/pull/962>

[#518]
<https://github.com/ocaml-batteries-team/batteries-included/pull/518>

[#956]
<https://github.com/ocaml-batteries-team/batteries-included/pull/956>

[#953]
<https://github.com/ocaml-batteries-team/batteries-included/pull/953>

[#947]
<https://github.com/ocaml-batteries-team/batteries-included/pull/947>

[#944]
<https://github.com/ocaml-batteries-team/batteries-included/pull/944>

[#939]
<https://github.com/ocaml-batteries-team/batteries-included/pull/939>

[#957]
<https://github.com/ocaml-batteries-team/batteries-included/pull/957>


Job offer in Paris - Be Sport
=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=
=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=
=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=
=E2=95=90=E2=95=90=E2=95=90=E2=95=90

  Archive:
  <https://discuss.ocaml.org/t/job-offer-in-paris-be-sport/6355/1>


Vincent Balat announced
=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=
=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=
=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80

  Be Sport is looking to hire an OCaml developer with skills in

  =E2=80=A2 Mobile/web feature design
  =E2=80=A2 Team management
  =E2=80=A2 Use of Social networks

  She/he will take part in the development of our Web and mobile apps,
  entirely written in OCaml with Ocsigen, and participate in reflections
  on features.

  Please contact me for more information or send an email to
  jobs@besport.com.


Some SIMD in your OCaml
=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=
=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=
=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90

  Archive: <https://discuss.ocaml.org/t/some-simd-in-your-ocaml/6367/1>


Anmol Sahoo announced
=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=
=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=
=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80

  Fresh from a weekend of hacking, I would like to share some results of
  an experiment I conducted of creating a library for exposing Intel
  AVX2 intrinsics to OCaml code. AVX2 is an instruction set subset that
  adds data-parallel operations in hardware.

  I chose to fork the amazing [bigstringaf] library and modified it. You
  can find the additions to the code here - [bigstringaf_simd].


[bigstringaf] <https://github.com/inhabitedtype/bigstringaf>

[bigstringaf_simd]
<https://github.com/anmolsahoo25/bigstringaf/blob/8df94c4fb5607317ee9634611=
784eea65368a270/lib/bigstringaf_simd.mli#L287>

Overview
=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C

  Given a type `Bigstring.t' (1 dimensional byte arrays) there now exist
  functions such as -
  =E2=94=8C=E2=94=80=E2=94=80=E2=94=80=E2=94=80
  =E2=94=82 val cmpeq_i8 : (t * int) -> (t * int) -> (t * int) -> unit
  =E2=94=94=E2=94=80=E2=94=80=E2=94=80=E2=94=80
  So `cmpeq_i8 (x,o1) (y,o2) (z,03)' will compare 32 bytes starting at
  `o1' and `o2' from `x' and `y' respectively and store the result in
  `z' at `o3'.


Why?
=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C

  This was mainly an exercise in curiosity. I just wanted to learn
  whether something like this is viable.  I also want to see if adding
  some type-directed magic + ppx spells can let us write data parallel
  code much more naturally similar to what `lwt / async' did for async
  code.

  At the same time, you might ask - why not use something like Owl
  (which already has good support for data-parallel operations)? Apart
  from the fact that such libraries are oriented towards numerical code,
  I would also like to explore if we can operate directly on OCaml types
  and cast them into data parallel algorithms. Like how `simdjson'
  pushed the boundaries of JSON parsing, it would be nice to port
  idiomatic code to data-parallel versions in OCaml. Can we, at some
  point, have generic traversals of data-types, which are actually
  carried out in a data-parallel fashion?


Does it work?
=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=
=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C

  Given the limitation of the current implementation (due to foreign
  function calls into C), I still found some preliminary results to be
  interesting! Implementing the `String.index' function, which returns
  the first occurence of a char, the runtime for finding an element at
  the `n-1' position in an array with `320000000' elements is -
  =E2=94=8C=E2=94=80=E2=94=80=E2=94=80=E2=94=80
  =E2=94=82 serial: 1.12 seconds
  =E2=94=82 simd: 0.72 seconds (1.5x)
  =E2=94=94=E2=94=80=E2=94=80=E2=94=80=E2=94=80
  I still have to do the analysis what the overhead of the function call
  into C is (even with `[@@noalloc]'!


Future directions
=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=
=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=
=8C

  It would be interesting to see, if we can create a representation
  which encapsulates the various SIMD ISA's such as AVX2, AVX512, NEON,
  SVE etc. Further more, it would be really interesting to see if we can
  use ppx to automatically widen `map` functions to operate on blocks of
  code, or automatically cast data types in a data parallel
  representation.


Disclaimer
=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=
=95=8C=E2=95=8C

  This was mostly a hobby project, so I cannot promise completing any
  milestones or taking feature requests etc. I definitely do not
  recommend using this in production, because of the lack of testing
  etc.


A PPX Rewriter approach to ocaml-migrate-parsetree
=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=
=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=
=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=
=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=
=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=
=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90

  Archive:
  <https://discuss.ocaml.org/t/a-ppx-rewriter-approach-to-ocaml-migrate-par=
setree/6369/1>


Chet Murthy announced
=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=
=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=
=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80

TL;DR
=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C

  Based on `camlp5' and the `pa_ppx' PPX rewriters, I've written a new
  one, `pa_deriving_plugins.rewrite', that automates almost all the work
  of writing a migration from one version of OCaml's AST to another.
  1. It took a few days (b/c of laziness) to write the initial PPX
     rewriter
  2. A day to get 4.02->4.03 AST migration working
  3. a couple of hours to get 4.03->4.02 working
  4. and a few more hours to get 4.03<->4.04 and 4.04<->4.05 working

  At this point, I fully expect that the other version-pairs will not be
  difficult.

  You can find this code [warning: very much a work-in-progress] at
  <https://github.com/chetmurthy/pa_ppx/tree/migrate-parsetree-hacking>

  The file `pa_deriving.plugins/pa_deriving_rewrite.ml' contains the
  source for the PPX rewriter.

  The directory `pa_omp' contains the migrations, typically named
  `rewrite_NNN_MMM.ml'.


A slightly longer-winded explanation
=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=
=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=
=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=
=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=
=95=8C=E2=95=8C=E2=95=8C

  If you think about it, `ppx_deriving.map' isn't so different from what
  we need for `ocaml-migrate-parsetree'.  `ppx_deriving.map', from a
  type definition for ~ 'a t~, will automatically generate a function
  =E2=94=8C=E2=94=80=E2=94=80=E2=94=80=E2=94=80
  =E2=94=82 map_t : ('a -> 'b) -> 'a t -> 'b t
  =E2=94=94=E2=94=80=E2=94=80=E2=94=80=E2=94=80
  If you think about it, if we could just substitute our own type for
  the second occurrence of `t' (somehow =E2=80=A6. yeah *grin*) then it wou=
ld be
  almost like what we want for o-m-p, yes?

  With 11 versions of the Ocaml AST so far, maybe it's worth thinking
  about how to automate more of the migration task.  Also, since so much
  of it is type-structure-driven, one would think that it would be an
  excellent opportunity to apply PPX rewriting technology.  *Indeed, one
  might think that a good test of PPX rewriting, is the ability to
  automate precisely such tasks.*

  So what's hard about this migration task?  Here are some issues (maybe
  there are more):
  1. the types are slightly differently-organized in different versions
     of the AST.  Types might move from one module to another.
  2. sometimes new types are introduced and old ones disappear
  3. constructor data-types may get new branches, or lose them
  4. record-types may get new fields, or lose them
  5. sometimes the analogous types in two consecutive versions are just
     really, really different [but this is rare]: we need to supply the
     code directly
  6. when mapping from one version to another, sometimes features are
     simply not mappable, and an error needs to be raised; that error
     ought to contain an indication of where in the source that
     offending feature was found
  7. And finally, when all else fails, we might need to hack on the
     migration code directly

  But morally, the task is really straightforward (with problems listed
  in-line):

  1. use `ppx_import' to copy over types from each of the AST times of
     each Ocaml version
     =E2=80=A2 `ppx_import' works on `.cmi' files, and those have different
       formats in different versions of Ocaml.  Wouldn't it be nice if
       it worked on `.mli' files, whose syntax (b/c OCaml is
       well-managed) doesn't change much?
  2. build a single OCaml module that has all the AST types in it (from
     all the versions of OCaml)
     =E2=80=A2 but without the form
       =E2=94=8C=E2=94=80=E2=94=80=E2=94=80=E2=94=80
       =E2=94=82 type t =3D M.t =3D A of .. | B of ....
       =E2=94=94=E2=94=80=E2=94=80=E2=94=80=E2=94=80
       that is, without the "type equation" that allows for a new
       type-definition to precisely repeat a previous one.
  3. Then use `ppx_import' against this single module to construct a
     recursive type-declaration list of all the AST types for a
     particular version of OCaml, and apply a "souped-up" version of
     ppx_deriving.map to it, to map the types to *another* version of
     the AST types.
     =E2=80=A2 but `ppx_deriving.map' doesn't do this today, and besides, it
       would have to provide a bunch of "escape hatches" for all the
       special-cases I mentioned above.

  But this is in principle doable, and it has the nice feature that all
  the tedious boilerplate is mechanically-generated from
  type-definitions, hence likely to not contain errors (assuming the PPX
  rewriter isn't buggy).

  So I decided to do it, and this little post is a result.


Discussion
=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=
=95=8C=E2=95=8C

  I think this is a quite viable approach to writing
  `ocaml-migrate-parsetree', and I would encourage the PPX community to
  consider it.  One of the nice things about this approach, is that it
  relies *heavily* on PPX rewriting itself, to get the job done.  I
  think one of the important things we've learned in programming
  languages research, is that our tools need to be largely sufficient to
  allow us to comfortably implement those same tools.  It's a good test
  of the PPX infrastructure, to see if you can take tedious tasks and
  automate them away.

  I'm not going to describe anymore of how this works, b/c I'd rather
  get the rest of the migrations working, start figuring out how to
  test, and get this code integrated with camlp5.

  But for anybody who's interested, I'd be happy to interactively
  describe the code and walk them thru how it works.


Louis Roch=C3=A9 then asked
=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=
=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=
=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80

  For a person who hasn't digged into OMP, can you explain how it is
  different from what is done currently? Because the idea I had of OMP
  is basically what you describe, a set of functions transformation an
  AST from vX to vX-1 and vX+1. So I am obviously missing something.


Chet Murthy replied
=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=
=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=
=80=E2=94=80=E2=94=80

  Yes, you're right: imagine a series of modules M2=E2=80=A6M11.  Each decl=
ares
  the same set of types, but with different definitions, yes?  Then
  you'd have migration modules, `migrate_i_j' (j=3Di+1 or j=3Di-1) that have
  functions that convert between the analogously-named types.  The
  entire question is: how are these functions implemented?  By hand?
  With significant mechanized support?  They can't be implemented
  fully-mechanically, because there are decisions to be made about how
  to bridge differences in type-definitions.  For instance, look at the
  4.02 type `label' and the 4.03 type `arg_label'.  Sometimes these are
  analogous (and sometimes they're not).  When they're analogous, the
  code that converts between -cannot- be automatically inferred: a human
  has to write it.  But -most- of the code of these migration functions
  can be inferred automatically from the type-definitions themselves.

  And that's really all that my little experiment does: automatically
  infer the migration code (most of the time) with some hints for those
  cases where it's not possible to automatically infer.

  Now, why would one do this?  Well, two reasons:

  1. it should be more maintainable to automatically generate most of
     the code from types, and it should be quicker to bring online a
     migration for a new version of the Ocaml AST.
  2. this should be a good test of PPX rewriting.  That is, if we're
     going to build a macro-preprocessing support system, shouldn't it
     be able to make solving such straightforward, but very tedious,
     problems much, much easier?


Chet Murthy then added
=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=
=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=
=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80

  I forgot to add a third reason why this PPX-rewriter-based approach is
  better:

  1. If you look at ocaml-migrate-parsetree "migrations", you'll find
     that they're almost all boilerplate code.  But sprinkled
     here-and-there, is actual logic, actual decisions about how to come
     up with values for new fields, about which fields, when non-trivial
     (e.g. not "[]") should lead to migration-failure, etc.  It is this
     code, that is the actual meat of the migration, and it's not at all
     obvious, when sprinkled thru the mass of mechanically-produclble
     boilerplate.

  A mechanized production of that boilerplate would mean that we
  retained explicitly only this nontrivial code, and hence for
  maintenance we could focus on it, and make sure it does the right
  thing.


Josh Berdine asked
=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=
=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=
=80=E2=94=80

  Figuring out ways to make maintaining this stuff more efficient would
  be great! One aspect that isn't clear to me is how this approach
  compares to the process currently used to generate the omp code. I
  haven't done it myself, but at first glance the tools to generate the
  omp code (e.g. gencopy) seem to also accurately be describable as
  heavily using ppx infrastructure in order to implement the map code
  from one version to another. Is there an executive summary that
  compares and contrasts that and this proposal?


Chet Murthy replied
=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=
=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=
=80=E2=94=80=E2=94=80

  From the README, gencopy is used to generate a prototype file for each
  migration, and then a human goes in and fixes up the code.  A way to
  put my point is: gencopy should be provided the fixups in some compact
  form, and apply them itself.


telltime - when is when exactly?
=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=
=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=
=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=
=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90

  Archive:
  <https://discuss.ocaml.org/t/ann-telltime-when-is-when-exactly/6372/1>


Darren announced
=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=
=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80

  I'm happy to announce release of [telltime] 0.0.1, a small cli tool
  for interacting with Daypack-lib (a schedule, time, time slots
  handling library) components.

  It primarily answers time related queries, with support for union
  (`||'), intersect (`&&') and "ordered select" (`>>', explanation of
  this is at the bottom).

  The query language, time expression, aims to mimic natural language,
  but without ambiguity. The grammar is only documented in the online
  demo [here] at the moment.

  Some examples copied from the README are as follows.


[telltime] <https://github.com/daypack-dev/telltime>

[here] <https://daypack-dev.github.io/time-expr-demo/>

Search for time slots matching Daypack time expression
=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=
=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=
=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=
=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=
=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=
=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=
=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C

  "Hm, I wonder what years have Febuary 29th?"

  =E2=94=8C=E2=94=80=E2=94=80=E2=94=80=E2=94=80
  =E2=94=82 $ telltime search --time-slots 5 --years 100 "feb 29 00:00"
  =E2=94=82 Searching in time zone offset (seconds)            : 36000
  =E2=94=82 Search by default starts from (in above time zone) : 2020 Sep 0=
3 19:24:15
  =E2=94=82=20
  =E2=94=82 Matching time slots (in above time zone):
  =E2=94=82 [2024 Feb 29 00:00:00, 2024 Feb 29 00:00:01)
  =E2=94=82 [2028 Feb 29 00:00:00, 2028 Feb 29 00:00:01)
  =E2=94=82 [2032 Feb 29 00:00:00, 2032 Feb 29 00:00:01)
  =E2=94=82 [2036 Feb 29 00:00:00, 2036 Feb 29 00:00:01)
  =E2=94=82 [2040 Feb 29 00:00:00, 2040 Feb 29 00:00:01)
  =E2=94=94=E2=94=80=E2=94=80=E2=94=80=E2=94=80

  "Would be handy to know what this cron expression refers to"
  =E2=94=8C=E2=94=80=E2=94=80=E2=94=80=E2=94=80
  =E2=94=82 $ telltime search --time-slots 5 "0 4 8-14 * *"
  =E2=94=82 Searching in time zone offset (seconds)            : 36000
  =E2=94=82 Search by default starts from (in above time zone) : 2020 Sep 0=
6 17:39:56
  =E2=94=82=20
  =E2=94=82 Matching time slots (in above time zone):
  =E2=94=82 [2020 Sep 08 04:00:00, 2020 Sep 08 04:01:00)
  =E2=94=82 [2020 Sep 09 04:00:00, 2020 Sep 09 04:01:00)
  =E2=94=82 [2020 Sep 10 04:00:00, 2020 Sep 10 04:01:00)
  =E2=94=82 [2020 Sep 11 04:00:00, 2020 Sep 11 04:01:00)
  =E2=94=82 [2020 Sep 12 04:00:00, 2020 Sep 12 04:01:00)
  =E2=94=94=E2=94=80=E2=94=80=E2=94=80=E2=94=80

  "I have a bunch of time ranges, but some of them overlap, and they are
  not in the right order. If only there is a way to combine and sort
  them easily."

  =E2=94=8C=E2=94=80=E2=94=80=E2=94=80=E2=94=80
  =E2=94=82 $ telltime search --time-slots 1000 "2020 . jan . 1, 10, 20 . 1=
3:00 to 14:00 \
  =E2=94=82   || 2019 dec 25 13:00 \
  =E2=94=82   || 2019 dec 25 10am to 17:00 \
  =E2=94=82   || 2020 jan 5 10am to 1:30pm \
  =E2=94=82   || 2020 . jan . 7 to 12 . 9:15am to 2:45pm"
  =E2=94=82 Searching in time zone offset (seconds)            : 36000
  =E2=94=82 Search by default starts from (in above time zone) : 2020 Sep 0=
6 18:01:12
  =E2=94=82=20
  =E2=94=82 Matching time slots (in above time zone):
  =E2=94=82 [2019 Dec 25 10:00:00, 2019 Dec 25 17:00:00)
  =E2=94=82 [2020 Jan 01 13:00:00, 2020 Jan 01 14:00:00)
  =E2=94=82 [2020 Jan 05 10:00:00, 2020 Jan 05 13:30:00)
  =E2=94=82 [2020 Jan 07 09:15:00, 2020 Jan 07 14:45:00)
  =E2=94=82 [2020 Jan 08 09:15:00, 2020 Jan 08 14:45:00)
  =E2=94=82 [2020 Jan 09 09:15:00, 2020 Jan 09 14:45:00)
  =E2=94=82 [2020 Jan 10 09:15:00, 2020 Jan 10 14:45:00)
  =E2=94=82 [2020 Jan 11 09:15:00, 2020 Jan 11 14:45:00)
  =E2=94=82 [2020 Jan 12 09:15:00, 2020 Jan 12 14:45:00)
  =E2=94=82 [2020 Jan 20 13:00:00, 2020 Jan 20 14:00:00)
  =E2=94=94=E2=94=80=E2=94=80=E2=94=80=E2=94=80


Get exact time after some duration from now
=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=
=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=
=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=
=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=
=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=
=8C=E2=95=8C

  =E2=94=8C=E2=94=80=E2=94=80=E2=94=80=E2=94=80
  =E2=94=82 $ telltime from-now "1 hour"
  =E2=94=82 Now                   : 2020-09-03 15:53:29
  =E2=94=82 Duration (original)   : 1 hour
  =E2=94=82 Duration (normalized) : 1 hours 0 mins 0 secs
  =E2=94=82 Now + duration        : 2020-09-03 16:53:29
  =E2=94=94=E2=94=80=E2=94=80=E2=94=80=E2=94=80

  =E2=94=8C=E2=94=80=E2=94=80=E2=94=80=E2=94=80
  =E2=94=82 $ telltime from-now "1.5 days 2.7 hours 0.5 minutes"
  =E2=94=82 Now                   : 2020-09-03 15:55:43
  =E2=94=82 Duration (original)   : 1.5 days 2.7 hours 0.5 minutes
  =E2=94=82 Duration (normalized) : 1 days 14 hours 42 mins 30 secs
  =E2=94=82 Now + duration        : 2020-09-05 06:38:13
  =E2=94=94=E2=94=80=E2=94=80=E2=94=80=E2=94=80


Difference between ordered select and union
=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=
=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=
=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=
=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=
=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=8C=E2=95=
=8C=E2=95=8C

  `s1 >> s2' is similar to `s1 || s2', but `>>' picks between s1 and s2
  in a round robin fashion, instead of just picking the smallest between
  two.

  One specific differing case would be when the search starts at 4pm
  today, `3pm || 5pm' would return 5pm today and 3pm tomorrow, and so
  on, while `3pm >> 5pm' would return 3pm tomorrow and 5pm tomorrow (a
  5pm is only picked after a 3pm has been picked already).


Ocamlunit emacs minor-mode
=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=
=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=
=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=
=E2=95=90

  Archive:
  <https://discuss.ocaml.org/t/ocamlunit-emacs-minor-mode/6373/1>


Manfred Bergmann announced
=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=
=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=
=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=
=E2=94=80

  Here is a first version of this plugin that allows running `dune test'
  with an Emacs key stroke.  It shows the test result in a separate
  buffer and a simple colorized status 'message'.

  <https://github.com/mdbergmann/emacs-ocamlunit>

  While it is possible to run `dune' in 'watch' mode I'd like to
  manually run tests.

  I didn't find a way to specify individual test modules in `dune'. Is
  that possible?


Sihl 0.1.0
=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=
=95=90=E2=95=90

  Archive: <https://discuss.ocaml.org/t/ann-sihl-0-1-0/6374/1>


jerben announced
=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=
=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80

  I am happy to announce this milestone release of Sihl, a web framework
  for OCaml.

  Github: <https://github.com/oxidizing/sihl>
  opam: <http://opam.ocaml.org/packages/sihl/>

  Sihl is really just a collection of services that can be plugged into
  each other and a tiny core that knows how to start them. The goal is
  to take care of infrastructure concerns so you can focus on the
  domain.

  After many iterations, the API is in a shape where we dare to show it
  to you :slight_smile: It is still under heavy development so expect
  breakage without a major version bump. However, we just finished
  migrating a project from Reason on NodeJS to OCaml on Sihl, so we use
  it in production.

  We provide service implementations that were useful to us so far. In
  the future we want to provide many more to cover all kinds of
  needs. (PRs are always welcome!)

  Any feedback is greatly appreciated, thanks! :)


jerben then added
=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=
=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=
=80

  Here is an example of a tiny Sihl app:

  =E2=94=8C=E2=94=80=E2=94=80=E2=94=80=E2=94=80
  =E2=94=82 module Service =3D struct
  =E2=94=82   module Random =3D Sihl.Utils.Random.Service
  =E2=94=82   module Log =3D Sihl.Log.Service
  =E2=94=82   module Config =3D Sihl.Config.Service
  =E2=94=82   module Db =3D Sihl.Data.Db.Service
  =E2=94=82   module MigrationRepo =3D Sihl.Data.Migration.Service.Repo.Mar=
iaDb
  =E2=94=82   module Cmd =3D Sihl.Cmd.Service
  =E2=94=82   module Migration =3D Sihl.Data.Migration.Service.Make (Cmd) (=
Db) (MigrationRepo)
  =E2=94=82   module WebServer =3D Sihl.Web.Server.Service.Make (Cmd)
  =E2=94=82   module Schedule =3D Sihl.Schedule.Service.Make (Log)
  =E2=94=82 end
  =E2=94=82=20
  =E2=94=82 let services : (module Sihl.Core.Container.SERVICE) list =3D
  =E2=94=82   [ (module Service.WebServer) ]
  =E2=94=82=20
  =E2=94=82 let hello_page =3D
  =E2=94=82   Sihl.Web.Route.get "/hello/" (fun _ ->
  =E2=94=82       Sihl.Web.Res.(html |> set_body "Hello!") |> Lwt.return)
  =E2=94=82=20
  =E2=94=82 let routes =3D [ ("/page", [ hello_page ], []) ]
  =E2=94=82=20
  =E2=94=82 module App =3D Sihl.App.Make (Service)
  =E2=94=82=20
  =E2=94=82 let _ =3D App.(empty |> with_services services |> with_routes r=
outes |> run)
  =E2=94=94=E2=94=80=E2=94=80=E2=94=80=E2=94=80


promise_jsoo 0.1.0
=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=
=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=
=90=E2=95=90

  Archive: <https://discuss.ocaml.org/t/ann-promise-jsoo-0-1-0/6377/1>


Max LANTAS announced
=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=
=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=
=80=E2=94=80=E2=94=80=E2=94=80

  Hello! I am announcing the first release of `promise_jsoo', a library
  for JS promises in Js_of_ocaml.

  <https://github.com/mnxn/promise_jsoo>
  <https://opam.ocaml.org/packages/promise_jsoo/>

  The library has bindings to the core `Promise' methods as well as
  helper functions that make it easier to deal with a `Promise' of an
  `option' or `result'. It is also possible to use this library with
  [gen_js_api] to make for an easier JavaScript binding experience

  Inspired by [aantron/promise], this library also uses indirection
  internally when handling nested promises in order to ensure that the
  bindings are type safe.

  This project is part of ongoing work to port [vscode-ocaml-platform]
  to Js_of_ocaml.

  Generated documentation can be found [here].


[gen_js_api] <https://github.com/LexiFi/gen_js_api>

[aantron/promise]
<https://github.com/aantron/promise#discussion-how-reason-promise-makes-pro=
mises-type-safe>

[vscode-ocaml-platform]
<https://github.com/ocamllabs/vscode-ocaml-platform>

[here]
<https://mnxn.github.io/promise_jsoo/promise_jsoo/Promise/index.html>


Other OCaml News
=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=
=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90

>From the ocamlcore planet blog
=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=
=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=
=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=
=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80

  Here are links from many OCaml blogs aggregated at [OCaml Planet].

  =E2=80=A2 [Announcing Signals and Threads, a new podcast from Jane Street]


[OCaml Planet] <http://ocaml.org/community/planet/>

[Announcing Signals and Threads, a new podcast from Jane Street]
<https://blog.janestreet.com/announcing-signals-and-threads-index/>


Old CWN
=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90=E2=95=90

  If you happen to miss a CWN, you can [send me a message] and I'll mail
  it to you, or go take a look at [the archive] or the [RSS feed of the
  archives].

  If you also wish to receive it every week by mail, you may subscribe
  [online].

  [Alan Schmitt]


[send me a message] <mailto:alan.schmitt@polytechnique.org>

[the archive] <http://alan.petitepomme.net/cwn/>

[RSS feed of the archives] <http://alan.petitepomme.net/cwn/cwn.rss>

[online] <http://lists.idyll.org/listinfo/caml-news-weekly/>

[Alan Schmitt] <http://alan.petitepomme.net/>


--=-=-=
Content-Type: text/html; charset=utf-8
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

<?xml version=3D"1.0" encoding=3D"utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns=3D"http://www.w3.org/1999/xhtml" lang=3D"en" xml:lang=3D"en">
<head>
<!-- 2020-09-08 Tue 15:09 -->
<meta http-equiv=3D"Content-Type" content=3D"text/html;charset=3Dutf-8" />
<meta name=3D"viewport" content=3D"width=3Ddevice-width, initial-scale=3D1"=
 />
<title>OCaml Weekly News</title>
<meta name=3D"generator" content=3D"Org mode" />
<style type=3D"text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<style type=3D"text/css">#table-of-contents h2 { display: none } .title { d=
isplay: none } .authorname { text-align: right }</style>
<style type=3D"text/css">.outline-2 {border-top: 1px solid black;}</style>
<script type=3D"text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target =3D document.getElementById(id);
   if(null !=3D target) {
     elem.cacheClassElem =3D elem.className;
     elem.cacheClassTarget =3D target.className;
     target.className =3D "code-highlighted";
     elem.className   =3D "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target =3D document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className =3D elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className =3D elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id=3D"content">
<h1 class=3D"title">OCaml Weekly News</h1>
<p>
<a href=3D"http://alan.petitepomme.net/cwn/2020.09.01.html">Previous Week</=
a> <a href=3D"http://alan.petitepomme.net/cwn/index.html">Up</a> <a href=3D=
"http://alan.petitepomme.net/cwn/2020.09.15.html">Next Week</a>
</p>

<p>
Hello
</p>

<p>
Here is the latest OCaml Weekly News, for the week of September 01 to 08, 2=
020.
</p>

<div id=3D"table-of-contents">
<h2>Table of Contents</h2>
<div id=3D"text-table-of-contents">
<ul>
<li><a href=3D"#1">OCaml 4.11.1: early bugfix release</a></li>
<li><a href=3D"#2">textmate-language 0.1.0</a></li>
<li><a href=3D"#3">Batteries v3.1.0</a></li>
<li><a href=3D"#4">Job offer in Paris - Be Sport</a></li>
<li><a href=3D"#5">Some SIMD in your OCaml</a></li>
<li><a href=3D"#6">A PPX Rewriter approach to ocaml-migrate-parsetree</a></=
li>
<li><a href=3D"#7">telltime - when is when exactly?</a></li>
<li><a href=3D"#8">Ocamlunit emacs minor-mode</a></li>
<li><a href=3D"#9">Sihl 0.1.0</a></li>
<li><a href=3D"#10">promise_jsoo 0.1.0</a></li>
<li><a href=3D"#11">Other OCaml News</a></li>
<li><a href=3D"#orgf7c3f69">Old CWN</a></li>
</ul>
</div>
</div>


<div id=3D"outline-container-orga1b78b7" class=3D"outline-2">
<h2 id=3D"1">OCaml 4.11.1: early bugfix release</h2>
<div class=3D"outline-text-2" id=3D"text-1">
<p>
Archive: <a href=3D"https://discuss.ocaml.org/t/ocaml-4-11-1-early-bugfix-r=
elease/6337/1">https://discuss.ocaml.org/t/ocaml-4-11-1-early-bugfix-releas=
e/6337/1</a>
</p>
</div>

<div id=3D"outline-container-org94dba18" class=3D"outline-3">
<h3 id=3D"org94dba18">octachron announced</h3>
<div class=3D"outline-text-3" id=3D"text-org94dba18">
<p>
A serious bug has been discovered last week in OCaml 4.11.0:
explicit polymorphic annotations are checked too permissively.
Some incorrect programs (possibly segfaulting) are accepted
by the compiler in 4.11.0.
</p>

<p>
Programs accepted by OCaml 4.10 are unchanged.
</p>

<p>
We are thus releasing OCaml 4.11.1 as an early bugfix version.
You are advised to upgrade to this new version if you were
using OCaml 4.11.0.
</p>

<p>
It is (or soon will be) available as a set of OPAM switches with
</p>
<pre class=3D"example">
opam switch create 4.11.1
</pre>

<p>
and as a source download here:
  <a href=3D"https://caml.inria.fr/pub/distrib/ocaml-4.11/">https://caml.in=
ria.fr/pub/distrib/ocaml-4.11/</a>
</p>

<p>
This bug was introduced when making polymorphic recursion
easier to use. We are working on making the typechecker
more robust and more exhaustively tested to avoid such
issues in the future.
</p>
</div>

<div id=3D"outline-container-org537446e" class=3D"outline-4">
<h4 id=3D"org537446e">Bug fixes:</h4>
<div class=3D"outline-text-4" id=3D"text-org537446e">
<ul class=3D"org-ul">
<li><a href=3D"https://github.com/ocaml/ocaml/issues/9856">#9856</a>, <a hr=
ef=3D"https://github.com/ocaml/ocaml/issues/9857">#9857</a>: Prevent polymo=
rphic type annotations from generalizing weak polymorphic variables. (Leo W=
hite, report by Thierry Martinez, review by Jacques Garrigue)</li>

<li><a href=3D"https://github.com/ocaml/ocaml/issues/9859">#9859</a>, <a hr=
ef=3D"https://github.com/ocaml/ocaml/issues/9862">#9862</a>: Remove an erro=
neous assertion when inferred function types appear in the right hand side =
of an explicit :&gt; coercion (Florian Angeletti, report by Jerry James, re=
view by Thomas Refis)</li>
</ul>
</div>
</div>
</div>


<div id=3D"outline-container-org7a659bd" class=3D"outline-3">
<h3 id=3D"org7a659bd">Rwmjones then said</h3>
<div class=3D"outline-text-3" id=3D"text-org7a659bd">
<p>
We've now got 4.11.1 in Fedora 33 &amp; Fedora 34.  No apparent problems so=
 far.
</p>
</div>
</div>
</div>




<div id=3D"outline-container-org858a317" class=3D"outline-2">
<h2 id=3D"2">textmate-language 0.1.0</h2>
<div class=3D"outline-text-2" id=3D"text-2">
<p>
Archive: <a href=3D"https://discuss.ocaml.org/t/ann-textmate-language-0-1-0=
/6339/1">https://discuss.ocaml.org/t/ann-textmate-language-0-1-0/6339/1</a>
</p>
</div>

<div id=3D"outline-container-org6ac199b" class=3D"outline-3">
<h3 id=3D"org6ac199b">dosaylazy announced</h3>
<div class=3D"outline-text-3" id=3D"text-org6ac199b">
<p>
I am pleased to announce <a href=3D"https://opam.ocaml.org/packages/textmat=
e-language/textmate-language.0.1.0/">textmate-language
0.1.0</a>. Textmate-language
is a library for tokenizing code using TextMate grammars. Therefore, it may=
 be useful for implementing
syntax highlighters. Please report any bugs or API inconveniences you find.
</p>
</div>
</div>
</div>




<div id=3D"outline-container-orgde27f68" class=3D"outline-2">
<h2 id=3D"3">Batteries v3.1.0</h2>
<div class=3D"outline-text-2" id=3D"text-3">
<p>
Archive: <a href=3D"https://discuss.ocaml.org/t/batteries-v3-1-0/6347/1">ht=
tps://discuss.ocaml.org/t/batteries-v3-1-0/6347/1</a>
</p>
</div>

<div id=3D"outline-container-org73ed5b7" class=3D"outline-3">
<h3 id=3D"org73ed5b7">UnixJunkie announced</h3>
<div class=3D"outline-text-3" id=3D"text-org73ed5b7">
<p>
OCaml Batteries Included is a community-maintained extended standard librar=
y for OCaml.
</p>

<p>
The latest API can be found here:
<a href=3D"https://ocaml-batteries-team.github.io/batteries-included/hdoc2/=
">https://ocaml-batteries-team.github.io/batteries-included/hdoc2/</a>
</p>

<p>
This minor release adds support for OCaml 4.11.
It has been available in opam for some days.
</p>

<p>
Special thanks to all the contributors!
</p>

<p>
The changelog follows:
</p>

<ul class=3D"org-ul">
<li>Compatibility fixes for OCaml-4.11 <a href=3D"https://github.com/ocaml-=
batteries-team/batteries-included/pull/962">#962</a> (Jerome Vouillon)</li>
<li>BatEnum: added combination <a href=3D"https://github.com/ocaml-batterie=
s-team/batteries-included/pull/518">#518</a> (Chimrod, review by hcarty)</l=
i>
<li>fix benchmarks <a href=3D"https://github.com/ocaml-batteries-team/batte=
ries-included/pull/956">#956</a> (Cedric Cellier)</li>
<li>BatFile: added count_lines <a href=3D"https://github.com/ocaml-batterie=
s-team/batteries-included/pull/953">#953</a> (Francois Berenger, review by =
Cedric Cellier)</li>
<li>BatArray: use unsafe_get and unsafe_set more often <a href=3D"https://g=
ithub.com/ocaml-batteries-team/batteries-included/pull/947">#947</a> (Franc=
ois Berenger, review by Cedric Cellier)</li>
<li>fix some tests for ocaml-4.10.0 <a href=3D"https://github.com/ocaml-bat=
teries-team/batteries-included/pull/944">#944</a> (kit-ty-kate)</li>
<li>BatResult: BatPervasives.result is now equal to Stdlib.result instead o=
f sharing constructors without being the same type <a href=3D"https://githu=
b.com/ocaml-batteries-team/batteries-included/pull/939">#939</a>, <a href=
=3D"https://github.com/ocaml-batteries-team/batteries-included/pull/957">#9=
57</a> (Cl=C3=A9ment Busschaert, Cedric Cellier).</li>
</ul>
</div>
</div>
</div>




<div id=3D"outline-container-orga5d58b3" class=3D"outline-2">
<h2 id=3D"4">Job offer in Paris - Be Sport</h2>
<div class=3D"outline-text-2" id=3D"text-4">
<p>
Archive: <a href=3D"https://discuss.ocaml.org/t/job-offer-in-paris-be-sport=
/6355/1">https://discuss.ocaml.org/t/job-offer-in-paris-be-sport/6355/1</a>
</p>
</div>

<div id=3D"outline-container-orge6bcf3c" class=3D"outline-3">
<h3 id=3D"orge6bcf3c">Vincent Balat announced</h3>
<div class=3D"outline-text-3" id=3D"text-orge6bcf3c">
<p>
Be Sport is looking to hire an OCaml developer with skills in
</p>

<ul class=3D"org-ul">
<li>Mobile/web feature design</li>
<li>Team management</li>
<li>Use of Social networks</li>
</ul>

<p>
She/he will take part in the development of our Web and mobile apps, entire=
ly written in OCaml with
Ocsigen, and participate in reflections on features.
</p>

<p>
Please contact me for more information or send an email to jobs@besport.com.
</p>
</div>
</div>
</div>




<div id=3D"outline-container-orge0d80e0" class=3D"outline-2">
<h2 id=3D"5">Some SIMD in your OCaml</h2>
<div class=3D"outline-text-2" id=3D"text-5">
<p>
Archive: <a href=3D"https://discuss.ocaml.org/t/some-simd-in-your-ocaml/636=
7/1">https://discuss.ocaml.org/t/some-simd-in-your-ocaml/6367/1</a>
</p>
</div>

<div id=3D"outline-container-org4328c9d" class=3D"outline-3">
<h3 id=3D"org4328c9d">Anmol Sahoo announced</h3>
<div class=3D"outline-text-3" id=3D"text-org4328c9d">
<p>
Fresh from a weekend of hacking, I would like to share some results of an e=
xperiment I conducted of
creating a library for exposing Intel AVX2 intrinsics to OCaml code. AVX2 i=
s an instruction set subset
that adds data-parallel operations in hardware.
</p>

<p>
I chose to fork the amazing <a href=3D"https://github.com/inhabitedtype/big=
stringaf">bigstringaf</a> library and
modified it. You can find the additions to the code here -
<a href=3D"https://github.com/anmolsahoo25/bigstringaf/blob/8df94c4fb560731=
7ee9634611784eea65368a270/lib/bigstringaf_simd.mli#L287">bigstringaf_simd</=
a>.
</p>
</div>

<div id=3D"outline-container-orge5abcb4" class=3D"outline-4">
<h4 id=3D"orge5abcb4">Overview</h4>
<div class=3D"outline-text-4" id=3D"text-orge5abcb4">
<p>
Given a type <code>Bigstring.t</code> (1 dimensional byte arrays) there now=
 exist functions such as -
</p>
<div class=3D"org-src-container">
<pre class=3D"src src-ocaml"><span style=3D"color: #000000; font-weight: bo=
ld;">val</span> <span style=3D"color: #0000ff;">cmpeq_i8</span> : (t * int)=
 -&gt; (t * int) -&gt; (t * int) -&gt; unit
</pre>
</div>
<p>
So <code>cmpeq_i8 (x,o1) (y,o2) (z,03)</code> will compare 32 bytes startin=
g at <code>o1</code> and <code>o2</code> from <code>x</code> and <code>y</c=
ode>
respectively and store the result in <code>z</code> at <code>o3</code>.
</p>
</div>
</div>

<div id=3D"outline-container-orgf347cda" class=3D"outline-4">
<h4 id=3D"orgf347cda">Why?</h4>
<div class=3D"outline-text-4" id=3D"text-orgf347cda">
<p>
This was mainly an exercise in curiosity. I just wanted to learn whether so=
mething like this is viable.
I also want to see if adding some type-directed magic + ppx spells can let =
us write data parallel code
much more naturally similar to what <code>lwt / async</code> did for async =
code.
</p>

<p>
At the same time, you might ask - why not use something like Owl (which alr=
eady has good support for
data-parallel operations)? Apart from the fact that such libraries are orie=
nted towards numerical code,
I would also like to explore if we can operate directly on OCaml types and =
cast them into data parallel
algorithms. Like how <code>simdjson</code> pushed the boundaries of JSON pa=
rsing, it would be nice to port
idiomatic code to data-parallel versions in OCaml. Can we, at some point, h=
ave generic traversals of
data-types, which are actually carried out in a data-parallel fashion?
</p>
</div>
</div>

<div id=3D"outline-container-orgda9ce72" class=3D"outline-4">
<h4 id=3D"orgda9ce72">Does it work?</h4>
<div class=3D"outline-text-4" id=3D"text-orgda9ce72">
<p>
Given the limitation of the current implementation (due to foreign function=
 calls into C), I still
found some preliminary results to be interesting! Implementing the <code>St=
ring.index</code> function, which
returns the first occurence of a char, the runtime for finding an element a=
t the <code>n-1</code> position in an
array with <code>320000000</code> elements is -
</p>
<pre class=3D"example">
serial: 1.12 seconds
simd: 0.72 seconds (1.5x)
</pre>
<p>
I still have to do the analysis what the overhead of the function call into=
 C is (even with
<code>[@@noalloc]</code>!
</p>
</div>
</div>

<div id=3D"outline-container-org0a22620" class=3D"outline-4">
<h4 id=3D"org0a22620">Future directions</h4>
<div class=3D"outline-text-4" id=3D"text-org0a22620">
<p>
It would be interesting to see, if we can create a representation which enc=
apsulates the various SIMD
ISA's such as AVX2, AVX512, NEON, SVE etc. Further more, it would be really=
 interesting to see if we
can use ppx to automatically widen `map` functions to operate on blocks of =
code, or automatically cast
data types in a data parallel representation.
</p>
</div>
</div>

<div id=3D"outline-container-org66ed8d4" class=3D"outline-4">
<h4 id=3D"org66ed8d4">Disclaimer</h4>
<div class=3D"outline-text-4" id=3D"text-org66ed8d4">
<p>
This was mostly a hobby project, so I cannot promise completing any milesto=
nes or taking feature
requests etc. I definitely do not recommend using this in production, becau=
se of the lack of testing
etc.
</p>
</div>
</div>
</div>
</div>




<div id=3D"outline-container-org192de4a" class=3D"outline-2">
<h2 id=3D"6">A PPX Rewriter approach to ocaml-migrate-parsetree</h2>
<div class=3D"outline-text-2" id=3D"text-6">
<p>
Archive: <a href=3D"https://discuss.ocaml.org/t/a-ppx-rewriter-approach-to-=
ocaml-migrate-parsetree/6369/1">https://discuss.ocaml.org/t/a-ppx-rewriter-=
approach-to-ocaml-migrate-parsetree/6369/1</a>
</p>
</div>

<div id=3D"outline-container-org185655f" class=3D"outline-3">
<h3 id=3D"org185655f">Chet Murthy announced</h3>
<div class=3D"outline-text-3" id=3D"text-org185655f">
</div>
<div id=3D"outline-container-orge5554af" class=3D"outline-4">
<h4 id=3D"orge5554af">TL;DR</h4>
<div class=3D"outline-text-4" id=3D"text-orge5554af">
<p>
Based on <code>camlp5</code> and the <code>pa_ppx</code> PPX rewriters, I'v=
e written a new one,
<code>pa_deriving_plugins.rewrite</code>, that automates almost all the wor=
k of writing a migration from one
version of OCaml's AST to another.
</p>
<ol class=3D"org-ol">
<li>It took a few days (b/c of laziness) to write the initial PPX rewriter<=
/li>
<li>A day to get 4.02-&gt;4.03 AST migration working</li>
<li>a couple of hours to get 4.03-&gt;4.02 working</li>
<li>and a few more hours to get 4.03&lt;-&gt;4.04 and 4.04&lt;-&gt;4.05 wor=
king</li>
</ol>

<p>
At this point, I fully expect that the other version-pairs will not be diff=
icult.
</p>

<p>
You can find this code [warning: very much a work-in-progress] at
<a href=3D"https://github.com/chetmurthy/pa_ppx/tree/migrate-parsetree-hack=
ing">https://github.com/chetmurthy/pa_ppx/tree/migrate-parsetree-hacking</a>
</p>

<p>
The file <code>pa_deriving.plugins/pa_deriving_rewrite.ml</code> contains t=
he source for the PPX rewriter.
</p>

<p>
The directory <code>pa_omp</code> contains the migrations, typically named =
<code>rewrite_NNN_MMM.ml</code>.
</p>
</div>
</div>

<div id=3D"outline-container-org5e3dd79" class=3D"outline-4">
<h4 id=3D"org5e3dd79">A slightly longer-winded explanation</h4>
<div class=3D"outline-text-4" id=3D"text-org5e3dd79">
<p>
If you think about it, <code>ppx_deriving.map</code> isn't so different fro=
m what
we need for <code>ocaml-migrate-parsetree</code>.  <code>ppx_deriving.map</=
code>, from a type definition for ~ 'a t~, will
automatically generate a function
</p>
<div class=3D"org-src-container">
<pre class=3D"src src-ocaml">map_t : ('a -&gt; 'b) -&gt; 'a t -&gt; 'b t
</pre>
</div>
<p>
If you think about it, if we could just substitute our own type for the sec=
ond occurrence of <code>t</code>
(somehow &#x2026;. yeah <b>grin</b>) then it would be almost like what we w=
ant for o-m-p, yes?
</p>

<p>
With 11 versions of the Ocaml AST so far, maybe it's worth thinking about h=
ow to automate more of the
migration task.  Also, since so much of it is type-structure-driven, one wo=
uld think that it would be
an excellent opportunity to apply PPX rewriting technology.  <b>Indeed, one=
 might think that a good test of PPX rewriting, is the ability to automate =
precisely such tasks.</b>
</p>

<p>
So what's hard about this migration task?  Here are some issues (maybe ther=
e are more):
</p>
<ol class=3D"org-ol">
<li>the types are slightly differently-organized in different versions of t=
he AST.  Types might move from one module to another.</li>
<li>sometimes new types are introduced and old ones disappear</li>
<li>constructor data-types may get new branches, or lose them</li>
<li>record-types may get new fields, or lose them</li>
<li>sometimes the analogous types in two consecutive versions are just real=
ly, really different [but this is rare]: we need to supply the code directl=
y</li>
<li>when mapping from one version to another, sometimes features are simply=
 not mappable, and an error needs to be raised; that error ought to contain=
 an indication of where in the source that offending feature was found</li>
<li>And finally, when all else fails, we might need to hack on the migratio=
n code directly</li>
</ol>

<p>
But morally, the task is really straightforward (with problems listed in-li=
ne):
</p>

<ol class=3D"org-ol">
<li>use <code>ppx_import</code> to copy over types from each of the AST tim=
es of each Ocaml version
<ul class=3D"org-ul">
<li><code>ppx_import</code> works on <code>.cmi</code> files, and those hav=
e different formats in different versions of Ocaml.  Wouldn't it be nice if=
 it worked on <code>.mli</code> files, whose syntax (b/c OCaml is well-mana=
ged) doesn't change much?</li>
</ul></li>
<li>build a single OCaml module that has all the AST types in it (from all =
the versions of OCaml)
<ul class=3D"org-ul">
<li><p>
but without the form
</p>
<div class=3D"org-src-container">
<pre class=3D"src src-ocaml"><span style=3D"color: #000000; font-weight: bo=
ld;">type</span> <span style=3D"color: #228b22;">t</span> =3D <span style=
=3D"color: #228b22;">M.</span>t =3D <span style=3D"color: #000000; backgrou=
nd-color: #ffffff;">A</span> <span style=3D"color: #a020f0;">of</span> .. |=
 <span style=3D"color: #000000; background-color: #ffffff;">B</span> <span =
style=3D"color: #a020f0;">of</span> ....
</pre>
</div>
<p>
that is, without the "type equation" that allows for a new type-definition =
to precisely repeat a previous one.
</p></li>
</ul></li>
<li>Then use <code>ppx_import</code> against this single module to construc=
t a recursive type-declaration list of all the AST types for a particular v=
ersion of OCaml, and apply a "souped-up" version of ppx_deriving.map to it,=
 to map the types to <b>another</b> version of the AST types.
<ul class=3D"org-ul">
<li>but <code>ppx_deriving.map</code> doesn't do this today, and besides, i=
t would have to provide a bunch of "escape hatches" for all the special-cas=
es I mentioned above.</li>
</ul></li>
</ol>

<p>
But this is in principle doable, and it has the nice feature that all the t=
edious boilerplate is
mechanically-generated from type-definitions, hence likely to not contain e=
rrors (assuming the PPX
rewriter isn't buggy).
</p>

<p>
So I decided to do it, and this little post is a result.
</p>
</div>
</div>

<div id=3D"outline-container-org278e9b0" class=3D"outline-4">
<h4 id=3D"org278e9b0">Discussion</h4>
<div class=3D"outline-text-4" id=3D"text-org278e9b0">
<p>
I think this is a quite viable approach to writing <code>ocaml-migrate-pars=
etree</code>, and I would encourage the
PPX community to consider it.  One of the nice things about this approach, =
is that it relies <b>heavily</b>
on PPX rewriting itself, to get the job done.  I think one of the important=
 things we've learned in
programming languages research, is that our tools need to be largely suffic=
ient to allow us to
comfortably implement those same tools.  It's a good test of the PPX infras=
tructure, to see if you can
take tedious tasks and automate them away.
</p>

<p>
I'm not going to describe anymore of how this works, b/c I'd rather
get the rest of the migrations working, start figuring out how to
test, and get this code integrated with camlp5.
</p>

<p>
But for anybody who's interested, I'd be happy to interactively
describe the code and walk them thru how it works.
</p>
</div>
</div>
</div>


<div id=3D"outline-container-orgb57522f" class=3D"outline-3">
<h3 id=3D"orgb57522f">Louis Roch=C3=A9 then asked</h3>
<div class=3D"outline-text-3" id=3D"text-orgb57522f">
<p>
For a person who hasn't digged into OMP, can you explain how it is differen=
t from what is done
currently? Because the idea I had of OMP is basically what you describe, a =
set of functions
transformation an AST from vX to vX-1 and vX+1. So I am obviously missing s=
omething.
</p>
</div>
</div>


<div id=3D"outline-container-org0d444ad" class=3D"outline-3">
<h3 id=3D"org0d444ad">Chet Murthy replied</h3>
<div class=3D"outline-text-3" id=3D"text-org0d444ad">
<p>
Yes, you're right: imagine a series of modules M2&#x2026;M11.  Each declare=
s the same set of types, but with
different definitions, yes?  Then you'd have migration modules, <code>migra=
te_i_j</code> (j=3Di+1 or j=3Di-1) that
have functions that convert between the analogously-named types.  The entir=
e question is: how are these
functions implemented?  By hand?  With significant mechanized support?  The=
y can't be implemented
fully-mechanically, because there are decisions to be made about how to bri=
dge differences in
type-definitions.  For instance, look at the 4.02 type <code>label</code> a=
nd the 4.03 type <code>arg_label</code>.
Sometimes these are analogous (and sometimes they're not).  When they're an=
alogous, the code that
converts between -cannot- be automatically inferred: a human has to write i=
t.  But -most- of the code
of these migration functions can be inferred automatically from the type-de=
finitions themselves.
</p>

<p>
And that's really all that my little experiment does: automatically infer t=
he migration code (most of
the time) with some hints for those cases where it's not possible to automa=
tically infer.
</p>

<p>
Now, why would one do this?  Well, two reasons:
</p>

<ol class=3D"org-ol">
<li>it should be more maintainable to automatically generate most of the co=
de from types, and it should be quicker to bring online a migration for a n=
ew version of the Ocaml AST.</li>
<li>this should be a good test of PPX rewriting.  That is, if we're going t=
o build a macro-preprocessing support system, shouldn't it be able to make =
solving such straightforward, but very tedious, problems much, much easier?=
</li>
</ol>
</div>
</div>


<div id=3D"outline-container-orgaa8cbbf" class=3D"outline-3">
<h3 id=3D"orgaa8cbbf">Chet Murthy then added</h3>
<div class=3D"outline-text-3" id=3D"text-orgaa8cbbf">
<p>
I forgot to add a third reason why this PPX-rewriter-based approach is bett=
er:
</p>

<ol class=3D"org-ol">
<li>If you look at ocaml-migrate-parsetree "migrations", you'll find that t=
hey're almost all boilerplate code.  But sprinkled here-and-there, is actua=
l logic, actual decisions about how to come up with values for new fields, =
about which fields, when non-trivial (e.g. not "[]") should lead to migrati=
on-failure, etc.  It is this code, that is the actual meat of the migration=
, and it's not at all obvious, when sprinkled thru the mass of mechanically=
-produclble boilerplate.</li>
</ol>

<p>
A mechanized production of that boilerplate would mean that we retained exp=
licitly only this nontrivial code, and hence for maintenance we could focus=
 on it, and make sure it does the right thing.
</p>
</div>
</div>


<div id=3D"outline-container-orga7fe310" class=3D"outline-3">
<h3 id=3D"orga7fe310">Josh Berdine asked</h3>
<div class=3D"outline-text-3" id=3D"text-orga7fe310">
<p>
Figuring out ways to make maintaining this stuff more efficient would be gr=
eat! One aspect that isn't
clear to me is how this approach compares to the process currently used to =
generate the omp code. I
haven't done it myself, but at first glance the tools to generate the omp c=
ode (e.g. gencopy) seem to
also accurately be describable as heavily using ppx infrastructure in order=
 to implement the map code
from one version to another. Is there an executive summary that compares an=
d contrasts that and this
proposal?
</p>
</div>
</div>


<div id=3D"outline-container-org0748279" class=3D"outline-3">
<h3 id=3D"org0748279">Chet Murthy replied</h3>
<div class=3D"outline-text-3" id=3D"text-org0748279">
<p>
>From the README, gencopy is used to generate a prototype file for each migr=
ation, and then a human goes
in and fixes up the code.  A way to put my point is: gencopy should be prov=
ided the fixups in some
compact form, and apply them itself.
</p>
</div>
</div>
</div>




<div id=3D"outline-container-org0cf1d5d" class=3D"outline-2">
<h2 id=3D"7">telltime - when is when exactly?</h2>
<div class=3D"outline-text-2" id=3D"text-7">
<p>
Archive: <a href=3D"https://discuss.ocaml.org/t/ann-telltime-when-is-when-e=
xactly/6372/1">https://discuss.ocaml.org/t/ann-telltime-when-is-when-exactl=
y/6372/1</a>
</p>
</div>

<div id=3D"outline-container-org0c0a8db" class=3D"outline-3">
<h3 id=3D"org0c0a8db">Darren announced</h3>
<div class=3D"outline-text-3" id=3D"text-org0c0a8db">
<p>
I'm happy to announce release of <a href=3D"https://github.com/daypack-dev/=
telltime">telltime</a> 0.0.1, a small cli
tool for interacting with Daypack-lib (a schedule, time, time slots handlin=
g library) components.
</p>

<p>
It primarily answers time related queries, with support for union (<code>||=
</code>), intersect (<code>&amp;&amp;</code>) and "ordered
select" (<code>&gt;&gt;</code>, explanation of this is at the bottom).
</p>

<p>
The query language, time expression, aims to mimic natural language, but wi=
thout ambiguity. The grammar
is only documented in the online demo <a href=3D"https://daypack-dev.github=
.io/time-expr-demo/">here</a> at the
moment.
</p>

<p>
Some examples copied from the README are as follows.
</p>
</div>

<div id=3D"outline-container-org8d2ebb2" class=3D"outline-4">
<h4 id=3D"org8d2ebb2">Search for time slots matching Daypack time expressio=
n</h4>
<div class=3D"outline-text-4" id=3D"text-org8d2ebb2">
<p>
"Hm, I wonder what years have Febuary 29th?"
</p>

<pre class=3D"example">
$ telltime search --time-slots 5 --years 100 "feb 29 00:00"
Searching in time zone offset (seconds)            : 36000
Search by default starts from (in above time zone) : 2020 Sep 03 19:24:15

Matching time slots (in above time zone):
[2024 Feb 29 00:00:00, 2024 Feb 29 00:00:01)
[2028 Feb 29 00:00:00, 2028 Feb 29 00:00:01)
[2032 Feb 29 00:00:00, 2032 Feb 29 00:00:01)
[2036 Feb 29 00:00:00, 2036 Feb 29 00:00:01)
[2040 Feb 29 00:00:00, 2040 Feb 29 00:00:01)
</pre>

<p>
"Would be handy to know what this cron expression refers to"
</p>
<pre class=3D"example">
$ telltime search --time-slots 5 "0 4 8-14 * *"
Searching in time zone offset (seconds)            : 36000
Search by default starts from (in above time zone) : 2020 Sep 06 17:39:56

Matching time slots (in above time zone):
[2020 Sep 08 04:00:00, 2020 Sep 08 04:01:00)
[2020 Sep 09 04:00:00, 2020 Sep 09 04:01:00)
[2020 Sep 10 04:00:00, 2020 Sep 10 04:01:00)
[2020 Sep 11 04:00:00, 2020 Sep 11 04:01:00)
[2020 Sep 12 04:00:00, 2020 Sep 12 04:01:00)
</pre>

<p>
"I have a bunch of time ranges, but some of them overlap, and they are not =
in the right order. If only
there is a way to combine and sort them easily."
</p>

<pre class=3D"example">
$ telltime search --time-slots 1000 "2020 . jan . 1, 10, 20 . 13:00 to 14:0=
0 \
  || 2019 dec 25 13:00 \
  || 2019 dec 25 10am to 17:00 \
  || 2020 jan 5 10am to 1:30pm \
  || 2020 . jan . 7 to 12 . 9:15am to 2:45pm"
Searching in time zone offset (seconds)            : 36000
Search by default starts from (in above time zone) : 2020 Sep 06 18:01:12

Matching time slots (in above time zone):
[2019 Dec 25 10:00:00, 2019 Dec 25 17:00:00)
[2020 Jan 01 13:00:00, 2020 Jan 01 14:00:00)
[2020 Jan 05 10:00:00, 2020 Jan 05 13:30:00)
[2020 Jan 07 09:15:00, 2020 Jan 07 14:45:00)
[2020 Jan 08 09:15:00, 2020 Jan 08 14:45:00)
[2020 Jan 09 09:15:00, 2020 Jan 09 14:45:00)
[2020 Jan 10 09:15:00, 2020 Jan 10 14:45:00)
[2020 Jan 11 09:15:00, 2020 Jan 11 14:45:00)
[2020 Jan 12 09:15:00, 2020 Jan 12 14:45:00)
[2020 Jan 20 13:00:00, 2020 Jan 20 14:00:00)
</pre>
</div>
</div>

<div id=3D"outline-container-orgb12d248" class=3D"outline-4">
<h4 id=3D"orgb12d248">Get exact time after some duration from now</h4>
<div class=3D"outline-text-4" id=3D"text-orgb12d248">
<pre class=3D"example">
$ telltime from-now "1 hour"
Now                   : 2020-09-03 15:53:29
Duration (original)   : 1 hour
Duration (normalized) : 1 hours 0 mins 0 secs
Now + duration        : 2020-09-03 16:53:29
</pre>

<pre class=3D"example">
$ telltime from-now "1.5 days 2.7 hours 0.5 minutes"
Now                   : 2020-09-03 15:55:43
Duration (original)   : 1.5 days 2.7 hours 0.5 minutes
Duration (normalized) : 1 days 14 hours 42 mins 30 secs
Now + duration        : 2020-09-05 06:38:13
</pre>
</div>
</div>

<div id=3D"outline-container-org1eccab5" class=3D"outline-4">
<h4 id=3D"org1eccab5">Difference between ordered select and union</h4>
<div class=3D"outline-text-4" id=3D"text-org1eccab5">
<p>
<code>s1 &gt;&gt; s2</code> is similar to <code>s1 || s2</code>, but <code>=
&gt;&gt;</code> picks between s1 and s2 in a round robin fashion, instead
of just picking the smallest between two.
</p>

<p>
One specific differing case would be when the search starts at 4pm today, <=
code>3pm || 5pm</code> would return 5pm
today and 3pm tomorrow, and so on, while <code>3pm &gt;&gt; 5pm</code> woul=
d return 3pm tomorrow and 5pm tomorrow (a 5pm
is only picked after a 3pm has been picked already).
</p>
</div>
</div>
</div>
</div>




<div id=3D"outline-container-orgf0b31b5" class=3D"outline-2">
<h2 id=3D"8">Ocamlunit emacs minor-mode</h2>
<div class=3D"outline-text-2" id=3D"text-8">
<p>
Archive: <a href=3D"https://discuss.ocaml.org/t/ocamlunit-emacs-minor-mode/=
6373/1">https://discuss.ocaml.org/t/ocamlunit-emacs-minor-mode/6373/1</a>
</p>
</div>

<div id=3D"outline-container-org781a90f" class=3D"outline-3">
<h3 id=3D"org781a90f">Manfred Bergmann announced</h3>
<div class=3D"outline-text-3" id=3D"text-org781a90f">
<p>
Here is a first version of this plugin that allows running <code>dune test<=
/code> with an Emacs key stroke.
It shows the test result in a separate buffer and a simple colorized status=
 'message'.
</p>

<p>
<a href=3D"https://github.com/mdbergmann/emacs-ocamlunit">https://github.co=
m/mdbergmann/emacs-ocamlunit</a>
</p>

<p>
While it is possible to run <code>dune</code> in 'watch' mode I'd like to m=
anually run tests.
</p>

<p>
I didn't find a way to specify individual test modules in <code>dune</code>=
. Is that possible?
</p>
</div>
</div>
</div>




<div id=3D"outline-container-orgd012186" class=3D"outline-2">
<h2 id=3D"9">Sihl 0.1.0</h2>
<div class=3D"outline-text-2" id=3D"text-9">
<p>
Archive: <a href=3D"https://discuss.ocaml.org/t/ann-sihl-0-1-0/6374/1">http=
s://discuss.ocaml.org/t/ann-sihl-0-1-0/6374/1</a>
</p>
</div>

<div id=3D"outline-container-org3380cb5" class=3D"outline-3">
<h3 id=3D"org3380cb5">jerben announced</h3>
<div class=3D"outline-text-3" id=3D"text-org3380cb5">
<p>
I am happy to announce this milestone release of Sihl, a web framework for =
OCaml.
</p>

<p>
Github: <a href=3D"https://github.com/oxidizing/sihl">https://github.com/ox=
idizing/sihl</a> <br />
opam: <a href=3D"http://opam.ocaml.org/packages/sihl/">http://opam.ocaml.or=
g/packages/sihl/</a>
</p>

<p>
Sihl is really just a collection of services that can be plugged into each =
other and a tiny core that
knows how to start them. The goal is to take care of infrastructure concern=
s so you can focus on the
domain.
</p>

<p>
After many iterations, the API is in a shape where we dare to show it to yo=
u :slight_smile:
It is still under heavy development so expect breakage without a major vers=
ion bump. However, we just
finished migrating a project from Reason on NodeJS to OCaml on Sihl, so we =
use it in production.
</p>

<p>
We provide service implementations that were useful to us so far. In the fu=
ture we want to provide many
more to cover all kinds of needs. (PRs are always welcome!)
</p>

<p>
Any feedback is greatly appreciated, thanks! :)
</p>
</div>
</div>


<div id=3D"outline-container-org9dc6a4e" class=3D"outline-3">
<h3 id=3D"org9dc6a4e">jerben then added</h3>
<div class=3D"outline-text-3" id=3D"text-org9dc6a4e">
<p>
Here is an example of a tiny Sihl app:
</p>

<div class=3D"org-src-container">
<pre class=3D"src src-ocaml"><span style=3D"color: #000000; font-weight: bo=
ld;">module</span> <span style=3D"color: #228b22;">Service</span> =3D <span=
 style=3D"color: #000000; font-weight: bold;">struct</span>
  <span style=3D"color: #000000; font-weight: bold;">module</span> <span st=
yle=3D"color: #228b22;">Random</span> =3D <span style=3D"color: #228b22;">S=
ihl.Utils.Random.Service</span>
  <span style=3D"color: #000000; font-weight: bold;">module</span> <span st=
yle=3D"color: #228b22;">Log</span> =3D <span style=3D"color: #228b22;">Sihl=
.Log.Service</span>
  <span style=3D"color: #000000; font-weight: bold;">module</span> <span st=
yle=3D"color: #228b22;">Config</span> =3D <span style=3D"color: #228b22;">S=
ihl.Config.Service</span>
  <span style=3D"color: #000000; font-weight: bold;">module</span> <span st=
yle=3D"color: #228b22;">Db</span> =3D <span style=3D"color: #228b22;">Sihl.=
Data.Db.Service</span>
  <span style=3D"color: #000000; font-weight: bold;">module</span> <span st=
yle=3D"color: #228b22;">MigrationRepo</span> =3D <span style=3D"color: #228=
b22;">Sihl.Data.Migration.Service.Repo.MariaDb</span>
  <span style=3D"color: #000000; font-weight: bold;">module</span> <span st=
yle=3D"color: #228b22;">Cmd</span> =3D <span style=3D"color: #228b22;">Sihl=
.Cmd.Service</span>
  <span style=3D"color: #000000; font-weight: bold;">module</span> <span st=
yle=3D"color: #228b22;">Migration</span> =3D <span style=3D"color: #228b22;=
">Sihl.Data.Migration.Service.Make (Cmd) (Db) (MigrationRepo)</span>
  <span style=3D"color: #000000; font-weight: bold;">module</span> <span st=
yle=3D"color: #228b22;">WebServer</span> =3D <span style=3D"color: #228b22;=
">Sihl.Web.Server.Service.Make (Cmd)</span>
  <span style=3D"color: #000000; font-weight: bold;">module</span> <span st=
yle=3D"color: #228b22;">Schedule</span> =3D <span style=3D"color: #228b22;"=
>Sihl.Schedule.Service.Make (Log)</span>
<span style=3D"color: #000000; font-weight: bold;">end</span>

<span style=3D"color: #000000; font-weight: bold;">let</span> <span style=
=3D"color: #a0522d;">services</span> :<span style=3D"color: #228b22;"> (</s=
pan><span style=3D"color: #a020f0;">module</span><span style=3D"color: #228=
b22;"> </span><span style=3D"color: #228b22;">Sihl.Core.Container.SERVICE</=
span><span style=3D"color: #228b22;">) list </span>=3D
  [ (<span style=3D"color: #a020f0;">module</span> <span style=3D"color: #2=
28b22;">Service.WebServer</span>) ]

<span style=3D"color: #000000; font-weight: bold;">let</span> <span style=
=3D"color: #a0522d;">hello_page</span> =3D
  <span style=3D"color: #228b22;">Sihl.Web.Route.</span>get <span style=3D"=
color: #8b2252;">"/hello/"</span> (<span style=3D"color: #a020f0;">fun</spa=
n> <span style=3D"color: #a0522d;">_</span> -&gt;
      <span style=3D"color: #228b22;">Sihl.Web.Res.</span>(html <span style=
=3D"color: #a52a2a;">|&gt;</span> set_body <span style=3D"color: #8b2252;">=
"Hello!"</span>) <span style=3D"color: #a52a2a;">|&gt;</span> <span style=
=3D"color: #228b22;">Lwt.</span>return)

<span style=3D"color: #000000; font-weight: bold;">let</span> <span style=
=3D"color: #a0522d;">routes</span> =3D [ (<span style=3D"color: #8b2252;">"=
/page"</span>, [ hello_page ], <span style=3D"color: #000000; background-co=
lor: #ffffff;">[]</span>) ]

<span style=3D"color: #000000; font-weight: bold;">module</span> <span styl=
e=3D"color: #228b22;">App</span> =3D <span style=3D"color: #228b22;">Sihl.A=
pp.Make (Service)</span>

<span style=3D"color: #000000; font-weight: bold;">let</span> <span style=
=3D"color: #a0522d;">_</span> =3D <span style=3D"color: #228b22;">App.</spa=
n>(empty <span style=3D"color: #a52a2a;">|&gt;</span> with_services service=
s <span style=3D"color: #a52a2a;">|&gt;</span> with_routes routes <span sty=
le=3D"color: #a52a2a;">|&gt;</span> run)
</pre>
</div>
</div>
</div>
</div>




<div id=3D"outline-container-org29f8d50" class=3D"outline-2">
<h2 id=3D"10">promise_jsoo 0.1.0</h2>
<div class=3D"outline-text-2" id=3D"text-10">
<p>
Archive: <a href=3D"https://discuss.ocaml.org/t/ann-promise-jsoo-0-1-0/6377=
/1">https://discuss.ocaml.org/t/ann-promise-jsoo-0-1-0/6377/1</a>
</p>
</div>

<div id=3D"outline-container-org1540bbb" class=3D"outline-3">
<h3 id=3D"org1540bbb">Max LANTAS announced</h3>
<div class=3D"outline-text-3" id=3D"text-org1540bbb">
<p>
Hello! I am announcing the first release of <code>promise_jsoo</code>, a li=
brary for JS promises in Js_of_ocaml.
</p>

<p>
<a href=3D"https://github.com/mnxn/promise_jsoo">https://github.com/mnxn/pr=
omise_jsoo</a> <br />
<a href=3D"https://opam.ocaml.org/packages/promise_jsoo/">https://opam.ocam=
l.org/packages/promise_jsoo/</a>
</p>

<p>
The library has bindings to the core <code>Promise</code> methods as well a=
s helper functions that make it easier
to deal with a <code>Promise</code> of an <code>option</code> or <code>resu=
lt</code>. It is also possible to use this library with
<a href=3D"https://github.com/LexiFi/gen_js_api">gen_js_api</a> to make for=
 an easier JavaScript binding experience
</p>

<p>
Inspired by
<a href=3D"https://github.com/aantron/promise#discussion-how-reason-promise=
-makes-promises-type-safe">aantron/promise</a>,
this library also uses indirection internally when handling nested promises=
 in order to ensure that the
bindings are type safe.
</p>

<p>
This project is part of ongoing work to port
<a href=3D"https://github.com/ocamllabs/vscode-ocaml-platform">vscode-ocaml=
-platform</a> to Js_of_ocaml.
</p>

<p>
Generated documentation can be found
<a href=3D"https://mnxn.github.io/promise_jsoo/promise_jsoo/Promise/index.h=
tml">here</a>.
</p>
</div>
</div>
</div>




<div id=3D"outline-container-orgcef4b76" class=3D"outline-2">
<h2 id=3D"11">Other OCaml News</h2>
<div class=3D"outline-text-2" id=3D"text-11">
</div>
<div id=3D"outline-container-org695e062" class=3D"outline-3">
<h3 id=3D"org695e062">From the ocamlcore planet blog</h3>
<div class=3D"outline-text-3" id=3D"text-org695e062">
<p>
Here are links from many OCaml blogs aggregated at <a href=3D"http://ocaml.=
org/community/planet/">OCaml Planet</a>.
</p>

<ul class=3D"org-ul">
<li><a href=3D"https://blog.janestreet.com/announcing-signals-and-threads-i=
ndex/">Announcing Signals and Threads, a new podcast from Jane Street</a></=
li>
</ul>
</div>
</div>
</div>




<div id=3D"outline-container-orgf7c3f69" class=3D"outline-2">
<h2 id=3D"orgf7c3f69">Old CWN</h2>
<div class=3D"outline-text-2" id=3D"text-orgf7c3f69">
<p>
If you happen to miss a CWN, you can <a href=3D"mailto:alan.schmitt@polytec=
hnique.org">send me a message</a> and I'll mail it to you, or go take a loo=
k at <a href=3D"http://alan.petitepomme.net/cwn/">the archive</a> or the <a=
 href=3D"http://alan.petitepomme.net/cwn/cwn.rss">RSS feed of the archives<=
/a>.
</p>

<p>
If you also wish to receive it every week by mail, you may subscribe <a hre=
f=3D"http://lists.idyll.org/listinfo/caml-news-weekly/">online</a>.
</p>

<div class=3D"authorname">
<p>
<a href=3D"http://alan.petitepomme.net/">Alan Schmitt</a>
</p>

</div>
</div>
</div>
</div>
</body>
</html>


--=-=-=--

