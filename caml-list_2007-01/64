Return-Path: <robert@fischerventure.com>
X-Spam-Checker-Version: SpamAssassin 3.1.3 (2006-06-01) on yquem.inria.fr
X-Spam-Level: 
X-Spam-Status: No, score=0.6 required=5.0 tests=NO_REAL_NAME 
	autolearn=disabled version=3.1.3
X-Original-To: caml-list@yquem.inria.fr
Delivered-To: caml-list@yquem.inria.fr
Received: from concorde.inria.fr (concorde.inria.fr [192.93.2.39])
	by yquem.inria.fr (Postfix) with ESMTP id CFFF0BC0A
	for <caml-list@yquem.inria.fr>; Mon,  8 Jan 2007 20:31:36 +0100 (CET)
Received: from webmail1.sd.dreamhost.com (webmail1.sd.dreamhost.com [66.33.201.159])
	by concorde.inria.fr (8.13.6/8.13.6) with ESMTP id l08JVZc3021176
	for <caml-list@inria.fr>; Mon, 8 Jan 2007 20:31:36 +0100
Received: from webmail.fischerventure.com (localhost [127.0.0.1])
	by webmail1.sd.dreamhost.com (Postfix) with ESMTP id 6E9312C183
	for <caml-list@inria.fr>; Mon,  8 Jan 2007 11:31:34 -0800 (PST)
Received: from 151.151.73.168
        (SquirrelMail authenticated user robert@fischerventure.com)
        by webmail.fischerventure.com with HTTP;
        Mon, 8 Jan 2007 11:31:34 -0800 (PST)
Message-ID: <43813.151.151.73.168.1168284694.squirrel@webmail.fischerventure.com>
In-Reply-To: <45A29223.3090600@mcmaster.ca>
References: 
    <1168193722.6133.38.camel@Blefuscu>	<1168209464.8650.36.camel@rosella.wigram>
    <60198.151.151.21.104.1168280811.squirrel@webmail.fischerventure.com>
    <45A29223.3090600@mcmaster.ca>
Date: Mon, 8 Jan 2007 11:31:34 -0800 (PST)
Subject: Re: [Caml-list] Before teaching OCaml
From: robert@fischerventure.com
To: "OCaml" <caml-list@inria.fr>
User-Agent: SquirrelMail/1.4.9a
MIME-Version: 1.0
Content-Type: text/plain;charset=iso-8859-1
Content-Transfer-Encoding: 8bit
X-j-chkmail-Score: MSGID : 45A29C17.001 on concorde : j-chkmail score : X : 0/20 1 0.000 -> 1
X-Miltered: at concorde with ID 45A29C17.001 by Joe's j-chkmail (http://j-chkmail . ensmp . fr)!
X-Spam: no; 0.00; ocaml:01 algebra:01 syntax:01 guis:01 ocaml's:01 algebra:01 functors:01 renaud:01 functors:01 polymorphism:01 functionnal:01 abstraction:01 polymorphism:01 ocaml:01 behaves:01 

Alright, then I recommend staying to the simple stuff (and away from
Abstract Algebra) for the sake of the class.  I stand by the simple
mathematical interpreter as a good example, though.

The nice thing about mathematics is that one can assume a rather universal
"intuitive" understanding with this class, so the instructor wouldn't need
to get into syntax definitions or the like.  And the project doesn't
require any mucking about with GUIs, which is a lot of time dedicated to
little learning return.

Thanks for the paper reference, BTW.

~~ Robert.
Fischer Venture Management Corp

>> This was actually going to be my suggestion.  I'd suggest a very
>> toned-down version of a mathematics interpreter (think of a baby
>> Mathematica).  That's the kind of problem that will play well to Ocaml's
>> strengths, and since you're looking at math-oriented problems, it'd be
>> reasonably forward.
>>
>> It'd be really fun to do this post-abstract algebra.  Define Rings and
>> that kind of stuff as functors, and then go to town.  :-D
>>
> You would think so - and then when actually doing it, realize that it
> doesn't *quite* work.  See for example
> http://focal.inria.fr/site/images/stories/articles/boulme_rr00b.ps.gz
> i.e.
>
> @TECHREPORT{BoulmeRR00b,
>   AUTHOR = {Sylvain Boulm\'e and Th\'er\`ese Hardin and Renaud Rioboo},
>   TITLE = {Polymorphic Data Types, Objects, Modules and Functors: is it
> too much?},
>   INSTITUTION = {LIP6},
>   TYPE = {Research report},
>   YEAR = 2000,
>   NOTE = {Available on
> \url{http://www.lip6.fr/reports/lip6.2000.014.html}{http://www.lip6.fr/reports/lip6.2000.014.html}},
>   KEYWORDS = {classes, modules, functors, objects, types, polymorphism,
> functionnal programming, Computer Algebra, specification, library},
>   ABSTRACT = {Abstraction is a powerful tool for developers and it is
> offered by numerous features such as polymorphism, classes, modules and
> functors, ...
>                       A working programmer may be confused with this
> abundance. We develop a computer algebra library
> which is being certified. Reporting this experience
> made with a
>                       language (Ocaml) offering all these features, we
> argue that they are all needed together. We compare
> several ways of using classes to represent algebraic
> concept,
>                       trying to follow as close as possible mathematical
> specification. Then we show how to combine classes
> and modules to produce code having very strong
> properties.
>                       Currently, this library is made of one hundred units
> of functional codes and behaves faster than
> analogous ones such as Axiom}
> }
>
> To really make it 'work', you need quite a bit of technology.  You can do
> a toy version without getting too fancy, but you have to be careful
> because so many different extensions you might want to implement do not
> *quite* work.
>
> I have also seen a "baby Maple" written in Haskell -- the level of
> necessary technology is also quite high.
>
> Jacques
>


