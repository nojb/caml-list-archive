Return-Path: <jonathandeanharrop@googlemail.com>
X-Original-To: caml-list@yquem.inria.fr
Delivered-To: caml-list@yquem.inria.fr
Received: from mail2-relais-roc.national.inria.fr (mail2-relais-roc.national.inria.fr [192.134.164.83])
	by yquem.inria.fr (Postfix) with ESMTP id D1C17BBAF
	for <caml-list@yquem.inria.fr>; Fri, 13 Aug 2010 01:14:26 +0200 (CEST)
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: AkMCAJkdZExKfVIqmGdsb2JhbACBRJMJi2AIFQEBAQEBCAkMBxEiokqLIgEFjyMBBIU6
X-IronPort-AV: E=Sophos;i="4.55,360,1278280800"; 
   d="scan'208,217";a="57028372"
Received: from mail-ww0-f42.google.com ([74.125.82.42])
  by mail2-smtp-roc.national.inria.fr with ESMTP; 13 Aug 2010 01:14:25 +0200
Received: by wwf26 with SMTP id 26so21767wwf.3
        for <caml-list@yquem.inria.fr>; Thu, 12 Aug 2010 16:14:25 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=googlemail.com; s=gamma;
        h=domainkey-signature:received:received:from:to:cc:references
         :in-reply-to:subject:date:organization:message-id:mime-version
         :content-type:x-mailer:thread-index:content-language;
        bh=YA1BKs9tEuftCpXbCvoG7AdapU4ISZMboBExSWzdXi0=;
        b=AdTd7HAohsmmzZ+T4SzZkput4CUwwjiQ4CFKjt193XXeAni9fqk3ucoTelDAIq4ucX
         UXME8d07hF98ufNEYGKxso59yYOWx73a6js2hlqQFe2hFhx5lfg9Hf8RckjD/yYSk1Iy
         097aZG+GxdzeZEKX7QBV8vfOHRRVQfdKqnAZE=
DomainKey-Signature: a=rsa-sha1; c=nofws;
        d=googlemail.com; s=gamma;
        h=from:to:cc:references:in-reply-to:subject:date:organization
         :message-id:mime-version:content-type:x-mailer:thread-index
         :content-language;
        b=w3nBfYWrSwg6FeGRIm8XjQ8oXmFnv9awBKAcjA2Z2kT25i1+1gedjhYL9ZntP4or3/
         Ra4sHz9+LzpGdOtUjv1vXDcgmG6r8OxJXBoiyfoBCoD8kJS5CxPxAqzP7h1JGs1nOCSj
         gk7ri+VSj8Teb9plwplj9vDTLBXDW8jmq/8+M=
Received: by 10.227.143.12 with SMTP id s12mr705127wbu.125.1281654865558;
        Thu, 12 Aug 2010 16:14:25 -0700 (PDT)
Received: from WinEight ([87.113.155.108])
        by mx.google.com with ESMTPS id a1sm1695569wbb.2.2010.08.12.16.14.21
        (version=SSLv3 cipher=RC4-MD5);
        Thu, 12 Aug 2010 16:14:23 -0700 (PDT)
From: Jon Harrop <jonathandeanharrop@googlemail.com>
To: "'Jeremy Bem'" <jeremy1@gmail.com>,
	"'Jon Harrop'" <jonathandeanharrop@googlemail.com>
Cc: "'bluestorm'" <bluestorm.dylc@gmail.com>,
	"'caml-list List'" <caml-list@yquem.inria.fr>,
	"'Florian Weimer'" <fw@deneb.enyo.de>
References: <AANLkTi=UuefVu9CmwwomimGzMqFrks5SZ+227Znv5r+z@mail.gmail.com>	<877hk1m1df.fsf@mid.deneb.enyo.de>	<AANLkTi=L07p_xN7DCZQn0j+iy=-_7FzCrTm6KOf6oaJU@mail.gmail.com>	<87bp9dkkca.fsf@mid.deneb.enyo.de>	<4c5f194e.8644d80a.7fef.69e6@mx.google.com>	<AANLkTinPp4njJm+PH1EfURubPcKi-Y8UZd1p7yODjAJ7@mail.gmail.com>	<AANLkTimoAn8PNOW2X+eTYPQneKQertH-K__Q63mU9T7x@mail.gmail.com>	<AANLkTimob_iCJiwqJ8S4EYe94vPUzjnd7xKwUxAo0q_D@mail.gmail.com>	<03fb01cb3955$76093770$621ba650$@com> <AANLkTi=Gcy2eBcQ2peOawnUk2Qfq1uOXSdSAouAnS=Hj@mail.gmail.com>
In-Reply-To: <AANLkTi=Gcy2eBcQ2peOawnUk2Qfq1uOXSdSAouAnS=Hj@mail.gmail.com>
Subject: RE: [Caml-list] interest in a much simpler, but modern, Caml?
Date: Fri, 13 Aug 2010 00:14:19 +0100
Organization: Flying Frog Consultancy
Message-ID: <009e01cb3a74$193f5770$4bbe0650$@com>
MIME-Version: 1.0
Content-Type: multipart/alternative;
	boundary="----=_NextPart_000_009F_01CB3A7C.7B03BF70"
X-Mailer: Microsoft Office Outlook 12.0
Thread-Index: Acs5tFhja6ItLvdwTMqDPpU5/IodeAAvmn7A
Content-Language: en-gb
X-Spam: no; 0.00; bool:01 delimited:01 overloading:01 hashing:01 cheers:01 ocaml's:01 runtime:01 abstraction:01 ocamllex:01 pervasives:01 syntax:01 ocaml:01 overloading:01 minimalist:01 higher-order:01 

This is a multi-part message in MIME format.

------=_NextPart_000_009F_01CB3A7C.7B03BF70
Content-Type: text/plain;
	charset="us-ascii"
Content-Transfer-Encoding: 7bit

Presumably, in general, that would need to be:

 

  If Bool.(Int.(x=42) || Int.(x=45)) .

 

At which point things start to look hairy. To be honest, I see this
delimited overloading as the best of a bad job in the absence of equality
types or per-type functionality. I think what we really want is to be able
to define custom equality, comparison and hashing on types when structural
versions are not applicable. F#'s solution is pretty good. Type classes are
a generalization but I do not see that they buy you much for the added
complexity.

 

I'd have thought this (at least equality types) would be worth putting in a
minimalistic language because it is so useful.

 

Cheers,

Jon.

 

From: Jeremy Bem [mailto:jeremy1@gmail.com] 
Sent: 12 August 2010 01:22
To: Jon Harrop
Cc: bluestorm; caml-list List; Florian Weimer
Subject: Re: [Caml-list] interest in a much simpler, but modern, Caml?

 

On Wed, Aug 11, 2010 at 9:02 AM, Jon Harrop
<jonathandeanharrop@googlemail.com> wrote:

 

What happens when you do:

 if Int.(x = 42 || x = 45) then ... else ...

Presumably it either barfs on the assumption that "||" refers to bitwise-or
between ints, or we're back to inventing progressively more absurd operator
names for each individual combination of types over which they might work.

 

How so?  I think this is a borderline case (even in C++, "||" does not refer
to bitwise-or).  But even if Int.(||) *were* defined as some sort of integer
operation, one could simply write:

  if Int.(x = 42) || Int.(x = 45)

 

Also, I think the discussion has shifted.  For me, the local open is a
reasonably appealing way to stop using OCaml's exotic polymorphic operators
whose behavior depends on the runtime representation and which don't respect
type abstraction.  (For example, ocamllex uses Pervasives.(=) to test
whether Map's are empty, but this breaks if the Map representation changes.)
Moreover the syntax even maintains OCaml compatibility thanks to the recent
update.  But now we seem to be talking about operator overloading, and I'm
just not convinced it's necessary at all in a system with a minimalist
aesthetic.

 

Back to the local opens, I find that I'm hesitant to add so many of them,
especially for equality.  Polymorphic equality is hardly unnatural, after
all (cf. higher-order logic).  I wonder, do any practical languages use
quotient types to implement custom equality predicates?  In principle,
Pervasives.(=) ought to be the "finest" reasonable equivalence relation on a
type, which could then be coarsened:

 

type foo = Foo of int | Goo of string

let _ = assert (Foo 3 <> Goo "3") (* duh *)

let foo_equiv x y =

  match x, y with

    Foo a, Foo b -> a=b

  | Goo a, Goo b -> a=b

  | Foo a, Goo b

  | Goo b, Foo a -> string_of_int a = b

type goo = foo / foo_equiv (* automatically creates goo_of_foo *)

let _ = assert (goo_of_foo (Foo 3) = goo_of_foo (Goo "3"))

 

This would require runtime support.  I envision that every "goo" is a block
whose tag is "Quotient_tag" and which stores a "foo_equiv" closure in its
first Obj field.

 

As it happens, this approach would dovetail with my plans for an integrated
proof assistant.  Of course it lacks the "conservatism" I've been promoting
:)

 

-Jeremy

 


------=_NextPart_000_009F_01CB3A7C.7B03BF70
Content-Type: text/html;
	charset="us-ascii"
Content-Transfer-Encoding: quoted-printable

<html xmlns:v=3D"urn:schemas-microsoft-com:vml" =
xmlns:o=3D"urn:schemas-microsoft-com:office:office" =
xmlns:w=3D"urn:schemas-microsoft-com:office:word" =
xmlns:m=3D"http://schemas.microsoft.com/office/2004/12/omml" =
xmlns=3D"http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=3DContent-Type content=3D"text/html; =
charset=3Dus-ascii">
<meta name=3DGenerator content=3D"Microsoft Word 12 (filtered medium)">
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:"Cambria Math";
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:Calibri;
	panose-1:2 15 5 2 2 2 4 3 2 4;}
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
a:link, span.MsoHyperlink
	{mso-style-priority:99;
	color:blue;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{mso-style-priority:99;
	color:purple;
	text-decoration:underline;}
span.EmailStyle17
	{mso-style-type:personal-reply;
	font-family:"Calibri","sans-serif";
	color:#1F497D;}
.MsoChpDefault
	{mso-style-type:export-only;}
@page WordSection1
	{size:612.0pt 792.0pt;
	margin:72.0pt 72.0pt 72.0pt 72.0pt;}
div.WordSection1
	{page:WordSection1;}
-->
</style>
<!--[if gte mso 9]><xml>
 <o:shapedefaults v:ext=3D"edit" spidmax=3D"1026" />
</xml><![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext=3D"edit">
  <o:idmap v:ext=3D"edit" data=3D"1" />
 </o:shapelayout></xml><![endif]-->
</head>

<body lang=3DEN-GB link=3Dblue vlink=3Dpurple>

<div class=3DWordSection1>

<p class=3DMsoNormal><span =
style=3D'font-size:11.0pt;font-family:"Calibri","sans-serif";
color:#1F497D'>Presumably, in general, that would need to =
be:<o:p></o:p></span></p>

<p class=3DMsoNormal><span =
style=3D'font-size:11.0pt;font-family:"Calibri","sans-serif";
color:#1F497D'><o:p>&nbsp;</o:p></span></p>

<p class=3DMsoNormal><span =
style=3D'font-size:11.0pt;font-family:"Calibri","sans-serif";
color:#1F497D'>&nbsp; If Bool.(Int.(x=3D42) || Int.(x=3D45)) =
&#8230;<o:p></o:p></span></p>

<p class=3DMsoNormal><span =
style=3D'font-size:11.0pt;font-family:"Calibri","sans-serif";
color:#1F497D'><o:p>&nbsp;</o:p></span></p>

<p class=3DMsoNormal><span =
style=3D'font-size:11.0pt;font-family:"Calibri","sans-serif";
color:#1F497D'>At which point things start to look hairy. To be honest, =
I see
this delimited overloading as the best of a bad job in the absence of =
equality
types or per-type functionality. I think what we really want is to be =
able to
define custom equality, comparison and hashing on types when structural
versions are not applicable. F#&#8217;s solution is pretty good. Type =
classes
are a generalization but I do not see that they buy you much for the =
added
complexity.<o:p></o:p></span></p>

<p class=3DMsoNormal><span =
style=3D'font-size:11.0pt;font-family:"Calibri","sans-serif";
color:#1F497D'><o:p>&nbsp;</o:p></span></p>

<p class=3DMsoNormal><span =
style=3D'font-size:11.0pt;font-family:"Calibri","sans-serif";
color:#1F497D'>I&#8217;d have thought this (at least equality types) =
would be
worth putting in a minimalistic language because it is so =
useful.<o:p></o:p></span></p>

<p class=3DMsoNormal><span =
style=3D'font-size:11.0pt;font-family:"Calibri","sans-serif";
color:#1F497D'><o:p>&nbsp;</o:p></span></p>

<p class=3DMsoNormal><span =
style=3D'font-size:11.0pt;font-family:"Calibri","sans-serif";
color:#1F497D'>Cheers,<o:p></o:p></span></p>

<p class=3DMsoNormal><span =
style=3D'font-size:11.0pt;font-family:"Calibri","sans-serif";
color:#1F497D'>Jon.<o:p></o:p></span></p>

<p class=3DMsoNormal><span =
style=3D'font-size:11.0pt;font-family:"Calibri","sans-serif";
color:#1F497D'><o:p>&nbsp;</o:p></span></p>

<div style=3D'border:none;border-left:solid blue 1.5pt;padding:0cm 0cm =
0cm 4.0pt'>

<div>

<div style=3D'border:none;border-top:solid #B5C4DF 1.0pt;padding:3.0pt =
0cm 0cm 0cm'>

<p class=3DMsoNormal><b><span lang=3DEN-US =
style=3D'font-size:10.0pt;font-family:
"Tahoma","sans-serif"'>From:</span></b><span lang=3DEN-US =
style=3D'font-size:10.0pt;
font-family:"Tahoma","sans-serif"'> Jeremy Bem =
[mailto:jeremy1@gmail.com] <br>
<b>Sent:</b> 12 August 2010 01:22<br>
<b>To:</b> Jon Harrop<br>
<b>Cc:</b> bluestorm; caml-list List; Florian Weimer<br>
<b>Subject:</b> Re: [Caml-list] interest in a much simpler, but modern, =
Caml?<o:p></o:p></span></p>

</div>

</div>

<p class=3DMsoNormal><o:p>&nbsp;</o:p></p>

<p class=3DMsoNormal>On Wed, Aug 11, 2010 at 9:02 AM, Jon Harrop &lt;<a
href=3D"mailto:jonathandeanharrop@googlemail.com">jonathandeanharrop@goog=
lemail.com</a>&gt;
wrote:<o:p></o:p></p>

<div>

<blockquote style=3D'border:none;border-left:solid #CCCCCC =
1.0pt;padding:0cm 0cm 0cm 6.0pt;
margin-left:4.8pt;margin-right:0cm'>

<div>

<p class=3DMsoNormal><o:p>&nbsp;</o:p></p>

</div>

<p class=3DMsoNormal>What happens when you do:<br>
<br>
&nbsp;if Int.(x =3D 42 || x =3D 45) then ... else ...<br>
<br>
Presumably it either barfs on the assumption that &quot;||&quot; refers =
to
bitwise-or<br>
between ints, or we're back to inventing progressively more absurd =
operator<br>
names for each individual combination of types over which they might =
work.<o:p></o:p></p>

</blockquote>

<div>

<p class=3DMsoNormal><o:p>&nbsp;</o:p></p>

</div>

<div>

<p class=3DMsoNormal>How so? &nbsp;I think this is a borderline case =
(even in
C++, &quot;||&quot; does not refer to bitwise-or). &nbsp;But even if =
Int.(||)
*were* defined as some sort of integer operation, one could simply =
write:<o:p></o:p></p>

</div>

<div>

<p class=3DMsoNormal>&nbsp;&nbsp;if Int.(x =3D 42) || Int.(x =3D =
45)<o:p></o:p></p>

</div>

<div>

<p class=3DMsoNormal><o:p>&nbsp;</o:p></p>

</div>

<div>

<p class=3DMsoNormal>Also, I think the discussion has shifted. &nbsp;For =
me, the
local open is a reasonably appealing way to stop using OCaml's exotic
polymorphic operators whose behavior depends on the runtime =
representation and
which don't respect type abstraction. &nbsp;(For example, ocamllex uses
Pervasives.(=3D) to test whether Map's are empty, but this breaks if the =
Map
representation changes.) &nbsp;Moreover the syntax even maintains OCaml
compatibility thanks to the recent update. &nbsp;But now we seem to be =
talking
about operator overloading, and I'm just not convinced it's necessary at =
all in
a system with a minimalist aesthetic.<o:p></o:p></p>

</div>

<div>

<p class=3DMsoNormal><o:p>&nbsp;</o:p></p>

</div>

<div>

<p class=3DMsoNormal>Back to the local opens, I find that I'm hesitant =
to add so
many of them, especially for equality. &nbsp;Polymorphic equality is =
hardly
unnatural, after all (cf. higher-order logic). &nbsp;I wonder, do any =
practical
languages use quotient types to implement custom equality predicates? =
&nbsp;In
principle, Pervasives.(=3D) ought to be the &quot;finest&quot; =
reasonable
equivalence relation on a type, which could then be =
coarsened:<o:p></o:p></p>

</div>

<div>

<p class=3DMsoNormal><o:p>&nbsp;</o:p></p>

</div>

<div>

<p class=3DMsoNormal><span style=3D'font-family:"Courier New"'>type foo =
=3D Foo of
int | Goo of string</span><o:p></o:p></p>

</div>

<div>

<p class=3DMsoNormal><span style=3D'font-family:"Courier New"'>let _ =3D =
assert (Foo
3 &lt;&gt; Goo &quot;3&quot;) (* duh *)</span><o:p></o:p></p>

</div>

<div>

<p class=3DMsoNormal><span style=3D'font-family:"Courier New"'>let =
foo_equiv x y =3D</span><o:p></o:p></p>

</div>

<div>

<p class=3DMsoNormal><span style=3D'font-family:"Courier =
New"'>&nbsp;&nbsp;match x,
y with</span><o:p></o:p></p>

</div>

<div>

<p class=3DMsoNormal><span style=3D'font-family:"Courier =
New"'>&nbsp;&nbsp;
&nbsp;Foo a, Foo b -&gt; a=3Db</span><o:p></o:p></p>

</div>

<div>

<p class=3DMsoNormal><span style=3D'font-family:"Courier =
New"'>&nbsp;&nbsp;| Goo a,
Goo b -&gt; a=3Db</span><o:p></o:p></p>

</div>

<div>

<p class=3DMsoNormal><span style=3D'font-family:"Courier =
New"'>&nbsp;&nbsp;| Foo a,
Goo b</span><o:p></o:p></p>

</div>

<div>

<p class=3DMsoNormal><span style=3D'font-family:"Courier =
New"'>&nbsp;&nbsp;| Goo b,
Foo a -&gt;&nbsp;string_of_int a =3D b</span><o:p></o:p></p>

</div>

<div>

<p class=3DMsoNormal><span style=3D'font-family:"Courier New"'>type goo =
=3D foo /
foo_equiv (* automatically creates goo_of_foo *)</span><o:p></o:p></p>

</div>

<div>

<p class=3DMsoNormal><span style=3D'font-family:"Courier New"'>let _ =3D =
assert
(goo_of_foo (Foo 3) =3D goo_of_foo (Goo =
&quot;3&quot;))</span><o:p></o:p></p>

</div>

<div>

<p class=3DMsoNormal><o:p>&nbsp;</o:p></p>

</div>

<div>

<p class=3DMsoNormal>This would require runtime support. &nbsp;I =
envision that
every &quot;goo&quot; is a block whose tag is &quot;Quotient_tag&quot; =
and
which stores a &quot;foo_equiv&quot; closure in its first Obj =
field.<o:p></o:p></p>

</div>

<div>

<p class=3DMsoNormal><o:p>&nbsp;</o:p></p>

</div>

<div>

<p class=3DMsoNormal>As it happens, this approach would dovetail with my =
plans
for an integrated proof assistant. &nbsp;Of course it lacks the
&quot;conservatism&quot; I've been promoting :)<o:p></o:p></p>

</div>

<div>

<p class=3DMsoNormal><o:p>&nbsp;</o:p></p>

</div>

<div>

<p class=3DMsoNormal>-Jeremy<o:p></o:p></p>

</div>

<div>

<p class=3DMsoNormal><o:p>&nbsp;</o:p></p>

</div>

</div>

</div>

</div>

</body>

</html>

------=_NextPart_000_009F_01CB3A7C.7B03BF70--

