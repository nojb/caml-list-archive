Return-Path: <yitzhak@research.att.com>
X-Original-To: caml-list@yquem.inria.fr
Delivered-To: caml-list@yquem.inria.fr
Received: from mail4-relais-sop.national.inria.fr (mail4-relais-sop.national.inria.fr [192.134.164.105])
	by yquem.inria.fr (Postfix) with ESMTP id 97A04BC6B
	for <caml-list@yquem.inria.fr>; Tue, 30 Oct 2007 01:13:47 +0100 (CET)
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: AgAAAK4TJkfAXQImh2dsb2JhbACCcottAQEBCAopgRM
X-IronPort-AV: E=Sophos;i="4.21,345,1188770400"; 
   d="scan'208,217";a="18747007"
Received: from discorde.inria.fr ([192.93.2.38])
  by mail4-smtp-sop.national.inria.fr with ESMTP; 30 Oct 2007 01:13:46 +0100
Received: from mail1-relais-roc.national.inria.fr (mail1-relais-roc.national.inria.fr [192.134.164.82])
	by discorde.inria.fr (8.13.6/8.13.6) with ESMTP id l9U0Diei025169
	(version=TLSv1/SSLv3 cipher=RC4-SHA bits=128 verify=OK)
	for <caml-list@inria.fr>; Tue, 30 Oct 2007 01:13:45 +0100
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: AgAAAK4TJkfAFOFui2dsb2JhbACCcottAQEBCAQGDxqBEw
X-IronPort-AV: E=Sophos;i="4.21,345,1188770400"; 
   d="scan'208,217";a="3810022"
Received: from mail-red.research.att.com ([192.20.225.110])
  by mail1-smtp-roc.national.inria.fr with ESMTP; 30 Oct 2007 01:13:43 +0100
Received: from [192.168.0.100] (vpn-26.research.att.com [135.207.240.26])
	by bigmail.research.att.com (8.13.7+Sun/8.11.6) with ESMTP id l9U0Dgc3013274;
	Mon, 29 Oct 2007 20:13:42 -0400 (EDT)
In-Reply-To: <47264C70.5050100@gmail.com>
References: <47264C70.5050100@gmail.com>
Mime-Version: 1.0 (Apple Message framework v752.3)
Content-Type: multipart/alternative; boundary=Apple-Mail-50-647648282
Message-Id: <F65436B6-C5D7-411B-8ED2-43E0D1F34337@research.att.com>
Cc: Caml List <caml-list@inria.fr>
From: Yitzhak Mandelbaum <yitzhak@research.att.com>
Subject: Re: [Caml-list] Patch to 3.10.0 compiler enabling simple spell-checking
Date: Mon, 29 Oct 2007 20:13:32 -0400
To: Edgar Friendly <thelema314@gmail.com>
X-Mailer: Apple Mail (2.752.3)
X-Miltered: at discorde with ID 47267738.000 by Joe's j-chkmail (http://j-chkmail . ensmp . fr)!
X-Spam: no; 0.00; yitzhak:01 mandelbaum:01 yitzhak:01 compiler:01 compiler:01 ocamlc:01 parses:01 cheers:01 ocamlc:01 lablgtk:01 lablgtk:01 gtkinit:01 cmo:01 compilation:01 spellings:01 


--Apple-Mail-50-647648282
Content-Transfer-Encoding: 7bit
Content-Type: text/plain;
	charset=US-ASCII;
	delsp=yes;
	format=flowed

Very cool! Do you think there's any way you could separate it from  
the compiler, like Learner et al.'s SEMINAL work, which separates  
type error messages from the compiler?. Separation could help ensure  
this (and any other, similar) ideas don't accidentally introduce bugs  
into the compiler, and make it much easier for you to maintain. A  
very simple hack might be tod wrap ocamlc in a script that parses  
such error messages and then tokenizes the source file, looking for  
similar strings?

Cheers,
Yitzhak


On Oct 29, 2007, at 5:11 PM, Edgar Friendly wrote:

> One random little feature of GNAT that comes in handy for me is its
> habit of, when I misspell an identifier, giving me a possible  
> correction
> in its compile error message.  Spending some time with the 3.10.0
> sources, I have created a "second draft" patch creating this
> functionality in my favored language.
>
> Example:
> ========
>
> # /home/thelema/Projects/ocaml-custom/bin/ocamlc -o coml -I +lablgtk2
> lablgtk.cma gtkInit.cmo coml.ml
> File "coml.ml", line 61, characters 16-25:
> Unbound value is_arcive, possible misspelling of is_archive
>
> Impacts:
> ========
>
> Efficiency in the case of finding a mistake should be quite good,
> although this shouldn't matter too much since the compiler quits  
> pretty
> early in compilation when it finds an unbound identifier.
>
> In the case of no unbound identifiers, the cost is an extra try/with
> block around the standard lookup.  I haven't made any benchmarks,  
> though.
>
> I expect this code to have little long term maintenance issues - the
> major source of code changes was adding a "* string list" to a  
> number of
> exceptions to carry the list of possible correct spellings to the  
> point
> they get output by the compiler.  These exceptions are still usable as
> before with an empty list in this spot.
>
> It's possible the code has created opportunities for uncaught  
> exceptions
> in the compiler as I only checked for instances of "Not_found" in a  
> few
> files -- those which dealt with the Unbound_* exceptions.  Someone who
> knows the internals better might find places the "Found_nearly"
> exception that carries possible corrections might escape into.
>
>
> Dedicated to:
> Yaron Minsky and the team at Jane Street
>
> E.
> diff --git a/typing/ident.ml b/typing/ident.ml
> index a30aa7a..8bbb395 100644
> --- a/typing/ident.ml
> +++ b/typing/ident.ml
> @@ -56,6 +56,61 @@ let same i1 i2 = i1 = i2
>         then i1.stamp = i2.stamp
>         else i2.stamp = 0 && i1.name = i2.name *)
>
> +(* does various heuristics to find spelling mistakes - algorithm  
> from GNAT Ada compiler - Lots of code, but hopefully about as  
> efficient as possible *)
> +let nearly_equal s i =
> +  let is_digit c = c >= '0' && c <= '9' in
> +  let rec tails_equal s1 i1 s2 i2 = i1 >= String.length s1 || (s1. 
> [i1] = s2.[i2] && tails_equal s1 (i1+1) s2 (i2+1)) in
> +
> +  let n1 = s and n2 = i.name in
> +  let l1 = String.length n1 and l2 = String.length n2 in
> +  if l1 = 0 then l2 = 0 (* both null -> equal *)
> +  else if l2 = 0 then false (* one of n1 or n2 null -> not equal *)
> +  else if n1.[0] != n2.[0] then false (* first characters don't  
> match -> not *)
> +  else if l1 < 3 && l2 < 3 then false (* short strings are all  
> different *)
> +  else if l1 = l2 then
> +    (* look for single errors, transpositions *)
> +    let rec find_diff c =
> +      if c < (l1 - 1) then
> +	if n1.[c] != n2.[c] then
> +	  (* mismatched digits -> not equal *)
> +	  if is_digit n1.[c] && is_digit n2.[c] then false
> +	    (* single error -> equal *)
> +	  else if n1.[c+1] = n2.[c+1] && tails_equal n1 (c+2) n2 (c+2)
> +	  then true
> +	    (* transposition -> equal *)
> +	  else if n1.[c] = n2.[c+1] && n1.[c+1] = n2.[c] &&
> +	  tails_equal n1 (c+2) n2 (c+2)
> +	  then true
> +	  else false
> +	else find_diff (c+1)
> +      else (* at the end of the strings *)
> +	if is_digit n1.[c] && is_digit n2.[c]
> +	  && n1.[c] != n2.[c]
> +	then false
> +	else true
> +    in
> +    find_diff 1
> +  else if l1 = l2 - 1 then (* short by one *)
> +    let rec find_del c =
> +      if c < l1 then
> +	if n1.[c] != n2.[c] then
> +	  tails_equal n1 c n2 (c+1)
> +	else find_del (c+1)
> +      else true (* last character was deleted *)
> +    in
> +    find_del 1
> +  else if l1 = l2 + 1 then (* too long by one *)
> +    let rec find_add c =
> +      if c < l2 then
> +	if n1.[c] != n2.[c] then
> +	  tails_equal n1 (c+1) n2 c
> +	else find_add (c+1)
> +      else true (* last character added *)
> +    in
> +    find_add 1
> +  else (* lengths totally different *)
> +    false
> +	
>  let binding_time i = i.stamp
>
>  let current_time() = !currentstamp
> @@ -97,6 +152,8 @@ and 'a data =
>
>  let empty = Empty
>
> +exception Found_nearly of string list
> +
>  (* Inline expansion of height for better speed
>   * let height = function
>   *     Empty -> 0
> @@ -182,3 +239,34 @@ let rec keys_aux stack accu = function
>        keys_aux (l :: stack) (k.ident :: accu) r
>
>  let keys tbl = keys_aux [] [] tbl
> +
> +let find_nearly_equal n tbl =
> +(*  List.filter (nearly_equal name) (keys tbl) -- optimized for  
> your enjoyment*)
> +  let rec find_nearly_equal_aux stack accu = function
> +      Empty ->
> +	begin match stack with
> +            [] -> accu
> +	  | a :: l -> find_nearly_equal_aux l accu a
> +	end
> +    | Node(l, k, r, _) ->
> +	let accu' =
> +	  if nearly_equal n k.ident
> +	  then k.ident.name :: accu
> +	  else accu
> +	in
> +	find_nearly_equal_aux (l :: stack) accu' r
> +  in
> +  find_nearly_equal_aux [] [] tbl
> +
> +let find_name_with_nearly name tbl =
> +  try find_name name tbl
> +  with Not_found ->
> +(*    prerr_string "FNE: "; prerr_endline name; *)
> +    let nearlies = find_nearly_equal name tbl in
> +(*    let rec pr_list to_str = function [] -> prerr_endline  
> "Empty" | [a] -> prerr_endline (to_str a) | h :: t -> prerr_string  
> (to_str h); prerr_string ", "; pr_list to_str t
> +    in
> +    prerr_string "nearlies: ";
> +    pr_list (fun i -> i) nearlies;
> +    prerr_string "whole table: ";
> +    pr_list (fun i -> i.name) (keys tbl); *)
> +    raise (Found_nearly nearlies)
> diff --git a/typing/ident.mli b/typing/ident.mli
> index 9f7372c..7ab9327 100644
> --- a/typing/ident.mli
> +++ b/typing/ident.mli
> @@ -52,8 +52,12 @@ val print: Format.formatter -> t -> unit
>  type 'a tbl
>          (* Association tables from identifiers to type 'a. *)
>
> +exception Found_nearly of string list
> +
>  val empty: 'a tbl
>  val add: t -> 'a -> 'a tbl -> 'a tbl
>  val find_same: t -> 'a tbl -> 'a
>  val find_name: string -> 'a tbl -> 'a
>  val keys: 'a tbl -> t list
> +
> +val find_name_with_nearly: string -> 'a tbl -> 'a
> diff --git a/typing/typecore.ml b/typing/typecore.ml
> index 691eb49..adff3ad 100644
> --- a/typing/typecore.ml
> +++ b/typing/typecore.ml
> @@ -23,9 +23,9 @@ open Btype
>  open Ctype
>
>  type error =
> -    Unbound_value of Longident.t
> -  | Unbound_constructor of Longident.t
> -  | Unbound_label of Longident.t
> +    Unbound_value of Longident.t * string list
> +  | Unbound_constructor of Longident.t * string list
> +  | Unbound_label of Longident.t * string list
>    | Polymorphic_label of Longident.t
>    | Constructor_arity_mismatch of Longident.t * int * int
>    | Label_mismatch of Longident.t * (type_expr * type_expr) list
> @@ -42,11 +42,11 @@ type error =
>    | Bad_conversion of string * int * char
>    | Undefined_method of type_expr * string
>    | Undefined_inherited_method of string
> -  | Unbound_class of Longident.t
> +  | Unbound_class of Longident.t * string list
>    | Virtual_class of Longident.t
>    | Private_type of type_expr
>    | Private_label of Longident.t * type_expr
> -  | Unbound_instance_variable of string
> +  | Unbound_instance_variable of string * string list
>    | Instance_variable_not_mutable of string
>    | Not_subtype of (type_expr * type_expr) list * (type_expr *  
> type_expr) list
>    | Outside_class
> @@ -276,7 +276,7 @@ let rec build_as_type env p =
>        unify_pat env {p2 with pat_type = ty2} ty1;
>        begin match path with None -> ()
>        | Some path ->
> -          let td = try Env.find_type path env with Not_found ->  
> assert false in
> +          let td = try Env.find_type path env with Not_found |  
> Ident.Found_nearly _ -> assert false in
>            let params = List.map (fun _ -> newvar()) td.type_params in
>            match expand_head env (newty (Tconstr (path, params, ref  
> Mnil)))
>            with {desc=Tvariant row} when static_row row ->
> @@ -291,7 +291,9 @@ let build_or_pat env loc lid =
>    let path, decl =
>      try Env.lookup_type lid env
>      with Not_found ->
> -      raise(Typetexp.Error(loc, Typetexp.Unbound_type_constructor  
> lid))
> +      raise(Typetexp.Error(loc, Typetexp.Unbound_type_constructor  
> (lid,[])))
> +      | Ident.Found_nearly l ->
> +      raise(Typetexp.Error(loc, Typetexp.Unbound_type_constructor  
> (lid,l)))
>    in
>    let tyl = List.map (fun _ -> newvar()) decl.type_params in
>    let fields =
> @@ -400,7 +402,10 @@ let rec type_pat env sp =
>          try
>            Env.lookup_constructor lid env
>          with Not_found ->
> -          raise(Error(sp.ppat_loc, Unbound_constructor lid)) in
> +          raise(Error(sp.ppat_loc, Unbound_constructor (lid,[])))
> +	  | Ident.Found_nearly l ->
> +	  raise(Error(sp.ppat_loc, Unbound_constructor (lid,l)))
> +      in
>        let sargs =
>          match sarg with
>            None -> []
> @@ -449,7 +454,10 @@ let rec type_pat env sp =
>            try
>              Env.lookup_label lid env
>            with Not_found ->
> -            raise(Error(sp.ppat_loc, Unbound_label lid)) in
> +            raise(Error(sp.ppat_loc, Unbound_label (lid,[])))
> +	    | Ident.Found_nearly l ->
> +	    raise(Error(sp.ppat_loc, Unbound_label (lid,l)))
> +	in
>          begin_def ();
>          let (vars, ty_arg, ty_res) = instance_label false label in
>          if vars = [] then end_def ();
> @@ -806,7 +814,7 @@ let rec approx_type env sty =
>          if List.length ctl <> decl.type_arity then raise Not_found;
>          let tyl = List.map (approx_type env) ctl in
>          newconstr path tyl
> -      with Not_found -> newvar ()
> +      with Not_found | Ident.Found_nearly _ -> newvar ()
>        end
>    | _ -> newvar ()
>
> @@ -923,7 +931,9 @@ let rec type_exp env sexp =
>            exp_type = instance desc.val_type;
>            exp_env = env }
>        with Not_found ->
> -        raise(Error(sexp.pexp_loc, Unbound_value lid))
> +        raise(Error(sexp.pexp_loc, Unbound_value (lid,[])))
> +	| Ident.Found_nearly l ->
> +	raise(Error(sexp.pexp_loc, Unbound_value (lid,l)))
>        end
>    | Pexp_constant cst ->
>        re {
> @@ -1021,7 +1031,10 @@ let rec type_exp env sexp =
>            try
>              Env.lookup_label lid env
>            with Not_found ->
> -            raise(Error(sexp.pexp_loc, Unbound_label lid)) in
> +            raise(Error(sexp.pexp_loc, Unbound_label (lid,[])))
> +	    | Ident.Found_nearly l ->
> +	    raise(Error(sexp.pexp_loc, Unbound_label (lid,l)))
> +	in
>          begin_def ();
>          if !Clflags.principal then begin_def ();
>          let (vars, ty_arg, ty_res) = instance_label true label in
> @@ -1098,7 +1111,10 @@ let rec type_exp env sexp =
>          try
>            Env.lookup_label lid env
>          with Not_found ->
> -          raise(Error(sexp.pexp_loc, Unbound_label lid)) in
> +          raise(Error(sexp.pexp_loc, Unbound_label (lid,[])))
> +	  | Ident.Found_nearly l ->
> +	  raise(Error(sexp.pexp_loc, Unbound_label (lid,l)))
> +      in
>        let (_, ty_arg, ty_res) = instance_label false label in
>        unify_exp env arg ty_res;
>        re {
> @@ -1112,7 +1128,10 @@ let rec type_exp env sexp =
>          try
>            Env.lookup_label lid env
>          with Not_found ->
> -          raise(Error(sexp.pexp_loc, Unbound_label lid)) in
> +          raise(Error(sexp.pexp_loc, Unbound_label (lid,[])))
> +	  | Ident.Found_nearly l ->
> +	  raise(Error(sexp.pexp_loc, Unbound_label (lid,l)))
> +      in
>        if label.lbl_mut = Immutable then
>          raise(Error(sexp.pexp_loc, Label_not_mutable lid));
>        begin_def ();
> @@ -1332,7 +1351,9 @@ let rec type_exp env sexp =
>    | Pexp_new cl ->
>        let (cl_path, cl_decl) =
>          try Env.lookup_class cl env with Not_found ->
> -          raise(Error(sexp.pexp_loc, Unbound_class cl))
> +          raise(Error(sexp.pexp_loc, Unbound_class (cl,[])))
> +	  | Ident.Found_nearly l ->
> +	  raise(Error(sexp.pexp_loc, Unbound_class (cl,l)))
>        in
>          begin match cl_decl.cty_new with
>            None ->
> @@ -1361,10 +1382,13 @@ let rec type_exp env sexp =
>          | Val_ivar _ ->
>              raise(Error(sexp.pexp_loc,  
> Instance_variable_not_mutable lab))
>          | _ ->
> -            raise(Error(sexp.pexp_loc, Unbound_instance_variable  
> lab))
> +            raise(Error(sexp.pexp_loc, Unbound_instance_variable  
> (lab,[])))
>        with
>          Not_found ->
> -          raise(Error(sexp.pexp_loc, Unbound_instance_variable lab))
> +          raise(Error(sexp.pexp_loc, Unbound_instance_variable  
> (lab,[])))
> +	| Ident.Found_nearly l ->
> +	  raise(Error(sexp.pexp_loc, Unbound_instance_variable (lab,l)))
> +
>        end
>    | Pexp_override lst ->
>        let _ =
> @@ -1380,7 +1404,7 @@ let rec type_exp env sexp =
>          try
>            Env.lookup_value (Longident.Lident "selfpat-*") env,
>            Env.lookup_value (Longident.Lident "self-*") env
> -        with Not_found ->
> +        with Not_found | Ident.Found_nearly _ ->
>            raise(Error(sexp.pexp_loc, Outside_class))
>        with
>          (_, {val_type = self_ty; val_kind = Val_self (_, vars, _,  
> _)}),
> @@ -1391,7 +1415,9 @@ let rec type_exp env sexp =
>                (Path.Pident id, type_expect env snewval (instance ty))
>              with
>                Not_found ->
> -                raise(Error(sexp.pexp_loc,  
> Unbound_instance_variable lab))
> +                raise(Error(sexp.pexp_loc,  
> Unbound_instance_variable (lab,[])))
> +	      | Ident.Found_nearly l ->
> +		raise(Error(sexp.pexp_loc, Unbound_instance_variable (lab,l)))
>              end
>            in
>            let modifs = List.map type_override lst in
> @@ -1637,7 +1663,7 @@ and type_application env funct sargs =
>                    may_warn sarg0.pexp_loc
>                      (Warnings.Not_principal "commuting this  
> argument");
>                  (l', sarg0, sargs1 @ sargs2, more_sargs)
> -              with Not_found ->
> +              with Not_found | Ident.Found_nearly _ ->
>                  let (l', sarg0, sargs1, sargs2) =
>                    extract_label name more_sargs in
>                  if sargs1 <> [] || sargs <> [] then
> @@ -1707,7 +1733,9 @@ and type_construct env loc lid sarg  
> explicit_arity ty_expected =
>      try
>        Env.lookup_constructor lid env
>      with Not_found ->
> -      raise(Error(loc, Unbound_constructor lid)) in
> +      raise(Error(loc, Unbound_constructor (lid,[])))
> +      | Ident.Found_nearly l ->
> +      raise(Error(loc, Unbound_constructor (lid,l))) in
>    let sargs =
>      match sarg with
>        None -> []
> @@ -2020,12 +2048,18 @@ open Format
>  open Printtyp
>
>  let report_error ppf = function
> -  | Unbound_value lid ->
> -      fprintf ppf "Unbound value %a" longident lid
> -  | Unbound_constructor lid ->
> +  | Unbound_value (lid,[]) ->
> +      fprintf ppf "Unbound value %a" longident lid
> +  | Unbound_value (lid,corr::_) ->
> +      fprintf ppf "Unbound value %a, possible misspelling of %s"  
> longident lid corr
> +  | Unbound_constructor (lid,[]) ->
>        fprintf ppf "Unbound constructor %a" longident lid
> -  | Unbound_label lid ->
> +  | Unbound_constructor (lid,corr::_) ->
> +      fprintf ppf "Unbound constructor %a, possible misspelling of  
> %s" longident lid corr
> +  | Unbound_label (lid,[]) ->
>        fprintf ppf "Unbound record field label %a" longident lid
> +  | Unbound_label (lid,corr::_) ->
> +      fprintf ppf "Unbound record field label %a, possible  
> misspelling of %s" longident lid corr
>    | Polymorphic_label lid ->
>        fprintf ppf "@[The record field label %a is polymorphic.@ %s@]"
>          longident lid "You cannot instantiate it in a pattern."
> @@ -2100,13 +2134,17 @@ let report_error ppf = function
>           It has no method %s@]" type_expr ty me
>    | Undefined_inherited_method me ->
>        fprintf ppf "This expression has no method %s" me
> -  | Unbound_class cl ->
> +  | Unbound_class (cl,[]) ->
>        fprintf ppf "Unbound class %a" longident cl
> +  | Unbound_class (cl,corr::_) ->
> +      fprintf ppf "Unbound class %a, possible misspelling of %s"  
> longident cl corr
>    | Virtual_class cl ->
>        fprintf ppf "One cannot create instances of the virtual  
> class %a"
>          longident cl
> -  | Unbound_instance_variable v ->
> +  | Unbound_instance_variable (v,[]) ->
>        fprintf ppf "Unbound instance variable %s" v
> +  | Unbound_instance_variable (v,corr::_) ->
> +      fprintf ppf "Unbound instance variable %s, possible  
> misspelling of %s" v corr
>    | Instance_variable_not_mutable v ->
>        fprintf ppf "The instance variable %s is not mutable" v
>    | Not_subtype(tr1, tr2) ->
> diff --git a/typing/typecore.mli b/typing/typecore.mli
> index 24aea7d..171e96e 100644
> --- a/typing/typecore.mli
> +++ b/typing/typecore.mli
> @@ -61,9 +61,9 @@ val force_delayed_checks: unit -> unit
>  val self_coercion : (Path.t * Location.t list ref) list ref
>
>  type error =
> -    Unbound_value of Longident.t
> -  | Unbound_constructor of Longident.t
> -  | Unbound_label of Longident.t
> +    Unbound_value of Longident.t * string list
> +  | Unbound_constructor of Longident.t * string list
> +  | Unbound_label of Longident.t * string list
>    | Polymorphic_label of Longident.t
>    | Constructor_arity_mismatch of Longident.t * int * int
>    | Label_mismatch of Longident.t * (type_expr * type_expr) list
> @@ -80,11 +80,11 @@ type error =
>    | Bad_conversion of string * int * char
>    | Undefined_method of type_expr * string
>    | Undefined_inherited_method of string
> -  | Unbound_class of Longident.t
> +  | Unbound_class of Longident.t * string list
>    | Virtual_class of Longident.t
>    | Private_type of type_expr
>    | Private_label of Longident.t * type_expr
> -  | Unbound_instance_variable of string
> +  | Unbound_instance_variable of string * string list
>    | Instance_variable_not_mutable of string
>    | Not_subtype of (type_expr * type_expr) list * (type_expr *  
> type_expr) list
>    | Outside_class
> _______________________________________________
> Caml-list mailing list. Subscription management:
> http://yquem.inria.fr/cgi-bin/mailman/listinfo/caml-list
> Archives: http://caml.inria.fr
> Beginner's list: http://groups.yahoo.com/group/ocaml_beginners
> Bug reports: http://caml.inria.fr/bin/caml-bugs

--------------------------------------------------
Yitzhak Mandelbaum
AT&T Labs - Research

http://www.research.att.com/~yitzhak



--Apple-Mail-50-647648282
Content-Transfer-Encoding: quoted-printable
Content-Type: text/html;
	charset=ISO-8859-1

<HTML><BODY style=3D"word-wrap: break-word; -khtml-nbsp-mode: space; =
-khtml-line-break: after-white-space; ">Very cool! Do you think there's =
any way you could separate it from the compiler, like Learner et al.'s =
SEMINAL work, which separates type error messages from the compiler?. =
Separation could help ensure this (and any other, similar) ideas don't =
accidentally introduce bugs into the compiler, and make it much easier =
for you to maintain. A very simple hack might be tod wrap ocamlc in a =
script that parses such error messages and then tokenizes the source =
file, looking for similar strings?<DIV><BR =
class=3D"khtml-block-placeholder"></DIV><DIV>Cheers,</DIV><DIV>Yitzhak<DIV=
><BR class=3D"khtml-block-placeholder"></DIV><DIV><BR><DIV><DIV>On Oct =
29, 2007, at 5:11 PM, Edgar Friendly wrote:</DIV><BR =
class=3D"Apple-interchange-newline"><BLOCKQUOTE type=3D"cite"><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">One random little feature of GNAT that comes in =
handy for me is its</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; ">habit of, when I misspell =
an identifier, giving me a possible correction</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">in its compile error message.<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>Spending some time with the =
3.10.0</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">sources, I have created a =
"second draft" patch creating this</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">functionality =
in my favored language.</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; min-height: =
14px; "><BR></DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">Example:</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">=3D=3D=3D=3D=3D=3D=3D=3D</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; min-height: 14px; "><BR></DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "># =
/home/thelema/Projects/ocaml-custom/bin/ocamlc -o coml -I =
+lablgtk2</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">lablgtk.cma gtkInit.cmo =
coml.ml</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">File "coml.ml", line 61, =
characters 16-25:</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">Unbound value is_arcive, =
possible misspelling of is_archive</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; min-height: =
14px; "><BR></DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">Impacts:</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">=3D=3D=3D=3D=3D=3D=3D=3D</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; min-height: 14px; "><BR></DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; =
">Efficiency in the case of finding a mistake should be quite =
good,</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">although this shouldn't matter =
too much since the compiler quits pretty</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">early in =
compilation when it finds an unbound identifier.</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; min-height: 14px; "><BR></DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">In the =
case of no unbound identifiers, the cost is an extra try/with</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">block around the standard lookup.<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>I haven't made any =
benchmarks, though.</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; min-height: 14px; =
"><BR></DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">I expect this code to have =
little long term maintenance issues - the</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">major =
source of code changes was adding a "* string list" to a number =
of</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: =
0px; margin-left: 0px; ">exceptions to carry the list of possible =
correct spellings to the point</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">they get =
output by the compiler.<SPAN class=3D"Apple-converted-space">=A0 =
</SPAN>These exceptions are still usable as</DIV><DIV style=3D"margin-top:=
 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">before =
with an empty list in this spot.</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; min-height: =
14px; "><BR></DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">It's possible the code has =
created opportunities for uncaught exceptions</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">in the compiler as I only checked for instances of =
"Not_found" in a few</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; ">files -- those which dealt =
with the Unbound_* exceptions.<SPAN class=3D"Apple-converted-space">=A0 =
</SPAN>Someone who</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; ">knows the internals better =
might find places the "Found_nearly"</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">exception =
that carries possible corrections might escape into.</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; min-height: 14px; "><BR></DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; =
min-height: 14px; "><BR></DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">Dedicated =
to:</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">Yaron Minsky and the team at =
Jane Street</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; min-height: 14px; "><BR></DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">E.</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; ">diff --git =
a/typing/ident.ml b/typing/ident.ml</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">index =
a30aa7a..8bbb395 100644</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">--- =
a/typing/ident.ml</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+++ b/typing/ident.ml</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">@@ -56,6 +56,61 @@ let same i1 i2 =3D i1 =3D =
i2</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: =
0px; margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0 =A0 =A0=
 =A0 </SPAN>then i1.stamp =3D i2.stamp</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 =A0 </SPAN>else i2.stamp =3D =
0 &amp;&amp; i1.name =3D i2.name *)</DIV><P style=3D"margin: 0.0px 0.0px =
0.0px 0.0px; min-height: 14.0px"><SPAN =
class=3D"Apple-converted-space">=A0</SPAN><BR =
class=3D"khtml-block-placeholder"></P><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+(* does =
various heuristics to find spelling mistakes - algorithm from GNAT Ada =
compiler - Lots of code, but hopefully about as efficient as possible =
*)</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: =
0px; margin-left: 0px; ">+let nearly_equal s i =3D</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =
</SPAN>let is_digit c =3D c &gt;=3D '0' &amp;&amp; c &lt;=3D '9' =
in</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: =
0px; margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =
</SPAN>let rec tails_equal s1 i1 s2 i2 =3D i1 &gt;=3D String.length s1 =
|| (s1.[i1] =3D s2.[i2] &amp;&amp; tails_equal s1 (i1+1) s2 (i2+1)) =
in</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: =
0px; margin-left: 0px; ">+ <SPAN =
class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>let n1 =3D s and n2 =3D =
i.name in</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>let l1 =3D String.length n1 =
and l2 =3D String.length n2 in</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>if l1 =3D 0 then l2 =3D 0 (* =
both null -&gt; equal *)</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>else if l2 =3D 0 then false =
(* one of n1 or n2 null -&gt; not equal *)</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>else if n1.[0] !=3D n2.[0] =
then false (* first characters don't match -&gt; not *)</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =
</SPAN>else if l1 &lt; 3 &amp;&amp; l2 &lt; 3 then false (* short =
strings are all different *)</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>else if l1 =3D l2 =
then</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 </SPAN>(* look for single =
errors, transpositions *)</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 </SPAN>let rec find_diff c =
=3D<SPAN class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =A0 =A0 =
</SPAN>if c &lt; (l1 - 1) then<SPAN =
class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-tab-span" style=3D"white-space:pre">	</SPAN>if n1.[c] =
!=3D n2.[c] then<SPAN class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV=
 style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>(* mismatched digits -&gt; =
not equal *)</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>if is_digit n1.[c] &amp;&amp; =
is_digit n2.[c] then false</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-tab-span" style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 =A0 </SPAN>(* single error -&gt; =
equal *)</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>else if n1.[c+1] =3D n2.[c+1] =
&amp;&amp; tails_equal n1 (c+2) n2 (c+2)</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-tab-span" style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>then true</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 =A0 </SPAN>(* transposition -&gt; =
equal *)</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>else if n1.[c] =3D n2.[c+1] =
&amp;&amp; n1.[c+1] =3D n2.[c] &amp;&amp;</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-tab-span" style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>tails_equal n1 (c+2) n2 =
(c+2)</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>then true</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>else false</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN>else find_diff (c+1)</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =A0 =A0 =
</SPAN>else (* at the end of the strings *)</DIV><DIV style=3D"margin-top:=
 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-tab-span" style=3D"white-space:pre">	</SPAN>if =
is_digit n1.[c] &amp;&amp; is_digit n2.[c]<SPAN =
class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-tab-span" style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>&amp;&amp; n1.[c] !=3D =
n2.[c]<SPAN class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN>then false</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN>else true</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =A0 =
</SPAN>in</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 </SPAN>find_diff 1</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =
</SPAN>else if l1 =3D l2 - 1 then (* short by one *)</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =A0 =
</SPAN>let rec find_del c =3D<SPAN =
class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 </SPAN>if c &lt; l1 =
then</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN>if n1.[c] !=3D n2.[c] then<SPAN =
class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-tab-span" style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>tails_equal n1 c n2 =
(c+1)</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN>else find_del (c+1)</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =A0 =A0 =
</SPAN>else true (* last character was deleted *)</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =A0 =
</SPAN>in</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 </SPAN>find_del 1</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =
</SPAN>else if l1 =3D l2 + 1 then (* too long by one *)</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =A0 =
</SPAN>let rec find_add c =3D</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 </SPAN>if c &lt; l2 =
then</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN>if n1.[c] !=3D n2.[c] then<SPAN =
class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-tab-span" style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>tails_equal n1 (c+1) n2 =
c</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: =
0px; margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN>else find_add (c+1)</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =A0 =A0 =
</SPAN>else true (* last character added *)</DIV><DIV style=3D"margin-top:=
 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 </SPAN>in</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =A0 =
</SPAN>find_add 1</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>else (* lengths totally =
different *)</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 </SPAN>false</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN></DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0</SPAN>let binding_time i =3D =
i.stamp</DIV><P style=3D"margin: 0.0px 0.0px 0.0px 0.0px; min-height: =
14.0px"><SPAN class=3D"Apple-converted-space">=A0</SPAN><BR =
class=3D"khtml-block-placeholder"></P><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0</SPAN>let current_time() =3D =
!currentstamp</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">@@ -97,6 +152,8 @@ and 'a data =
=3D</DIV><P style=3D"margin: 0.0px 0.0px 0.0px 0.0px; min-height: =
14.0px"><SPAN class=3D"Apple-converted-space">=A0</SPAN><BR =
class=3D"khtml-block-placeholder"></P><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0</SPAN>let empty =3D Empty</DIV><P =
style=3D"margin: 0.0px 0.0px 0.0px 0.0px; min-height: 14.0px"><SPAN =
class=3D"Apple-converted-space">=A0</SPAN><BR =
class=3D"khtml-block-placeholder"></P><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+exception =
Found_nearly of string list</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0</SPAN>(* =
Inline expansion of height for better speed</DIV><DIV style=3D"margin-top:=
 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>* let height =3D =
function</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>* <SPAN =
class=3D"Apple-converted-space">=A0 =A0 </SPAN>Empty -&gt; 0</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">@@ -182,3 +239,34 @@ let rec keys_aux stack accu =3D =
function</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 </SPAN>keys_aux (l :: =
stack) (k.ident :: accu) r</DIV><P style=3D"margin: 0.0px 0.0px 0.0px =
0.0px; min-height: 14.0px"><SPAN =
class=3D"Apple-converted-space">=A0</SPAN><BR =
class=3D"khtml-block-placeholder"></P><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0</SPAN>let keys tbl =3D keys_aux [] =
[] tbl</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+let =
find_nearly_equal n tbl =3D</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+(*<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>List.filter (nearly_equal =
name) (keys tbl) -- optimized for your enjoyment*)</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =
</SPAN>let rec find_nearly_equal_aux stack accu =3D function</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =A0 =A0 =
</SPAN>Empty -&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-tab-span" style=3D"white-space:pre">	</SPAN>begin =
match stack with</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 =A0 =A0 =A0 </SPAN>[] -&gt; =
accu</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| a :: l -&gt; =
find_nearly_equal_aux l accu a</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-tab-span" style=3D"white-space:pre">	=
</SPAN>end</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 </SPAN>| Node(l, k, r, _) =
-&gt;<SPAN class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN>let accu' =3D<SPAN =
class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-tab-span" style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>if nearly_equal n =
k.ident<SPAN class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>then k.ident.name :: =
accu</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>else accu<SPAN =
class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-tab-span" style=3D"white-space:pre">	=
</SPAN>in</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN>find_nearly_equal_aux (l :: =
stack) accu' r</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>in</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =
</SPAN>find_nearly_equal_aux [] [] tbl</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; =
">+</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+let find_name_with_nearly name =
tbl =3D<SPAN class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =
</SPAN>try find_name name tbl</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>with Not_found -&gt;<SPAN =
class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+(*<SPAN =
class=3D"Apple-converted-space">=A0 =A0 </SPAN>prerr_string "FNE: "; =
prerr_endline name; *)</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 </SPAN>let nearlies =3D =
find_nearly_equal name tbl in</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+(*<SPAN =
class=3D"Apple-converted-space">=A0 =A0 </SPAN>let rec pr_list to_str =3D =
function [] -&gt; prerr_endline "Empty" | [a] -&gt; prerr_endline =
(to_str a) | h :: t -&gt; prerr_string (to_str h); prerr_string ", "; =
pr_list to_str t</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 </SPAN>in</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =A0 =
</SPAN>prerr_string "nearlies: ";</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 </SPAN>pr_list (fun i -&gt; i) =
nearlies;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 </SPAN>prerr_string "whole =
table: ";</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 </SPAN>pr_list (fun i -&gt; =
i.name) (keys tbl); *)</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 </SPAN>raise (Found_nearly =
nearlies)</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">diff --git a/typing/ident.mli =
b/typing/ident.mli</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; ">index 9f7372c..7ab9327 =
100644</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">--- a/typing/ident.mli</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+++ b/typing/ident.mli</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">@@ -52,8 =
+52,12 @@ val print: Format.formatter -&gt; t -&gt; unit</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0</SPAN>type =
'a tbl</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 </SPAN>(* Association =
tables from identifiers to type 'a. *)</DIV><P style=3D"margin: 0.0px =
0.0px 0.0px 0.0px; min-height: 14.0px"><SPAN =
class=3D"Apple-converted-space">=A0</SPAN><BR =
class=3D"khtml-block-placeholder"></P><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+exception =
Found_nearly of string list</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0</SPAN>val =
empty: 'a tbl</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0</SPAN>val add: t -&gt; 'a -&gt; 'a =
tbl -&gt; 'a tbl</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0</SPAN>val find_same: t -&gt; 'a tbl =
-&gt; 'a</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0</SPAN>val find_name: string -&gt; 'a =
tbl -&gt; 'a</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0</SPAN>val keys: 'a tbl -&gt; t =
list</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+val =
find_name_with_nearly: string -&gt; 'a tbl -&gt; 'a</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">diff --git a/typing/typecore.ml =
b/typing/typecore.ml</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; ">index 691eb49..adff3ad =
100644</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">--- =
a/typing/typecore.ml</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; ">+++ =
b/typing/typecore.ml</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; ">@@ -23,9 +23,9 @@ open =
Btype</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0</SPAN>open Ctype</DIV><P =
style=3D"margin: 0.0px 0.0px 0.0px 0.0px; min-height: 14.0px"><SPAN =
class=3D"Apple-converted-space">=A0</SPAN><BR =
class=3D"khtml-block-placeholder"></P><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0</SPAN>type error =3D</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">-<SPAN class=3D"Apple-converted-space">=A0 =A0 =
</SPAN>Unbound_value of Longident.t</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_constructor of =
Longident.t</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_label of =
Longident.t</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 </SPAN>Unbound_value of =
Longident.t * string list</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_constructor of =
Longident.t * string list</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_label of =
Longident.t * string list</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| Polymorphic_label of =
Longident.t</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| =
Constructor_arity_mismatch of Longident.t * int * int</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =
</SPAN>| Label_mismatch of Longident.t * (type_expr * type_expr) =
list</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">@@ -42,11 +42,11 @@ type error =
=3D</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| Bad_conversion of string =
* int * char</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| Undefined_method of =
type_expr * string</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| =
Undefined_inherited_method of string</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_class of =
Longident.t</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_class of =
Longident.t * string list</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| Virtual_class of =
Longident.t</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| Private_type of =
type_expr</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| Private_label of =
Longident.t * type_expr</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_instance_variable =
of string</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_instance_variable =
of string * string list</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| =
Instance_variable_not_mutable of string</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| Not_subtype of =
(type_expr * type_expr) list * (type_expr * type_expr) list</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =
</SPAN>| Outside_class</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; ">@@ -276,7 +276,7 @@ let rec =
build_as_type env p =3D</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 </SPAN>unify_pat env {p2 =
with pat_type =3D ty2} ty1;</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 </SPAN>begin match path =
with None -&gt; ()</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 </SPAN>| Some path =
-&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 =A0 =A0 </SPAN>let td =3D =
try Env.find_type path env with Not_found -&gt; assert false =
in</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: =
0px; margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =A0 =
=A0 =A0 =A0 </SPAN>let td =3D try Env.find_type path env with Not_found =
| Ident.Found_nearly _ -&gt; assert false in</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
=A0 =A0 </SPAN>let params =3D List.map (fun _ -&gt; newvar()) =
td.type_params in</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 =A0 </SPAN>match =
expand_head env (newty (Tconstr (path, params, ref Mnil)))</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
=A0 =A0 </SPAN>with {desc=3DTvariant row} when static_row row =
-&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">@@ -291,7 +291,9 @@ let =
build_or_pat env loc lid =3D</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>let path, decl =3D</DIV><DIV=
 style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =
</SPAN>try Env.lookup_type lid env</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 </SPAN>with Not_found =
-&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 =
</SPAN>raise(Typetexp.Error(loc, Typetexp.Unbound_type_constructor =
lid))</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 =
</SPAN>raise(Typetexp.Error(loc, Typetexp.Unbound_type_constructor =
(lid,[])))</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 </SPAN>| Ident.Found_nearly =
l -&gt;<SPAN class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =A0 =A0 =
</SPAN>raise(Typetexp.Error(loc, Typetexp.Unbound_type_constructor =
(lid,l)))</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>in</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =
</SPAN>let tyl =3D List.map (fun _ -&gt; newvar()) decl.type_params =
in</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: =
0px; margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =
</SPAN>let fields =3D</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; ">@@ -400,7 +402,10 @@ let =
rec type_pat env sp =3D</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 </SPAN>try</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
=A0 =A0 </SPAN>Env.lookup_constructor lid env</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
=A0 </SPAN>with Not_found -&gt;</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 =A0 =A0 =
</SPAN>raise(Error(sp.ppat_loc, Unbound_constructor lid)) in</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =A0 =A0 =A0=
 =A0 </SPAN>raise(Error(sp.ppat_loc, Unbound_constructor (lid,[])))<SPAN =
class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-tab-span" style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Ident.Found_nearly l =
-&gt;<SPAN class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>raise(Error(sp.ppat_loc, =
Unbound_constructor (lid,l)))</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 </SPAN>in</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
</SPAN>let sargs =3D</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 </SPAN>match sarg =
with</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 =A0 </SPAN>None -&gt; =
[]</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: =
0px; margin-left: 0px; ">@@ -449,7 +454,10 @@ let rec type_pat env sp =
=3D</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 =A0 =
</SPAN>try</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 =A0 =A0 =
</SPAN>Env.lookup_label lid env</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 =A0 </SPAN>with =
Not_found -&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 =A0 =A0 =A0 =
</SPAN>raise(Error(sp.ppat_loc, Unbound_label lid)) in</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =A0 =A0 =A0=
 =A0 =A0 </SPAN>raise(Error(sp.ppat_loc, Unbound_label (lid,[])))<SPAN =
class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-tab-span" style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 =A0 </SPAN>| Ident.Found_nearly l =
-&gt;<SPAN class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 =A0 </SPAN>raise(Error(sp.ppat_loc, =
Unbound_label (lid,l)))</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-tab-span" style=3D"white-space:pre">	=
</SPAN>in</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 </SPAN>begin_def =
();</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 </SPAN>let (vars, =
ty_arg, ty_res) =3D instance_label false label in</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
=A0 </SPAN>if vars =3D [] then end_def ();</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">@@ =
-806,7 +814,7 @@ let rec approx_type env sty =3D</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
=A0 </SPAN>if List.length ctl &lt;&gt; decl.type_arity then raise =
Not_found;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 </SPAN>let tyl =3D =
List.map (approx_type env) ctl in</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 </SPAN>newconstr path =
tyl</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 </SPAN>with Not_found -&gt; =
newvar ()</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 </SPAN>with Not_found | =
Ident.Found_nearly _ -&gt; newvar ()</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 </SPAN>end</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =
</SPAN>| _ -&gt; newvar ()</DIV><P style=3D"margin: 0.0px 0.0px 0.0px =
0.0px; min-height: 14.0px"><SPAN =
class=3D"Apple-converted-space">=A0</SPAN><BR =
class=3D"khtml-block-placeholder"></P><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">@@ -923,7 =
+931,9 @@ let rec type_exp env sexp =3D</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 =A0 </SPAN>exp_type =3D=
 instance desc.val_type;</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 =A0 </SPAN>exp_env =3D =
env }</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 </SPAN>with Not_found =
-&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 =A0 =
</SPAN>raise(Error(sexp.pexp_loc, Unbound_value lid))</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =A0 =A0 =A0=
 </SPAN>raise(Error(sexp.pexp_loc, Unbound_value (lid,[])))</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN>| Ident.Found_nearly l -&gt;<SPAN =
class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-tab-span" style=3D"white-space:pre">	=
</SPAN>raise(Error(sexp.pexp_loc, Unbound_value (lid,l)))</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
</SPAN>end</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| Pexp_constant cst =
-&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 </SPAN>re {</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">@@ -1021,7 +1031,10 @@ let rec type_exp env sexp =
=3D</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 =A0 =
</SPAN>try</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 =A0 =A0 =
</SPAN>Env.lookup_label lid env</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 =A0 </SPAN>with =
Not_found -&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 =A0 =A0 =A0 =
</SPAN>raise(Error(sexp.pexp_loc, Unbound_label lid)) in</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =A0 =A0 =A0=
 =A0 =A0 </SPAN>raise(Error(sexp.pexp_loc, Unbound_label (lid,[])))<SPAN =
class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-tab-span" style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 =A0 </SPAN>| Ident.Found_nearly l =
-&gt;<SPAN class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 =A0 =
</SPAN>raise(Error(sexp.pexp_loc, Unbound_label (lid,l)))</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN>in</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 </SPAN>begin_def =
();</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 </SPAN>if =
!Clflags.principal then begin_def ();</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 </SPAN>let (vars, =
ty_arg, ty_res) =3D instance_label true label in</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">@@ -1098,7 +1111,10 @@ let rec type_exp env sexp =
=3D</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 </SPAN>try</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
=A0 =A0 </SPAN>Env.lookup_label lid env</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 </SPAN>with Not_found =
-&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 =A0 =A0 =
</SPAN>raise(Error(sexp.pexp_loc, Unbound_label lid)) in</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =A0 =A0 =A0=
 =A0 </SPAN>raise(Error(sexp.pexp_loc, Unbound_label (lid,[])))<SPAN =
class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-tab-span" style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Ident.Found_nearly l =
-&gt;<SPAN class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>raise(Error(sexp.pexp_loc, =
Unbound_label (lid,l)))</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 </SPAN>in</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
</SPAN>let (_, ty_arg, ty_res) =3D instance_label false label =
in</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: =
0px; margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =
=A0 </SPAN>unify_exp env arg ty_res;</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 </SPAN>re {</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">@@ -1112,7 +1128,10 @@ let rec type_exp env sexp =
=3D</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 </SPAN>try</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
=A0 =A0 </SPAN>Env.lookup_label lid env</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 </SPAN>with Not_found =
-&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 =A0 =A0 =
</SPAN>raise(Error(sexp.pexp_loc, Unbound_label lid)) in</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =A0 =A0 =A0=
 =A0 </SPAN>raise(Error(sexp.pexp_loc, Unbound_label (lid,[])))<SPAN =
class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-tab-span" style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Ident.Found_nearly l =
-&gt;<SPAN class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>raise(Error(sexp.pexp_loc, =
Unbound_label (lid,l)))</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 </SPAN>in</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
</SPAN>if label.lbl_mut =3D Immutable then</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 =
</SPAN>raise(Error(sexp.pexp_loc, Label_not_mutable lid));</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
</SPAN>begin_def ();</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; ">@@ -1332,7 +1351,9 @@ let =
rec type_exp env sexp =3D</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| Pexp_new cl =
-&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 </SPAN>let (cl_path, =
cl_decl) =3D</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 </SPAN>try =
Env.lookup_class cl env with Not_found -&gt;</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">-<SPAN class=3D"Apple-converted-space">=A0 =A0 =A0 =A0=
 =A0 </SPAN>raise(Error(sexp.pexp_loc, Unbound_class cl))</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =A0 =A0 =A0=
 =A0 </SPAN>raise(Error(sexp.pexp_loc, Unbound_class (cl,[])))</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Ident.Found_nearly l =
-&gt;<SPAN class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>raise(Error(sexp.pexp_loc, =
Unbound_class (cl,l)))</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 </SPAN>in</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
=A0 </SPAN>begin match cl_decl.cty_new with</DIV><DIV style=3D"margin-top:=
 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 =A0 </SPAN>None =
-&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">@@ -1361,10 +1382,13 @@ let rec =
type_exp env sexp =3D</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 </SPAN>| Val_ivar _ =
-&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 =A0 =A0 =
</SPAN>raise(Error(sexp.pexp_loc, Instance_variable_not_mutable =
lab))</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 </SPAN>| _ =
-&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 =A0 =A0 =A0 =
</SPAN>raise(Error(sexp.pexp_loc, Unbound_instance_variable =
lab))</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 =A0 =A0 =A0 =
</SPAN>raise(Error(sexp.pexp_loc, Unbound_instance_variable =
(lab,[])))</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 </SPAN>with</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
=A0 </SPAN>Not_found -&gt;</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 =A0 =A0 =
</SPAN>raise(Error(sexp.pexp_loc, Unbound_instance_variable =
lab))</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 =A0 =A0 =
</SPAN>raise(Error(sexp.pexp_loc, Unbound_instance_variable =
(lab,[])))</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN>| Ident.Found_nearly l -&gt;<SPAN =
class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-tab-span" style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>raise(Error(sexp.pexp_loc, =
Unbound_instance_variable (lab,l)))</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
</SPAN>end</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| Pexp_override lst =
-&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 </SPAN>let _ =3D</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">@@ -1380,7 +1404,7 @@ let rec type_exp env sexp =
=3D</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 </SPAN>try</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
=A0 =A0 </SPAN>Env.lookup_value (Longident.Lident "selfpat-*") =
env,</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 =A0 =
</SPAN>Env.lookup_value (Longident.Lident "self-*") env</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">-<SPAN class=3D"Apple-converted-space">=A0 =A0 =A0 =A0=
 </SPAN>with Not_found -&gt;</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 =A0 </SPAN>with Not_found | =
Ident.Found_nearly _ -&gt;</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 =A0 =
</SPAN>raise(Error(sexp.pexp_loc, Outside_class))</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
</SPAN>with</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 </SPAN>(_, {val_type =
=3D self_ty; val_kind =3D Val_self (_, vars, _, _)}),</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">@@ -1391,7 +1415,9 @@ let rec type_exp env sexp =
=3D</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 =A0 =A0 =A0 =
</SPAN>(Path.Pident id, type_expect env snewval (instance ty))</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
=A0 =A0 =A0 </SPAN>with</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 =A0 =A0 =A0 =
</SPAN>Not_found -&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =
</SPAN>raise(Error(sexp.pexp_loc, Unbound_instance_variable =
lab))</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =
</SPAN>raise(Error(sexp.pexp_loc, Unbound_instance_variable =
(lab,[])))</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN><SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 </SPAN>| Ident.Found_nearly =
l -&gt;<SPAN class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN><SPAN class=3D"Apple-tab-span" =
style=3D"white-space:pre">	</SPAN>raise(Error(sexp.pexp_loc, =
Unbound_instance_variable (lab,l)))</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 =A0 =A0 =
</SPAN>end</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 =A0 =
</SPAN>in</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 =A0 </SPAN>let modifs =
=3D List.map type_override lst in</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">@@ -1637,7 =
+1663,7 @@ and type_application env funct sargs =3D</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
=A0 =A0 =A0 =A0 =A0 =A0 </SPAN>may_warn sarg0.pexp_loc</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
=A0 =A0 =A0 =A0 =A0 =A0 =A0 </SPAN>(Warnings.Not_principal "commuting =
this argument");</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =
</SPAN>(l', sarg0, sargs1 @ sargs2, more_sargs)</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">-<SPAN class=3D"Apple-converted-space">=A0 =A0 =A0 =A0=
 =A0 =A0 =A0 </SPAN>with Not_found -&gt;</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 =A0 =A0 =A0 =A0 </SPAN>with =
Not_found | Ident.Found_nearly _ -&gt;</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =
</SPAN>let (l', sarg0, sargs1, sargs2) =3D</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =
</SPAN>extract_label name more_sargs in</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =
</SPAN>if sargs1 &lt;&gt; [] || sargs &lt;&gt; [] then</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">@@ -1707,7 +1733,9 @@ and type_construct env loc lid =
sarg explicit_arity ty_expected =3D</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 </SPAN>try</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
</SPAN>Env.lookup_constructor lid env</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 </SPAN>with Not_found =
-&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 </SPAN>raise(Error(loc, =
Unbound_constructor lid)) in</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 </SPAN>raise(Error(loc, =
Unbound_constructor (lid,[])))</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 </SPAN>| Ident.Found_nearly =
l -&gt;<SPAN class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 =A0 =A0 =
</SPAN>raise(Error(loc, Unbound_constructor (lid,l))) in</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =
</SPAN>let sargs =3D</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 </SPAN>match sarg =
with</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 </SPAN>None -&gt; =
[]</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: =
0px; margin-left: 0px; ">@@ -2020,12 +2048,18 @@ open Format</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0</SPAN>open =
Printtyp</DIV><P style=3D"margin: 0.0px 0.0px 0.0px 0.0px; min-height: =
14.0px"><SPAN class=3D"Apple-converted-space">=A0</SPAN><BR =
class=3D"khtml-block-placeholder"></P><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0</SPAN>let report_error ppf =3D =
function</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_value lid =
-&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 </SPAN>fprintf ppf "Unbound =
value %a" longident lid</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_constructor lid =
-&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_value (lid,[]) =
-&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 </SPAN>fprintf ppf "Unbound =
value %a" longident lid<SPAN =
class=3D"Apple-converted-space">=A0</SPAN></DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_value (lid,corr::_) =
-&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 </SPAN>fprintf ppf "Unbound =
value %a, possible misspelling of %s" longident lid corr</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 </SPAN>| =
Unbound_constructor (lid,[]) -&gt;</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 </SPAN>fprintf ppf =
"Unbound constructor %a" longident lid</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_label lid =
-&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_constructor =
(lid,corr::_) -&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 </SPAN>fprintf ppf "Unbound =
constructor %a, possible misspelling of %s" longident lid corr</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 </SPAN>| =
Unbound_label (lid,[]) -&gt;</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 </SPAN>fprintf ppf =
"Unbound record field label %a" longident lid</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">+<SPAN class=3D"Apple-converted-space">=A0 </SPAN>| =
Unbound_label (lid,corr::_) -&gt;</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 </SPAN>fprintf ppf "Unbound =
record field label %a, possible misspelling of %s" longident lid =
corr</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| Polymorphic_label lid =
-&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 </SPAN>fprintf ppf "@[The =
record field label %a is polymorphic.@ %s@]"</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
=A0 </SPAN>longident lid "You cannot instantiate it in a =
pattern."</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">@@ -2100,13 +2134,17 @@ let =
report_error ppf =3D function</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 =A0 =A0 </SPAN>It has no =
method %s@]" type_expr ty me</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| =
Undefined_inherited_method me -&gt;</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 </SPAN>fprintf ppf "This =
expression has no method %s" me</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_class cl =
-&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_class (cl,[]) =
-&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 </SPAN>fprintf ppf =
"Unbound class %a" longident cl</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_class (cl,corr::_) =
-&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 </SPAN>fprintf ppf "Unbound =
class %a, possible misspelling of %s" longident cl corr</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =
</SPAN>| Virtual_class cl -&gt;</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 </SPAN>fprintf ppf "One =
cannot create instances of the virtual class %a"</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
=A0 </SPAN>longident cl</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_instance_variable v =
-&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_instance_variable =
(v,[]) -&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 =A0 =A0 </SPAN>fprintf ppf =
"Unbound instance variable %s" v</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_instance_variable =
(v,corr::_) -&gt;</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 =A0 </SPAN>fprintf ppf "Unbound =
instance variable %s, possible misspelling of %s" v corr</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =
</SPAN>| Instance_variable_not_mutable v -&gt;</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =A0 =A0 =
</SPAN>fprintf ppf "The instance variable %s is not mutable" v</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =
</SPAN>| Not_subtype(tr1, tr2) -&gt;</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">diff --git =
a/typing/typecore.mli b/typing/typecore.mli</DIV><DIV style=3D"margin-top:=
 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">index =
24aea7d..171e96e 100644</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">--- =
a/typing/typecore.mli</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; ">+++ =
b/typing/typecore.mli</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; ">@@ -61,9 +61,9 @@ val =
force_delayed_checks: unit -&gt; unit</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0</SPAN>val self_coercion : (Path.t * =
Location.t list ref) list ref</DIV><P style=3D"margin: 0.0px 0.0px 0.0px =
0.0px; min-height: 14.0px"><SPAN =
class=3D"Apple-converted-space">=A0</SPAN><BR =
class=3D"khtml-block-placeholder"></P><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0</SPAN>type error =3D</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">-<SPAN class=3D"Apple-converted-space">=A0 =A0 =
</SPAN>Unbound_value of Longident.t</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_constructor of =
Longident.t</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_label of =
Longident.t</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 =A0 </SPAN>Unbound_value of =
Longident.t * string list</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_constructor of =
Longident.t * string list</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_label of =
Longident.t * string list</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| Polymorphic_label of =
Longident.t</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| =
Constructor_arity_mismatch of Longident.t * int * int</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =
</SPAN>| Label_mismatch of Longident.t * (type_expr * type_expr) =
list</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">@@ -80,11 +80,11 @@ type error =
=3D</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| Bad_conversion of string =
* int * char</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| Undefined_method of =
type_expr * string</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| =
Undefined_inherited_method of string</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_class of =
Longident.t</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_class of =
Longident.t * string list</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| Virtual_class of =
Longident.t</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| Private_type of =
type_expr</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| Private_label of =
Longident.t * type_expr</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">-<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_instance_variable =
of string</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; ">+<SPAN =
class=3D"Apple-converted-space">=A0 </SPAN>| Unbound_instance_variable =
of string * string list</DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| =
Instance_variable_not_mutable of string</DIV><DIV style=3D"margin-top: =
0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><SPAN =
class=3D"Apple-converted-space">=A0=A0 </SPAN>| Not_subtype of =
(type_expr * type_expr) list * (type_expr * type_expr) list</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; "><SPAN class=3D"Apple-converted-space">=A0=A0 =
</SPAN>| Outside_class</DIV><DIV style=3D"margin-top: 0px; margin-right: =
0px; margin-bottom: 0px; margin-left: 0px; =
">_______________________________________________</DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">Caml-list mailing list. Subscription =
management:</DIV><DIV style=3D"margin-top: 0px; margin-right: 0px; =
margin-bottom: 0px; margin-left: 0px; "><A =
href=3D"http://yquem.inria.fr/cgi-bin/mailman/listinfo/caml-list">http://y=
quem.inria.fr/cgi-bin/mailman/listinfo/caml-list</A></DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">Archives: <A =
href=3D"http://caml.inria.fr">http://caml.inria.fr</A></DIV><DIV =
style=3D"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; =
margin-left: 0px; ">Beginner's list: <A =
href=3D"http://groups.yahoo.com/group/ocaml_beginners">http://groups.yahoo=
.com/group/ocaml_beginners</A></DIV><DIV style=3D"margin-top: 0px; =
margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">Bug reports: =
<A =
href=3D"http://caml.inria.fr/bin/caml-bugs">http://caml.inria.fr/bin/caml-=
bugs</A></DIV> </BLOCKQUOTE></DIV><BR><DIV> <SPAN =
class=3D"Apple-style-span" style=3D"border-collapse: separate; =
border-spacing: 0px 0px; color: rgb(0, 0, 0); font-family: Helvetica; =
font-size: 12px; font-style: normal; font-variant: normal; font-weight: =
normal; letter-spacing: normal; line-height: normal; text-align: auto; =
-khtml-text-decorations-in-effect: none; text-indent: 0px; =
-apple-text-size-adjust: auto; text-transform: none; orphans: 2; =
white-space: normal; widows: 2; word-spacing: 0px; "><SPAN =
class=3D"Apple-style-span" style=3D"border-collapse: separate; =
border-spacing: 0px 0px; color: rgb(0, 0, 0); font-family: Helvetica; =
font-size: 12px; font-style: normal; font-variant: normal; font-weight: =
normal; letter-spacing: normal; line-height: normal; text-align: auto; =
-khtml-text-decorations-in-effect: none; text-indent: 0px; =
-apple-text-size-adjust: auto; text-transform: none; orphans: 2; =
white-space: normal; widows: 2; word-spacing: 0px; "><SPAN =
class=3D"Apple-style-span" style=3D"border-collapse: separate; =
border-spacing: 0px 0px; color: rgb(0, 0, 0); font-family: Helvetica; =
font-size: 12px; font-style: normal; font-variant: normal; font-weight: =
normal; letter-spacing: normal; line-height: normal; text-align: auto; =
-khtml-text-decorations-in-effect: none; text-indent: 0px; =
-apple-text-size-adjust: auto; text-transform: none; orphans: 2; =
white-space: normal; widows: 2; word-spacing: 0px; "><SPAN =
class=3D"Apple-style-span" style=3D"border-collapse: separate; =
border-spacing: 0px 0px; color: rgb(0, 0, 0); font-family: Helvetica; =
font-size: 12px; font-style: normal; font-variant: normal; font-weight: =
normal; letter-spacing: normal; line-height: normal; text-align: auto; =
-khtml-text-decorations-in-effect: none; text-indent: 0px; =
-apple-text-size-adjust: auto; text-transform: none; orphans: 2; =
white-space: normal; widows: 2; word-spacing: 0px; =
"><DIV>--------------------------------------------------</DIV><DIV>Yitzha=
k Mandelbaum</DIV><DIV>AT&amp;T Labs - Research</DIV><DIV><BR =
class=3D"khtml-block-placeholder"></DIV><DIV><A =
href=3D"http://www.research.att.com/~yitzhak">http://www.research.att.com/=
~yitzhak</A></DIV><BR =
class=3D"Apple-interchange-newline"></SPAN></SPAN></SPAN></SPAN> =
</DIV><BR></DIV></DIV></BODY></HTML>=

--Apple-Mail-50-647648282--

