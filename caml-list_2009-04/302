Return-Path: <garrigue@math.nagoya-u.ac.jp>
X-Spam-Checker-Version: SpamAssassin 3.1.3 (2006-06-01) on yquem.inria.fr
X-Spam-Level: 
X-Spam-Status: No, score=0.4 required=5.0 tests=AWL,DNS_FROM_RFC_ABUSE 
	autolearn=disabled version=3.1.3
X-Original-To: caml-list@yquem.inria.fr
Delivered-To: caml-list@yquem.inria.fr
Received: from mail2-relais-roc.national.inria.fr (mail2-relais-roc.national.inria.fr [192.134.164.83])
	by yquem.inria.fr (Postfix) with ESMTP id 3E34BBBAF
	for <caml-list@yquem.inria.fr>; Mon, 20 Apr 2009 07:35:01 +0200 (CEST)
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: ApoEAJ+m60mCNhAB/2dsb2JhbADLXIN9Bg
X-IronPort-AV: E=Sophos;i="4.40,215,1238968800"; 
   d="scan'208";a="24836534"
Received: from kurims.kurims.kyoto-u.ac.jp ([130.54.16.1])
  by mail2-smtp-roc.national.inria.fr with ESMTP/TLS/DHE-RSA-AES256-SHA; 20 Apr 2009 07:34:59 +0200
Received: from localhost (orion [130.54.16.5])
	by kurims.kurims.kyoto-u.ac.jp (8.13.8/8.13.8) with ESMTP id n3K5YrJM009403;
	Mon, 20 Apr 2009 14:34:53 +0900 (JST)
Date: Mon, 20 Apr 2009 14:34:40 +0900 (JST)
Message-Id: <20090420.143440.83528006.garrigue@math.nagoya-u.ac.jp>
To: gje.hennequin@gmail.com
Cc: caml-list@yquem.inria.fr
Subject: Re: [Caml-list] mixed functional / object style
From: Jacques Garrigue <garrigue@math.nagoya-u.ac.jp>
In-Reply-To: <d8e32b760904180748h25b5dc06t3e204fbdc8caafde@mail.gmail.com>
References: <d8e32b760904180748h25b5dc06t3e204fbdc8caafde@mail.gmail.com>
X-Mailer: Mew version 4.2 on Emacs 22.2 / Mule 5.0 (SAKAKI)
Mime-Version: 1.0
Content-Type: Text/Plain; charset=us-ascii
Content-Transfer-Encoding: 7bit
X-Spam: no; 0.00; guillaume:01 val:01 mutable:01 val:01 mutable:01 two-level:01 pointer:01 caml-list:01 constructor:01 define:02 define:02 functional:02 represented:02 objects:02 objects:02 

From: Guillaume Hennequin <gje.hennequin@gmail.com>
> Dear list,
> 
> this is a somewhat naive question
> let's define
> 
> class a = object
>  val mutable v = ...
>  method v = v
>  method m = something that uses v
> end ;;
> 
> now assume that I want to create a lot of those a objects, so many that I
> may encounter memory problems.
> 
> I thought the following would be better, memory wise, but when I test it
> doesn't seem to be the case
> 
> class a = object
>  val mutable v = ...
>  method v = v
> end ;;
> 
> and instead of each object having its own method m, I define it separately
> let m x = something that calls x#v
> 
> This question is somewhat equivalent to: what is the memory consumption of a
> simple method
> method m = let _ = self#v in () ??

A better answer is that objects have a two-level structure.
They are represented by a record containing their fields, an object id
(use for comparison) and a pointer to a shared method table (share by
all objects generate from the same class).
So adding a method to a class does not change the memory consumption
for generated objects.

However, beware that the number of fields in an object is not only the
number of val in its class definition. Constructor arguments or
intermediate values generated by let statements are automatically
converted into implicit fields if they are used by methods or
initializers.

class c x y z =
  let t = y + z in
  object
    method x = x
    method t = t
  end
The above class has just two implicit fields, x and t.

Jacques Garrigue

