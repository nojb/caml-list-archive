Return-Path: <lpw25@cam.ac.uk>
X-Original-To: caml-list@sympa.inria.fr
Delivered-To: caml-list@sympa.inria.fr
Received: from mail3-relais-sop.national.inria.fr (mail3-relais-sop.national.inria.fr [192.134.164.104])
	by sympa.inria.fr (Postfix) with ESMTPS id 8F16C7EE5B
	for <caml-list@sympa.inria.fr>; Thu, 15 May 2014 01:33:35 +0200 (CEST)
Received-SPF: None (mail3-smtp-sop.national.inria.fr: no sender
  authenticity information available from domain of
  lpw25@cam.ac.uk) identity=pra; client-ip=131.111.8.150;
  receiver=mail3-smtp-sop.national.inria.fr;
  envelope-from="lpw25@cam.ac.uk"; x-sender="lpw25@cam.ac.uk";
  x-conformance=sidf_compatible
Received-SPF: None (mail3-smtp-sop.national.inria.fr: no sender
  authenticity information available from domain of
  lpw25@cam.ac.uk) identity=mailfrom; client-ip=131.111.8.150;
  receiver=mail3-smtp-sop.national.inria.fr;
  envelope-from="lpw25@cam.ac.uk"; x-sender="lpw25@cam.ac.uk";
  x-conformance=sidf_compatible
Received-SPF: None (mail3-smtp-sop.national.inria.fr: no sender
  authenticity information available from domain of
  postmaster@ppsw-50.csi.cam.ac.uk) identity=helo;
  client-ip=131.111.8.150;
  receiver=mail3-smtp-sop.national.inria.fr;
  envelope-from="lpw25@cam.ac.uk";
  x-sender="postmaster@ppsw-50.csi.cam.ac.uk";
  x-conformance=sidf_compatible
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: AnABALr8c1ODbwiWnGdsb2JhbABZg1WsKgaaHQGBJBYOAQEBAQEGDQkJFCiCJQEBBAE6PwULCyElDwEESYhMCATLVoVjFxaFPocBgXkHhEAEsBw
X-IPAS-Result: AnABALr8c1ODbwiWnGdsb2JhbABZg1WsKgaaHQGBJBYOAQEBAQEGDQkJFCiCJQEBBAE6PwULCyElDwEESYhMCATLVoVjFxaFPocBgXkHhEAEsBw
X-IronPort-AV: E=Sophos;i="4.97,1055,1389740400"; 
   d="scan'208";a="61897529"
Received: from ppsw-50.csi.cam.ac.uk ([131.111.8.150])
  by mail3-smtp-sop.national.inria.fr with ESMTP/TLS/DHE-RSA-AES256-SHA; 15 May 2014 01:33:34 +0200
X-Cam-AntiVirus: no malware found
X-Cam-ScannerInfo: http://www.cam.ac.uk/cs/email/scanner/
Received: from host5-81-227-175.range5-81.btcentralplus.com ([5.81.227.175]:58223 helo=netbook)
	by ppsw-50.csi.cam.ac.uk (smtp.hermes.cam.ac.uk [131.111.8.158]:587)
	with esmtpsa (PLAIN:lpw25) (TLSv1.2:DHE-RSA-AES128-SHA:128)
	id 1Wkig0-0004i1-sp (Exim 4.82_3-c0e5623)
	(return-path <lpw25@cam.ac.uk>); Thu, 15 May 2014 00:33:33 +0100
From: Leo White <lpw25@cam.ac.uk>
To: Milan =?utf-8?Q?Stanojevi=C4=87?= <milanst@gmail.com>
Cc: Alain Frisch <alain.frisch@lexifi.com>,  Jeremie Dimino <jdimino@janestreet.com>,  Caml List <caml-list@inria.fr>
References: <CAKR7PS92EjrW60hD3+MCUpaog1abdSsByi-H+RCg1iOWrcT_NQ@mail.gmail.com>
	<CANhEzE7V9HKj9Y_yqbR72o0hKg-HvvvBRDyEo9BRTxB3LbcP9w@mail.gmail.com>
	<CANhEzE5=XeqJGGRAcnheQAL--BYhQM-BSh2+qA6YObDC7703jg@mail.gmail.com>
	<CAKR7PS_U4trQ0yhJ5vXyqKHNLS8SsayOOEG_32DP=SAQQv55xA@mail.gmail.com>
	<CANhEzE7rvy1dbEADy1bV5AhJWt4oBrt_2Gt3ks-Bmd-6mmDM3g@mail.gmail.com>
	<CAKR7PS8mE6rrA-mjRyNX4BcFusRaOvcvxw0q3NR1zu5aEUPEHw@mail.gmail.com>
	<5373B8C5.2000804@frisch.fr> <5373B924.9020206@lexifi.com>
	<CAKR7PS9T+rUPv3MG-KKn-um7zdC3nDVanUzD+fC_Yi0zyc26SA@mail.gmail.com>
X-Face: "XWxb[u_Z\PA_Y?9@|IA!!+jTb(/290-*ea/Un$I0B98.$n%eL.;2w<l)q>*,z]WR#T:,p[
 NBd++M7l]#7zj7!{<NUTKJA{}Ox<uO[wb-s<\6jzp.r]-AE[W%E+ckCQ'2WZS@Zu/PJU$~~oy|>~iw
 $W-"/=|dVjhT[D{4~gE}gK<2`.6fs!;uqqud]vs2N/3^m7{aS1V,
Date: Thu, 15 May 2014 00:33:30 +0100
In-Reply-To: <CAKR7PS9T+rUPv3MG-KKn-um7zdC3nDVanUzD+fC_Yi0zyc26SA@mail.gmail.com>
	("Milan \=\?utf-8\?Q\?Stanojevi\=C4\=87\=22's\?\= message of "Wed, 14 May 2014
 16:56:53 -0400")
Message-ID: <8638gcj5px.fsf@cam.ac.uk>
User-Agent: Gnus/5.13 (Gnus v5.13) Emacs/23.4 (gnu/linux)
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Subject: Re: [Caml-list] open extensible types representation

> The rebinding of constructors is interesting. What are uses case apart
> from reducing verbosity in some cases?

Naming a constructor created by a functor.

For example, the following excerpts from my own toy example
(testsuite/tests/typing-extensions/msg.ml in the ocaml sources):

    module Msg : sig

      type 'a tag

      (* ... *)

      module Define (D : Desc) : sig
        type 'a tag += C : D.t tag
      end

    end = struct

      type 'a tag = ..

      (* ... *)

    end

    (* ... *)

    module StrM = Msg.Define(struct
      type t = string
      (* ... *)
    end);;

    type 'a Msg.tag += String = StrM.C;;

Note that the `Msg.tag` type has been made abstract, so the `Define`
functor is the only method of creating new constructors.

The rebinding gives the `String` constructor a meaningful name, and
allows you to expose it in your interface rather than expose all of
`StrM`.

Regards,

Leo
