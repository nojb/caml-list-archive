Received: (from majordomo@localhost) by pauillac.inria.fr (8.7.6/8.7.3) id TAA30566; Tue, 10 Apr 2001 19:34:49 +0200 (MET DST)
X-Authentication-Warning: pauillac.inria.fr: majordomo set sender to owner-caml-list@pauillac.inria.fr using -f
Received: from nez-perce.inria.fr (nez-perce.inria.fr [192.93.2.78]) by pauillac.inria.fr (8.7.6/8.7.3) with ESMTP id TAA30559 for <caml-list@pauillac.inria.fr>; Tue, 10 Apr 2001 19:34:48 +0200 (MET DST)
Received: from mrwall.kal.com (mrwall.kal.com [194.193.14.236])
	by nez-perce.inria.fr (8.11.1/8.10.0) with SMTP id f3AHYkn12081;
	Tue, 10 Apr 2001 19:34:47 +0200 (MET DST)
Received: from mrwall.kal.com [194.193.14.236]
	(HELO localhost)
	by mrwall.kal.com (AltaVista Mail V2.0J/2.0J BL25J listener)
	id 0000_0045_3ad3_4503_87c6;
	Tue, 10 Apr 2001 18:38:11 +0100
Subject: RE: [Caml-list] variant with tuple arg in pattern match?
MIME-Version: 1.0
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
content-class: urn:content-classes:message
Date: Tue, 10 Apr 2001 18:33:09 +0100
X-MimeOLE: Produced By Microsoft Exchange V6.0.4417.0
Message-ID: <DD7356599083414BA450E3DCC4119B8B06C4E4@NT.kal.com>
Thread-Topic: [Caml-list] variant with tuple arg in pattern match?
Thread-Index: AcDBxSgSLVUQ1+T7Q/+uS8uab5UHcwAHicIQ
From: "Dave Berry" <Dave@kal.com>
To: "Frank Atanassow" <franka@cs.uu.nl>
Cc: "Daniel de Rauglaudre" <daniel.de_rauglaudre@inria.fr>,
        <caml-list@inria.fr>
Sender: owner-caml-list@pauillac.inria.fr
Precedence: bulk

> From: Frank Atanassow [mailto:franka@cs.uu.nl]
> Sent: Tuesday, April 10, 2001 14:51
>=20
> When you say "currying" you are talking about a syntactic=20
> matter which arises
> due to positional application. When Daniel said that "currying" is
> basic to the lambda-calculus, he was talking about a more fundamental,
> semantic matter.

Daniel did not write the sentence you attribute to him.  He said that
currying is basic to functional programming.  There are many differences
between functional programming and the pure lambda calculus.  Consider:
let-abstraction, the value polymorphism rule, restrictive type systems,
syntax, tuples, records, exceptions, assignment, modules, IO, size of
programs, etc.

As for syntax versus semantics, I nearly wrote "semantic hack", until I
realised that it only works if the syntax also supports it.

> If you look at lambda-calculus from a sufficiently abstract=20
> perspective where
> the syntax is immaterial,...

... then you're not talking about functional programming. =20

> And how do you define g in the first case if you don't have=20
> semantical currying?

Possibly there is some terminological confusion here.  I've only ever
seen "currying" used to mean the encoding of multiple arguments using
higher order functions.  I certainly do not oppose the use of
higher-order functions for other uses, and of course this requires the
building of closures as you describe.

Dave.=20
-------------------
To unsubscribe, mail caml-list-request@inria.fr.  Archives: http://caml.inria.fr

