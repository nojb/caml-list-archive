Return-Path: <jon@ffconsultancy.com>
X-Spam-Checker-Version: SpamAssassin 3.1.3 (2006-06-01) on yquem.inria.fr
X-Spam-Level: 
X-Spam-Status: No, score=0.0 required=5.0 tests=AWL autolearn=disabled 
	version=3.1.3
X-Original-To: caml-list@yquem.inria.fr
Delivered-To: caml-list@yquem.inria.fr
Received: from mail2-relais-roc.national.inria.fr (mail2-relais-roc.national.inria.fr [192.134.164.83])
	by yquem.inria.fr (Postfix) with ESMTP id 4D85ABC6B
	for <caml-list@yquem.inria.fr>; Tue,  8 Jan 2008 19:43:54 +0100 (CET)
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: Ah4FAANTg0fUnw7Vlmdsb2JhbACCNY1mAQEBAQcEBiIHmGg
X-IronPort-AV: E=Sophos;i="4.24,258,1196636400"; 
   d="scan'208";a="5847011"
Received: from ptb-relay02.plus.net ([212.159.14.213])
  by mail2-smtp-roc.national.inria.fr with ESMTP; 08 Jan 2008 19:43:54 +0100
Received: from [80.229.56.224] (helo=beast.local)
	 by ptb-relay02.plus.net with esmtp (Exim) id 1JCJQX-0000yw-1D
	for caml-list@yquem.inria.fr; Tue, 08 Jan 2008 18:43:53 +0000
From: Jon Harrop <jon@ffconsultancy.com>
Organization: Flying Frog Consultancy Ltd.
To: caml-list@yquem.inria.fr
Subject: Re: [Caml-list] Shared run-time DLLs for commerce
Date: Tue, 8 Jan 2008 18:35:53 +0000
User-Agent: KMail/1.9.7
References: <200801071130.29025.jon@ffconsultancy.com> <200801071951.25170.jon@ffconsultancy.com> <20080108160351.GB4410@annexia.org>
In-Reply-To: <20080108160351.GB4410@annexia.org>
MIME-Version: 1.0
Content-Type: text/plain;
  charset="iso-8859-1"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline
Message-Id: <200801081835.53398.jon@ffconsultancy.com>
X-Spam: no; 0.00; run-time:01 frisch:01 bytecode:01 no-go:01 camlp:01 ocaml:01 afaik:01 compilation:01 ocaml:01 camlp:01 argv:01 failwith:01 byte:01 stdin:01 byte:01 

On Tuesday 08 January 2008 16:03:51 Richard Jones wrote:
> On Mon, Jan 07, 2008 at 07:51:23PM +0000, Jon Harrop wrote:
> > On Monday 07 January 2008 15:54:45 Alain Frisch wrote:
> > > 1. Distribute the source code, even without an open source license. I
> > > cannot imagine this would reduce your sales, but you know better.
> >
> > Yes. The concern here is not loss of sales but loss of competitive edge.
> > With direct access to a comprehensible implementation of the complex
> > algorithms inside the software, people will nick the algorithms even if
> > they don't nick the source code. After 9 years of work, I'd rather not
> > see that happen... :-)
>
> Really?  Do you think that the generated bytecode is obscure enough to
> protect this 'valuable' knowledge too?

I value the little protection that it provides.

> If I was that concerned about 
> my cherished algorithms, I wouldn't let them go beyond a web service.

For implementations that can be hidden in that way, it would be fine, but this 
is high-performance OpenGL-based visualization so a web service is a no-go.

> > > 3. Obfuscate the parts of the source code you want to keep secret.
> > > Camlp4 might help here.
> >
> > This is a possibility but there is little scope for obfuscation within
> > OCaml, AFAIK. I really want to distribute after pattern match
> > compilation, for example.
>
> Check out this recent discussion on ocaml_beginners:
>
> http://tech.groups.yahoo.com/group/ocaml_beginners/message/9163

Actually that is an excellent example of source code obfuscation being 
inadequate in OCaml because you can reverse engineer the code into a 
developable form using only camlp4:

$ camlp4oof bf.ml
let (i, f) = (input_char, (open_in Sys.argv.(1)))
let rec p (c, b, k) =
  try
    p
      (match i f with
       | '+' -> ((c + 1), b, k)
       | '-' -> ((c - 1), b, k)
       | '<' ->
           (match b with
            | ([], r) -> (0, ([], (c :: r)), k)
            | (h :: l, r) -> (h, (l, (c :: r)), k))
       | '>' ->
           (match b with
            | (l, []) -> (0, ((c :: l), []), k)
            | (l, h :: r) -> (h, ((c :: l), r), k))
       | '[' ->
           if c = 0
           then (while (i f) <> ']' do () done; (c, b, k))
           else (c, b, (((pos_in f) - 1) :: k))
       | ']' ->
           (match k with
            | [] -> failwith "]"
            | h :: t -> (seek_in f h; (c, b, t)))
       | ',' -> ((input_byte stdin), b, k)
       | '.' -> (output_byte stdout c; (c, b, k))
       | _ -> (c, b, k))
  with | _ -> ()
let _ = p (0, ([], []), [])

On the other hand, reverse engineering non-trivial pattern matches after 
compilation would require substantially more work for someone with no 
relevant expertise.

-- 
Dr Jon D Harrop, Flying Frog Consultancy Ltd.
http://www.ffconsultancy.com/products/?e

