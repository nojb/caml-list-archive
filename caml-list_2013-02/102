Return-Path: <rathereasy@gmail.com>
X-Original-To: caml-list@sympa.inria.fr
Delivered-To: caml-list@sympa.inria.fr
Received: from mail2-relais-roc.national.inria.fr (mail2-relais-roc.national.inria.fr [192.134.164.83])
	by sympa.inria.fr (Postfix) with ESMTPS id 1C2857F20B
	for <caml-list@sympa.inria.fr>; Tue, 12 Feb 2013 02:44:38 +0100 (CET)
Received-SPF: None (mail2-smtp-roc.national.inria.fr: no sender
  authenticity information available from domain of
  rathereasy@gmail.com) identity=pra; client-ip=209.85.219.54;
  receiver=mail2-smtp-roc.national.inria.fr;
  envelope-from="rathereasy@gmail.com";
  x-sender="rathereasy@gmail.com";
  x-conformance=sidf_compatible
Received-SPF: Pass (mail2-smtp-roc.national.inria.fr: domain of
  rathereasy@gmail.com designates 209.85.219.54 as permitted
  sender) identity=mailfrom; client-ip=209.85.219.54;
  receiver=mail2-smtp-roc.national.inria.fr;
  envelope-from="rathereasy@gmail.com";
  x-sender="rathereasy@gmail.com";
  x-conformance=sidf_compatible; x-record-type="v=spf1"
Received-SPF: None (mail2-smtp-roc.national.inria.fr: no sender
  authenticity information available from domain of
  postmaster@mail-oa0-f54.google.com) identity=helo;
  client-ip=209.85.219.54;
  receiver=mail2-smtp-roc.national.inria.fr;
  envelope-from="rathereasy@gmail.com";
  x-sender="postmaster@mail-oa0-f54.google.com";
  x-conformance=sidf_compatible
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: Av0BAC+dGVHRVds2m2dsb2JhbAA+Bq43iUsBiR4IFg4BAQEBAQgJCwkUJ4IfAQEEAScZARsSCwEDDAYFCw0NISEBAREBBQEKEgYTEodtAQMJBgyiDIw0gnuEOAoZJwMKWYh8AQUMjDOBHoQwA4hmi2WBWYEdiiODMRYphEo
X-IPAS-Result: Av0BAC+dGVHRVds2m2dsb2JhbAA+Bq43iUsBiR4IFg4BAQEBAQgJCwkUJ4IfAQEEAScZARsSCwEDDAYFCw0NISEBAREBBQEKEgYTEodtAQMJBgyiDIw0gnuEOAoZJwMKWYh8AQUMjDOBHoQwA4hmi2WBWYEdiiODMRYphEo
X-IronPort-AV: E=Sophos;i="4.84,646,1355094000"; 
   d="scan'208";a="2401531"
Received: from mail-oa0-f54.google.com ([209.85.219.54])
  by mail2-smtp-roc.national.inria.fr with ESMTP/TLS/RC4-SHA; 12 Feb 2013 02:44:37 +0100
Received: by mail-oa0-f54.google.com with SMTP id n12so7059876oag.13
        for <caml-list@inria.fr>; Mon, 11 Feb 2013 17:44:35 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20120113;
        h=mime-version:x-received:in-reply-to:references:date:message-id
         :subject:from:to:cc:content-type;
        bh=MNgblaBuCj4ClJaEg4eFga9NAeidKC7YZLiq9HJOdpg=;
        b=gB3/jccAoC2zFQnh9TDAtqWTuo157mZq5s7GtwLOKx6/e2UaazCKI6jCCe3BZ/b5nH
         ITTOSOhl0buBOQOkDEEbIxRYURYrcaN/AfkC3Ii/RB113Degf9WjEHzK8PkxibLrbBZI
         9YAt92+dhI9AjXT/MyK+D/MPbdRDl8MoAckwX9Y3c0ODGchAHEsgDCRg8tQQjSnVj5p3
         ccsPsIzqkuzLpaqz7uWz8g2aUovO0CoDfYqIP3+aDICg+Kz4HUSBOvELFSJWraDUjRS9
         0CqHesQD79dGEfuFZg+W/8gnOfzACCAiM9ppCltiD1e5vzWuGazZMIrzfArfq0fCXC7Z
         KNfQ==
MIME-Version: 1.0
X-Received: by 10.182.54.102 with SMTP id i6mr12109542obp.67.1360633475657;
 Mon, 11 Feb 2013 17:44:35 -0800 (PST)
Received: by 10.76.76.233 with HTTP; Mon, 11 Feb 2013 17:44:35 -0800 (PST)
In-Reply-To: <CALScVYmE+d88QaR27eU=FmFk+UJYZAE9NuQUmWeH9AocE8RZqA@mail.gmail.com>
References: <A597868B-9524-4233-92C1-BA4ED411644F@math.nagoya-u.ac.jp>
	<CALScVYmE+d88QaR27eU=FmFk+UJYZAE9NuQUmWeH9AocE8RZqA@mail.gmail.com>
Date: Mon, 11 Feb 2013 17:44:35 -0800
Message-ID: <CAK0y-350-qwKcqHu2=rJnsE_4jkd_kjnGd8GdyS3K-GX2ioh4g@mail.gmail.com>
From: Jacques Le Normand <rathereasy@gmail.com>
To: Sebastien Mondet <sebastien.mondet@gmail.com>
Cc: "caml-list@inria.fr" <caml-list@inria.fr>, Jacques Garrigue <garrigue@math.nagoya-u.ac.jp>
Content-Type: multipart/alternative; boundary=14dae93a1145fc6fcf04d57d2a75
Subject: Re: [Caml-list] Propagating types to pattern-matching


--14dae93a1145fc6fcf04d57d2a75
Content-Type: text/plain; charset=windows-1252
Content-Transfer-Encoding: quoted-printable

In this particular case those prudent enough to use '-warn-error -a' will
get a more informative error message, which is nice. Furthermore, for those
who think of polymorphic variants as an extension of variants, this makes
more sense.

On Mon, Feb 11, 2013 at 7:31 AM, Sebastien Mondet <
sebastien.mondet@gmail.com> wrote:

>
> Hi Jacques
>
> I don't know if this directly related, or if it is actually intended, but
> this looks like a regression to me:
>
>
> With OCaml version 4.00.1+dev2_2012-08-06  (4.00.1+short-types in Opam):
>
> # let f =3D function 0 -> `zero | 1 -> `one | _ -> `some;;
> val f : int -> [> `one | `some | `zero ] =3D <fun>
>
> # let g x =3D match f x with `one -> 1 | `zero -> 0;;
> Error: This pattern matches values of type [< `one | `zero ]
>
>        but a pattern was expected which matches values of type
>          [> `one | `some | `zero ]
>        The first variant type does not allow tag(s) `some
>
> which is the nice behavior we were used to,
> but with OCaml version 4.01.0+dev10-2012-10-16  (a.k.a.
> 4.01.0dev+short-paths), the error has been downgraded to a warning:
>
> # let f =3D function 0 -> `zero | 1 -> `one | _ -> `some;;
> val f : int -> [> `one | `some | `zero ] =3D <fun>
>
> # let g x =3D match f x with `one -> 1 | `zero -> 0;;
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a value that is not matched:
> `some
> val g : int -> int =3D <fun>
>
>
> Is it intended?
>
> Cheers
> Seb
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
> On Tue, Jan 15, 2013 at 12:59 AM, Jacques Garrigue <
> garrigue@math.nagoya-u.ac.jp> wrote:
>
>> Dear Camlers,
>>
>> It is a bit unusual, but this message is about changes in trunk.
>>
>> As you may be aware from past threads, since the introduction of GADTs
>> in 4.00, some type information is propagated to pattern-matching, to all=
ow
>> it to refine types.
>> More recently, types have started being used to disambiguate constructors
>> and record fields, which means some more dependency on type information
>> in pattern-matching.
>>
>> However, a weakness of this approach was that propagation was disabled
>> as soon as a pattern contained polymorphic variants. The reason is that
>> typing rules for polymorphic variants in patterns and expression are
>> subtly
>> different, and mixing information without care would lose principality.
>>
>> At long last I have removed this restriction on the presence of
>> polymorphic
>> variants, but this has some consequences on typing:
>>
>> * while type information is now propagated, information about possibly
>>   present constructors still has to be discarded. For instance this means
>> that
>>   the following code will not be typed as you could expect:
>>
>>         let f (x : [< `A | `B]) =3D match x with `A -> 1 | _ -> 2;;
>>         val f : [< `A | `B > `A ] -> int
>>
>>   What happens is that inside pattern-matching, only required constructo=
rs
>>   are propagated, which reduces the type of x to [> ] (a polymorphic
>> variant
>>   type with any constructor=85)
>>   As before, to give an upper bound to the matched type, the type
>> annotation
>>   must be inside a pattern:
>>
>>         let f =3D function (`A : [< `A | `B]) -> 1 | _ -> 2;;
>>         val f : [< `A | `B ] -> int =3D <fun>
>>
>> * the propagation of type information may lead to failure in some cases
>> that
>>   where typable before:
>>
>>         type ab =3D [ `A | `B ];;
>>         let f (x : [`A]) =3D match x with #ab -> 1;;
>>         Error: This pattern matches values of type [? `A | `B ]
>>                but a pattern was expected which matches values of type [
>> `A ]
>>                The second variant type does not allow tag(s) `B
>>
>>   During pattern-matching it is not allowed to match on absent type
>> constructors,
>>   even though the type of the patterns would eventually be [< `A | `B],
>> which allows
>>   discarding `B. ([? `A | `B] denotes a type obeying the rules of
>> pattern-matching)
>>
>> * for the sake of coherence, even if a type was not propagated because it
>>   was not known when typing a pattern-matching, we are still going to
>> fail if a
>>   matched constructor appears to be absent after typing the whole
>> function.
>>   (This only applies to propagable types, i.e. polymorphic variant types
>> that
>>    contain only required constructors)
>>
>> In particular the last two points are important, because previously such
>> uses
>> would not have triggered even a warning.
>>
>> The idea is that allowing propagation of types is more important than
>> keeping some not really useful corner cases, but if this is of concern
>> to you, I'm interested in feedback.
>>
>>         Jacques Garrigue
>> --
>> Caml-list mailing list.  Subscription management and archives:
>> https://sympa.inria.fr/sympa/arc/caml-list
>> Beginner's list: http://groups.yahoo.com/group/ocaml_beginners
>> Bug reports: http://caml.inria.fr/bin/caml-bugs
>
>
>

--14dae93a1145fc6fcf04d57d2a75
Content-Type: text/html; charset=windows-1252
Content-Transfer-Encoding: quoted-printable

In this particular case those prudent enough to use &#39;-warn-error -a&#39=
; will get a more informative error message, which is nice. Furthermore, fo=
r those who think of polymorphic variants as an extension of variants, this=
 makes more sense.<br>
<br><div class=3D"gmail_quote">On Mon, Feb 11, 2013 at 7:31 AM, Sebastien M=
ondet <span dir=3D"ltr">&lt;<a href=3D"mailto:sebastien.mondet@gmail.com" t=
arget=3D"_blank">sebastien.mondet@gmail.com</a>&gt;</span> wrote:<br><block=
quote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;border-left:1px #ccc=
 solid;padding-left:1ex">
<div dir=3D"ltr"><div><div><div><div><div><div><div><br></div>Hi Jacques<br=
><br></div>I don&#39;t know if this directly related, or if it is actually =
intended, but this looks like a regression to me:<br><br><br></div>With OCa=
ml version 4.00.1+dev2_2012-08-06=A0 (4.00.1+short-types in Opam):<br>





<br># let f =3D function 0 -&gt; `zero | 1 -&gt; `one | _ -&gt; `some;;<br>=
val f : int -&gt; [&gt; `one | `some | `zero ] =3D &lt;fun&gt;<br><br># let=
 g x =3D match f x with `one -&gt; 1 | `zero -&gt; 0;;<br>Error: This patte=
rn matches values of type [&lt; `one | `zero ]<div class=3D"im">
<br>




=A0=A0=A0=A0=A0=A0 but a pattern was expected which matches values of type<=
br></div>=A0=A0=A0=A0=A0=A0=A0=A0 [&gt; `one | `some | `zero ]<br>=A0=A0=A0=
=A0=A0=A0 The first variant type does not allow tag(s) `some<br><br></div><=
div>which is the nice behavior we were used to,<br>




</div>but with OCaml version 4.01.0+dev10-2012-10-16=A0 (a.k.a.=A0 4.01.0de=
v+short-paths), the error has been downgraded to a warning:<br>
<br># let f =3D function 0 -&gt; `zero | 1 -&gt; `one | _ -&gt; `some;;<br>=
val f : int -&gt; [&gt; `one | `some | `zero ] =3D &lt;fun&gt;<br><br># let=
 g x =3D match f x with `one -&gt; 1 | `zero -&gt; 0;;<br>Warning 8: this p=
attern-matching is not exhaustive.<br>





Here is an example of a value that is not matched:<br>`some<br>val g : int =
-&gt; int =3D &lt;fun&gt;<br><br><br></div>Is it intended?<br><br></div>Che=
ers<br></div>Seb<div><div class=3D"h5"><br><br><br><div><div><br><div><br>
<br><br><br>
<div><br><br><br><br><br><div><br><br><br><div>

<br><br><br><br></div></div></div></div></div></div><div class=3D"gmail_ext=
ra"><br><br><div class=3D"gmail_quote">On Tue, Jan 15, 2013 at 12:59 AM, Ja=
cques Garrigue <span dir=3D"ltr">&lt;<a href=3D"mailto:garrigue@math.nagoya=
-u.ac.jp" target=3D"_blank">garrigue@math.nagoya-u.ac.jp</a>&gt;</span> wro=
te:<br>



<blockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;border-left:1p=
x #ccc solid;padding-left:1ex">Dear Camlers,<br>
<br>
It is a bit unusual, but this message is about changes in trunk.<br>
<br>
As you may be aware from past threads, since the introduction of GADTs<br>
in 4.00, some type information is propagated to pattern-matching, to allow<=
br>
it to refine types.<br>
More recently, types have started being used to disambiguate constructors<b=
r>
and record fields, which means some more dependency on type information<br>
in pattern-matching.<br>
<br>
However, a weakness of this approach was that propagation was disabled<br>
as soon as a pattern contained polymorphic variants. The reason is that<br>
typing rules for polymorphic variants in patterns and expression are subtly=
<br>
different, and mixing information without care would lose principality.<br>
<br>
At long last I have removed this restriction on the presence of polymorphic=
<br>
variants, but this has some consequences on typing:<br>
<br>
* while type information is now propagated, information about possibly<br>
=A0 present constructors still has to be discarded. For instance this means=
 that<br>
=A0 the following code will not be typed as you could expect:<br>
<br>
=A0 =A0 =A0 =A0 let f (x : [&lt; `A | `B]) =3D match x with `A -&gt; 1 | _ =
-&gt; 2;;<br>
=A0 =A0 =A0 =A0 val f : [&lt; `A | `B &gt; `A ] -&gt; int<br>
<br>
=A0 What happens is that inside pattern-matching, only required constructor=
s<br>
=A0 are propagated, which reduces the type of x to [&gt; ] (a polymorphic v=
ariant<br>
=A0 type with any constructor=85)<br>
=A0 As before, to give an upper bound to the matched type, the type annotat=
ion<br>
=A0 must be inside a pattern:<br>
<br>
=A0 =A0 =A0 =A0 let f =3D function (`A : [&lt; `A | `B]) -&gt; 1 | _ -&gt; =
2;;<br>
=A0 =A0 =A0 =A0 val f : [&lt; `A | `B ] -&gt; int =3D &lt;fun&gt;<br>
<br>
* the propagation of type information may lead to failure in some cases tha=
t<br>
=A0 where typable before:<br>
<br>
=A0 =A0 =A0 =A0 type ab =3D [ `A | `B ];;<br>
=A0 =A0 =A0 =A0 let f (x : [`A]) =3D match x with #ab -&gt; 1;;<br>
=A0 =A0 =A0 =A0 Error: This pattern matches values of type [? `A | `B ]<br>
=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0but a pattern was expected which matches val=
ues of type [ `A ]<br>
=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0The second variant type does not allow tag(s=
) `B<br>
<br>
=A0 During pattern-matching it is not allowed to match on absent type const=
ructors,<br>
=A0 even though the type of the patterns would eventually be [&lt; `A | `B]=
, which allows<br>
=A0 discarding `B. ([? `A | `B] denotes a type obeying the rules of pattern=
-matching)<br>
<br>
* for the sake of coherence, even if a type was not propagated because it<b=
r>
=A0 was not known when typing a pattern-matching, we are still going to fai=
l if a<br>
=A0 matched constructor appears to be absent after typing the whole functio=
n.<br>
=A0 (This only applies to propagable types, i.e. polymorphic variant types =
that<br>
=A0 =A0contain only required constructors)<br>
<br>
In particular the last two points are important, because previously such us=
es<br>
would not have triggered even a warning.<br>
<br>
The idea is that allowing propagation of types is more important than<br>
keeping some not really useful corner cases, but if this is of concern<br>
to you, I&#39;m interested in feedback.<br>
<span><font color=3D"#888888"><br>
=A0 =A0 =A0 =A0 Jacques Garrigue<br>
--<br>
Caml-list mailing list. =A0Subscription management and archives:<br>
<a href=3D"https://sympa.inria.fr/sympa/arc/caml-list" target=3D"_blank">ht=
tps://sympa.inria.fr/sympa/arc/caml-list</a><br>
Beginner&#39;s list: <a href=3D"http://groups.yahoo.com/group/ocaml_beginne=
rs" target=3D"_blank">http://groups.yahoo.com/group/ocaml_beginners</a><br>
Bug reports: <a href=3D"http://caml.inria.fr/bin/caml-bugs" target=3D"_blan=
k">http://caml.inria.fr/bin/caml-bugs</a></font></span></blockquote></div><=
br></div></div></div></div>
</blockquote></div><br>

--14dae93a1145fc6fcf04d57d2a75--
