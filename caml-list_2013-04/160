Return-Path: <jfc@mit.edu>
X-Original-To: caml-list@sympa.inria.fr
Delivered-To: caml-list@sympa.inria.fr
Received: from mail3-relais-sop.national.inria.fr (mail3-relais-sop.national.inria.fr [192.134.164.104])
	by sympa.inria.fr (Postfix) with ESMTPS id 0F0477EE51
	for <caml-list@sympa.inria.fr>; Thu, 18 Apr 2013 19:12:42 +0200 (CEST)
Received-SPF: None (mail3-smtp-sop.national.inria.fr: no sender
  authenticity information available from domain of
  jfc@MIT.EDU) identity=pra; client-ip=18.9.25.13;
  receiver=mail3-smtp-sop.national.inria.fr;
  envelope-from="jfc@mit.edu"; x-sender="jfc@MIT.EDU";
  x-conformance=sidf_compatible
Received-SPF: Pass (mail3-smtp-sop.national.inria.fr: domain of
  jfc@mit.edu designates 18.9.25.13 as permitted sender)
  identity=mailfrom; client-ip=18.9.25.13;
  receiver=mail3-smtp-sop.national.inria.fr;
  envelope-from="jfc@mit.edu"; x-sender="jfc@mit.edu";
  x-conformance=sidf_compatible; x-record-type="v=spf1"
Received-SPF: None (mail3-smtp-sop.national.inria.fr: no sender
  authenticity information available from domain of
  postmaster@dmz-mailsec-scanner-2.mit.edu) identity=helo;
  client-ip=18.9.25.13;
  receiver=mail3-smtp-sop.national.inria.fr;
  envelope-from="jfc@mit.edu";
  x-sender="postmaster@dmz-mailsec-scanner-2.mit.edu";
  x-conformance=sidf_compatible
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: AgUCAJIncFESCRkNnGdsb2JhbABQxR4WDgEBAQEBBg0JCRQogk2BDjSIeJ0zmCyJEY1ggVWCUGEDq0KBTg
X-IPAS-Result: AgUCAJIncFESCRkNnGdsb2JhbABQxR4WDgEBAQEBBg0JCRQogk2BDjSIeJ0zmCyJEY1ggVWCUGEDq0KBTg
X-IronPort-AV: E=Sophos;i="4.87,503,1363129200"; 
   d="scan'208";a="11461886"
Received: from dmz-mailsec-scanner-2.mit.edu ([18.9.25.13])
  by mail3-smtp-sop.national.inria.fr with ESMTP; 18 Apr 2013 19:12:40 +0200
X-AuditID: 1209190d-b7f716d000005557-e3-5170298761be
Received: from mailhub-auth-3.mit.edu ( [18.9.21.43])
	by dmz-mailsec-scanner-2.mit.edu (Symantec Messaging Gateway) with SMTP id 0D.F1.21847.78920715; Thu, 18 Apr 2013 13:12:39 -0400 (EDT)
Received: from outgoing.mit.edu (OUTGOING-AUTH-1.MIT.EDU [18.9.28.11])
	by mailhub-auth-3.mit.edu (8.13.8/8.9.2) with ESMTP id r3IHCcG4021613
	for <caml-list@inria.fr>; Thu, 18 Apr 2013 13:12:39 -0400
Received: from localhost (CONTENTS-VNDER-PRESSVRE.MIT.EDU [18.9.64.11])
	(authenticated bits=0)
        (User authenticated as jfc@ATHENA.MIT.EDU)
	by outgoing.mit.edu (8.13.8/8.12.4) with ESMTP id r3IHCbSC023593
	for <caml-list@inria.fr>; Thu, 18 Apr 2013 13:12:38 -0400
Message-Id: <201304181712.r3IHCbSC023593@outgoing.mit.edu>
To: caml-list@inria.fr
X-Mailer: MH-E 8.2; nmh 1.3; GNU Emacs 23.3.1
Date: Thu, 18 Apr 2013 13:12:37 -0400
From: John Carr <jfc@MIT.EDU>
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFmpkkeLIzCtJLcpLzFFi42IR4hTV1m3XLAg0+PRBxuLTjg0sDowek14c
	YglgjOKySUnNySxLLdK3S+DKWHDApuApV8X87n9MDYydHF2MnBwSAiYSj5fcZ4WwxSQu3FvP
	1sXIxSEksI9R4lL/LkYI5xSjxKO1jSwQzmQmidmNncwgLbwCVhIt9+YygdgiQO2z5l8BKuLg
	EAYau3iLIcRUXYl/+9ewgNgsAqoSt9q2sYPYbAKyEo/auxgnMHIvYGRYxSibklulm5uYmVOc
	mqxbnJyYl5dapGukl5tZopeaUrqJEexTSd4djO8OKh1iFOBgVOLhbZAoCBRiTSwrrsw9xCjJ
	waQkyvtOFSjEl5SfUpmRWJwRX1Sak1p8iFGCg1lJhPc6SI43JbGyKrUoHyYlzcGiJM57JeWm
	v5BAemJJanZqakFqEUxWhoNDSYI3QwOoUbAoNT21Ii0zpwQhzcTBCTKcB2i4HUgNb3FBYm5x
	ZjpE/hSjopQ4rztIQgAkkVGaB9cLi7lXjOJArwjzBoBU8QDjFa77FdBgJqDBf1fmgwwuSURI
	STUwMunJ7N/BzrzGLC2g66+G8Mn/286w7lgn+cTwyIvDCRo2W+zOyf8w/+WvZ1yTYiH8Q+tN
	0Kl9eh3nz/b/q/eR2FTZyGAVblP6KXtpx885yyxs3HNq50s7nbzDphtv8d4pcoXUsbj7+2WE
	DHT3zTUR5FKKPTnpwecLH+78eZRy57TxgTVzbm4VVGIpzkg01GIuKk4EAPLRRrqUAgAA
Subject: [Caml-list] Unpacked module parameterized type escaping


I have a function of two arguments:

1. A packed module implementing Map.S.

2. A value of the module's Map.S.t.

I can't find a way to prevent a "type constructor ... would escape its
scope" error.

I'm running into this limitation from the ocaml manual:

"The package-type syntactic class appearing in the (module package-type)
type expression and in the annotated forms represents a subset of module
types. This subset consists of named module types with optional
constraints of a limited form: only non-parametrized types can be
specified."

The type I want to constrain is parameterized: +'a Map.S.t.

Can I get this code to type check?

(* val make_module : unit -> (module Map.S with type key = int) *)
let make_module () =
  let module K = struct
    type t = int
    let compare = compare
  end
  in
    (module Map.Make(K) : Map.S with type key = int)

let is_empty m v =
  let module M = (val m : Map.S with type key = int) in
    M.is_empty v

(* This fails because (type mt) can not be unified with +'a Map.S.t.

let is_empty (type mt) m v =
  let module M = (val m : Map.S with type key = int and type t = mt) in
    M.is_empty v *)

(* This invalid syntax is approximately what I want:

let is_empty (type '+a mt) m v =
  let module M = (val m : Map.S with type key = int and type 'a t = 'a mt) in
    M.is_empty v
*)  
