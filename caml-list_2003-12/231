Received: (from majordomo@localhost) by pauillac.inria.fr (8.7.6/8.7.3) id RAA20370; Sat, 20 Dec 2003 17:50:30 +0100 (MET)
X-Authentication-Warning: pauillac.inria.fr: majordomo set sender to owner-caml-list@pauillac.inria.fr using -f
Received: from nez-perce.inria.fr (nez-perce.inria.fr [192.93.2.78]) by pauillac.inria.fr (8.7.6/8.7.3) with ESMTP id RAA20432 for <caml-list@pauillac.inria.fr>; Sat, 20 Dec 2003 17:50:29 +0100 (MET)
Received: from mwinf0302.wanadoo.fr (smtp3.wanadoo.fr [193.252.22.28])
	by nez-perce.inria.fr (8.11.1/8.11.1) with ESMTP id hBKGoTX09365
	for <caml-list@inria.fr>; Sat, 20 Dec 2003 17:50:29 +0100 (MET)
Received: from debian (ca-bordeaux-20-107.w80-8.abo.wanadoo.fr [80.8.92.107])
	by mwinf0302.wanadoo.fr (SMTP Server) with ESMTP id C1176C00026A
	for <caml-list@inria.fr>; Sat, 20 Dec 2003 17:50:28 +0100 (CET)
Received: from moi by debian with local (Exim 3.36 #1 (Debian))
	id 1AXkJb-0002lq-00
	for <caml-list@inria.fr>; Sat, 20 Dec 2003 17:50:55 +0100
To: caml-list@inria.fr
Subject: Re: [Caml-list] ASM code generated by OCAML
References: <20031220105040.7a079f67.segfault@email.it>
From: Remi Vanicat <remi.vanicat@laposte.net>
Mail-Copy-To: never
Date: Sat, 20 Dec 2003 17:50:54 +0100
In-Reply-To: <20031220105040.7a079f67.segfault@email.it> (Francesco Abbate's
 message of "Sat, 20 Dec 2003 10:50:40 +0100")
Message-ID: <87y8t78mc1.dlv@wanadoo.fr>
User-Agent: Gnus/5.1003 (Gnus v5.10.3) Emacs/21.3 (gnu/linux)
MIME-Version: 1.0
Content-Type: text/plain; charset=iso-8859-15
Content-Transfer-Encoding: 8bit
X-Loop: caml-list@inria.fr
X-Spam: no; 0.00; caml-list:01 francesco:99 segfault:01 paranoid:01 gcc:01 gcc:01 helper:01 mult:01 accu:01 accu:01 helper:01 mult:01 compiler:01 compiler:01 compilers:01 
Sender: owner-caml-list@pauillac.inria.fr
Precedence: bulk

Francesco Abbate <segfault@email.it> writes:

> Dear Ocamlers,
>
> ok, I confess that I'm a little bit paranoid and I often
> look to the assembler code generated by Ocaml to get an
> idea of real efficience of the compiler.
>
> While, generally speaking, the ASM code generated by ocaml
> is pretty good, I wonder why the following function
> is not decently assembled by ocaml :
> -----------------------------------------
> let rec conv n =
>   let r = n mod 10
>   and n' = n / 10 in
>   if n' = 0 then r
>   else r + 8 * (conv n')
> -----------------------------------------
> nor the C version is decently assembled by GCC
> -----------------------------------------
> int
> conv (int n)
> {
>   int m = n / 10, r = n % 10;
>   if (m > 0)
>     return r + 8 * conv (m);
>   return m;
> }
> -----------------------------------------

> So my answer is why nor Ocaml nor GCC does generate efficient
> assembler code ?
>
> I will attempt to give a tentative answer
> - for some reason the compiler does not understands the (n mod 10)
>   and (n /10) both can be avaluated with a simgle "idiv"
>   instruction

This require some analysis that isn't needed in general

> - for some reason the compilers does not conceive to have a loop
>   which push something on the stack at each cycle.

Ocaml (and I believe GCC) only optimize code witch is tail recursive,
that is the result of the function is the result of the recursive
case. 

You should transform your code into a tail rec function by hand :
let conv n =
   let rec helper n mult accu =
      if n = 0 then accu
      else
         let r = n mod 10
         and n' = n / 10 in
         helper n' (mult * 8) (accu + r * mult) in
   helper n 1 0

As you can see, the result of the recursive function helper is the
result of the recursive call.

-- 
Rémi Vanicat

-------------------
To unsubscribe, mail caml-list-request@inria.fr Archives: http://caml.inria.fr
Bug reports: http://caml.inria.fr/bin/caml-bugs FAQ: http://caml.inria.fr/FAQ/
Beginner's list: http://groups.yahoo.com/group/ocaml_beginners

