Return-Path: <anthony.tavener@gmail.com>
X-Original-To: caml-list@sympa.inria.fr
Delivered-To: caml-list@sympa.inria.fr
Received: from mail3-relais-sop.national.inria.fr (mail3-relais-sop.national.inria.fr [192.134.164.104])
	by sympa.inria.fr (Postfix) with ESMTPS id B7E577FCEF
	for <caml-list@sympa.inria.fr>; Thu,  2 Apr 2015 14:19:31 +0200 (CEST)
Received-SPF: None (mail3-smtp-sop.national.inria.fr: no sender
  authenticity information available from domain of
  anthony.tavener@gmail.com) identity=pra;
  client-ip=74.125.82.52;
  receiver=mail3-smtp-sop.national.inria.fr;
  envelope-from="anthony.tavener@gmail.com";
  x-sender="anthony.tavener@gmail.com";
  x-conformance=sidf_compatible
Received-SPF: Pass (mail3-smtp-sop.national.inria.fr: domain of
  anthony.tavener@gmail.com designates 74.125.82.52 as
  permitted sender) identity=mailfrom; client-ip=74.125.82.52;
  receiver=mail3-smtp-sop.national.inria.fr;
  envelope-from="anthony.tavener@gmail.com";
  x-sender="anthony.tavener@gmail.com";
  x-conformance=sidf_compatible; x-record-type="v=spf1"
Received-SPF: None (mail3-smtp-sop.national.inria.fr: no sender
  authenticity information available from domain of
  postmaster@mail-wg0-f52.google.com) identity=helo;
  client-ip=74.125.82.52;
  receiver=mail3-smtp-sop.national.inria.fr;
  envelope-from="anthony.tavener@gmail.com";
  x-sender="postmaster@mail-wg0-f52.google.com";
  x-conformance=sidf_compatible
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: A0DRAQBrMh1VmzRSfUobATcJg1pcBYJKRrIyjhiCA4VzAoFBB0wBAQEBAQESAQEBAQEGCwsJFC6EHgEBAQMBDAYRHQEbEgsBAwELBgMCCw0NHQICIgERAQUBChIGExIQh3gBAwkIDZdPSJBXPjGLNoFrgneNNAoZJwMKVIRwAQEBAQEFAQEBAQEBARUBBQ6LG4QdWAQHgmiBRQWFEAqJQYFshBiECoIBgR0RKY8pgX4SI4EMCYF9ghU8MYJDAQEB
X-IPAS-Result: A0DRAQBrMh1VmzRSfUobATcJg1pcBYJKRrIyjhiCA4VzAoFBB0wBAQEBAQESAQEBAQEGCwsJFC6EHgEBAQMBDAYRHQEbEgsBAwELBgMCCw0NHQICIgERAQUBChIGExIQh3gBAwkIDZdPSJBXPjGLNoFrgneNNAoZJwMKVIRwAQEBAQEFAQEBAQEBARUBBQ6LG4QdWAQHgmiBRQWFEAqJQYFshBiECoIBgR0RKY8pgX4SI4EMCYF9ghU8MYJDAQEB
X-IronPort-AV: E=Sophos;i="5.11,510,1422918000"; 
   d="scan'208";a="108054592"
Received: from mail-wg0-f52.google.com ([74.125.82.52])
  by mail3-smtp-sop.national.inria.fr with ESMTP/TLS/RC4-SHA; 02 Apr 2015 14:19:30 +0200
Received: by wgbdm7 with SMTP id dm7so83561937wgb.1
        for <caml-list@inria.fr>; Thu, 02 Apr 2015 05:19:30 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20120113;
        h=mime-version:in-reply-to:references:date:message-id:subject:from:to
         :cc:content-type;
        bh=7mBS909CAx8Tc4AxuvHhyaJex8G4FR4WBf0/mHIEwkU=;
        b=TvPH73GhlqSOBMB1sYm1aSIPqgAKIdcEBn58AuBMDSmMd9NcRS415xnIi/pTtgSbHb
         gdUcMarSN7cuNJt5kEzEAZAoFhhB00VSfjGGA4iyozFBHUWrMLZXRg3aNnDErmXNcWdl
         Rd9oc7+7reY/KUtQEyGbzAURmGahNbkLZ9se1SL1uZ6qF0yI8sRMLSjybOtzQWpRDug6
         4xfdTzIZrXk3MuZyKlLL8elLm8HEUvEKEnRvJC2sKp5YhTDIsmd7An9wVVmftX+oxyyc
         HptOx7mEtoBTscygB8I08C9024DC4fwpzLcw5u/E6VCoFvsJ4DAYhaG3Swd9zPq8lI4D
         pkeg==
MIME-Version: 1.0
X-Received: by 10.180.19.65 with SMTP id c1mr23452428wie.49.1427977170210;
 Thu, 02 Apr 2015 05:19:30 -0700 (PDT)
Received: by 10.28.87.65 with HTTP; Thu, 2 Apr 2015 05:19:30 -0700 (PDT)
In-Reply-To: <551D1C29.5010808@lakaban.net>
References: <551C55F4.5080703@lakaban.net>
	<551D1C29.5010808@lakaban.net>
Date: Thu, 2 Apr 2015 14:19:30 +0200
Message-ID: <CAN=ouMS8GxopBUuuwn_GKR62fdL7H9o+S3LBPcA_NunX85YKrQ@mail.gmail.com>
From: Anthony Tavener <anthony.tavener@gmail.com>
To: =?UTF-8?B?RnLDqWTDqXJpYyBCb3Vy?= <frederic.bour@lakaban.net>
Cc: "caml-list@inria.fr" <caml-list@inria.fr>
Content-Type: multipart/alternative; boundary=bcaec53d592ffa55320512bcd761
Subject: Re: [Caml-list] [ANN] OCamp - Reactive programming in the shell

--bcaec53d592ffa55320512bcd761
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Hah! You were serious? I thought with commands like hipp and stir, and your
legal review notice at the end, that this was an April Fool's joke. :)

On Thu, Apr 2, 2015 at 12:38 PM, Fr=C3=A9d=C3=A9ric Bour <frederic.bour@lak=
aban.net>
wrote:

> Code is finally available at:
>     https://github.com/def-lkb/ocamp
>
> Sorry for the little delay!
>
>
> On 01/04/2015 22:32, Fr=C3=A9d=C3=A9ric Bour wrote:
>
>> OCamp extends unix shells with constructions to express memoization,
>> sharing of computations and reactive programming.
>>
>> # Subcommands
>>
>> ## fire
>>
>> Just wrap a unix command with "ocamp fire" to enable the extension:
>>   $ ocamp fire bash
>>
>> This will spawn a new bash session where the following subcommands are
>> enabled.
>>
>> ## hipp
>>
>>   $ ocamp hipp <command>
>>
>> Will memoize the output and exit status of <command>.
>> Later calls to the same <command> won't lead to actual execution, but
>> just to a duplication of its previous output.
>> Concurrent calls to <command> will just share the same process, the
>> beginning of the output being replayed to later callers.
>>
>> The identity of a command is defined by its arguments and working
>> directory.
>>
>> ## stir
>>
>>   $ ocamp stir <command>
>>
>> Indicate potential changes in the output if <command> was rerun.
>> Later calls to `hipp` will recompute <command> as if it was not yet
>> memoized.
>>
>> ## (un)follow
>>
>>   $ ocamp follow <command>
>>
>> First, <command> is memoized if it was not the case yet.
>> Then changes to dependencies of <command> will trigger a reevaluation.
>> Use `stir` to notify a change.
>>
>> (to follow is an hipp/stir reactivity).
>>
>> ## pull
>>
>>   $ ocamp pull <command>
>>
>> Closely related to `hipp`, but instead of marking dependency on the
>> output of <command>, the dependency applies to the "effects" of <command=
>.
>>
>> Thus, if `stir` is used:
>> - all pullers will be reevaluated.
>> - hippers will be reevaluated only if the output is different.
>>
>> ## Summary
>>
>>   $ ocamp fire <command> - setup a new session alive until <command> exi=
ts
>>           pull <command> - mark dependency on effects of <command>
>>           hipp <command> - mark dependency on output of <command>
>>           stir <command> - notify that <command> might have been updated
>>           follow <command> - eval <command>, and reactively recompute it
>>                              whenever one of its dependencies change.
>>           unfollow <command> - stop recomputing <command> when
>> dependencies
>>                                change
>>
>> hipp and pull provide memoization.
>> stir and follow bring a flavor of reactive programming.
>>
>> # Examples
>>
>> ## Fibonacci
>>
>>   $ cat fib.sh
>>   #!/bin/sh
>>   ARG=3D"$1"
>>   if [ "$ARG" -le 1 ]; then
>>     echo "$ARG"
>>   else
>>     A=3D`ocamp hipp ./fib.sh $((ARG-1))`
>>     B=3D`ocamp hipp ./fib.sh $((ARG-2))`
>>     echo $((A+B))
>>   fi
>>
>>   $ time ocamp fire ./fib.sh 50
>>   12586269025
>>     real    0m0.391s
>>   user    0m0.153s
>>   sys     0m0.060s
>>
>> ## Build-system
>>
>> `ocamp` provides simple primitives to construct and manage a dependency
>> graph.
>>
>> This might be a saner foundation to base a build-system on than make(1):
>> - the command focus on one specific problem
>> - no dsl is involved; rules can be plain unix commands, including a
>> shell, rather than a make-flavored simulation of shell
>> - nothing is provided for resolving goals; indeed this is better left to
>> tools specifically built for goal-search.
>>
>> A quick'n'dirty script building ocamp itself is provided as an example.
>>
>> # Future
>>
>> The current release is a proof-of-concept and should be considered alpha
>> quality.
>> The two features planned next are a way to make the graph persistent (all
>> data is kept in memory atm) and an interface to debug and/or observe gra=
ph
>> construction.
>>
>> Note: code is undergoing legal review and should be available soon \o/
>>
>>
>
> --
> Caml-list mailing list.  Subscription management and archives:
> https://sympa.inria.fr/sympa/arc/caml-list
> Beginner's list: http://groups.yahoo.com/group/ocaml_beginners
> Bug reports: http://caml.inria.fr/bin/caml-bugs
>

--bcaec53d592ffa55320512bcd761
Content-Type: text/html; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

<div dir=3D"ltr">Hah! You were serious? I thought with commands like hipp a=
nd stir, and your legal review notice at the end, that this was an April Fo=
ol&#39;s joke. :)<br></div><div class=3D"gmail_extra"><br><div class=3D"gma=
il_quote">On Thu, Apr 2, 2015 at 12:38 PM, Fr=C3=A9d=C3=A9ric Bour <span di=
r=3D"ltr">&lt;<a href=3D"mailto:frederic.bour@lakaban.net" target=3D"_blank=
">frederic.bour@lakaban.net</a>&gt;</span> wrote:<br><blockquote class=3D"g=
mail_quote" style=3D"margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-l=
eft:1ex">Code is finally available at:<br>
=C2=A0 =C2=A0 <a href=3D"https://github.com/def-lkb/ocamp" target=3D"_blank=
">https://github.com/def-lkb/<u></u>ocamp</a><br>
<br>
Sorry for the little delay!<div class=3D"HOEnZb"><div class=3D"h5"><br>
<br>
On 01/04/2015 22:32, Fr=C3=A9d=C3=A9ric Bour wrote:<br>
<blockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;border-left:1p=
x #ccc solid;padding-left:1ex">
OCamp extends unix shells with constructions to express memoization, sharin=
g of computations and reactive programming.<br>
<br>
# Subcommands<br>
<br>
## fire<br>
<br>
Just wrap a unix command with &quot;ocamp fire&quot; to enable the extensio=
n:<br>
=C2=A0 $ ocamp fire bash<br>
<br>
This will spawn a new bash session where the following subcommands are enab=
led.<br>
<br>
## hipp<br>
<br>
=C2=A0 $ ocamp hipp &lt;command&gt;<br>
<br>
Will memoize the output and exit status of &lt;command&gt;.<br>
Later calls to the same &lt;command&gt; won&#39;t lead to actual execution,=
 but just to a duplication of its previous output.<br>
Concurrent calls to &lt;command&gt; will just share the same process, the b=
eginning of the output being replayed to later callers.<br>
<br>
The identity of a command is defined by its arguments and working directory=
.<br>
<br>
## stir<br>
<br>
=C2=A0 $ ocamp stir &lt;command&gt;<br>
<br>
Indicate potential changes in the output if &lt;command&gt; was rerun.<br>
Later calls to `hipp` will recompute &lt;command&gt; as if it was not yet m=
emoized.<br>
<br>
## (un)follow<br>
<br>
=C2=A0 $ ocamp follow &lt;command&gt;<br>
<br>
First, &lt;command&gt; is memoized if it was not the case yet.<br>
Then changes to dependencies of &lt;command&gt; will trigger a reevaluation=
.<br>
Use `stir` to notify a change.<br>
<br>
(to follow is an hipp/stir reactivity).<br>
<br>
## pull<br>
<br>
=C2=A0 $ ocamp pull &lt;command&gt;<br>
<br>
Closely related to `hipp`, but instead of marking dependency on the output =
of &lt;command&gt;, the dependency applies to the &quot;effects&quot; of &l=
t;command&gt;.<br>
<br>
Thus, if `stir` is used:<br>
- all pullers will be reevaluated.<br>
- hippers will be reevaluated only if the output is different.<br>
<br>
## Summary<br>
<br>
=C2=A0 $ ocamp fire &lt;command&gt; - setup a new session alive until &lt;c=
ommand&gt; exits<br>
=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 pull &lt;command&gt; - mark dependency o=
n effects of &lt;command&gt;<br>
=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 hipp &lt;command&gt; - mark dependency o=
n output of &lt;command&gt;<br>
=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 stir &lt;command&gt; - notify that &lt;c=
ommand&gt; might have been updated<br>
=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 follow &lt;command&gt; - eval &lt;comman=
d&gt;, and reactively recompute it<br>
=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0whenever one of its dependencies change.<br>
=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 unfollow &lt;command&gt; - stop recomput=
ing &lt;command&gt; when dependencies<br>
=C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=
=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0change<br>
<br>
hipp and pull provide memoization.<br>
stir and follow bring a flavor of reactive programming.<br>
<br>
# Examples<br>
<br>
## Fibonacci<br>
<br>
=C2=A0 $ cat fib.sh<br>
=C2=A0 #!/bin/sh<br>
=C2=A0 ARG=3D&quot;$1&quot;<br>
=C2=A0 if [ &quot;$ARG&quot; -le 1 ]; then<br>
=C2=A0 =C2=A0 echo &quot;$ARG&quot;<br>
=C2=A0 else<br>
=C2=A0 =C2=A0 A=3D`ocamp hipp ./fib.sh $((ARG-1))`<br>
=C2=A0 =C2=A0 B=3D`ocamp hipp ./fib.sh $((ARG-2))`<br>
=C2=A0 =C2=A0 echo $((A+B))<br>
=C2=A0 fi<br>
<br>
=C2=A0 $ time ocamp fire ./fib.sh 50<br>
=C2=A0 12586269025<br>
=C2=A0 =C2=A0 real=C2=A0 =C2=A0 0m0.391s<br>
=C2=A0 user=C2=A0 =C2=A0 0m0.153s<br>
=C2=A0 sys=C2=A0 =C2=A0 =C2=A00m0.060s<br>
<br>
## Build-system<br>
<br>
`ocamp` provides simple primitives to construct and manage a dependency gra=
ph.<br>
<br>
This might be a saner foundation to base a build-system on than make(1):<br>
- the command focus on one specific problem<br>
- no dsl is involved; rules can be plain unix commands, including a shell, =
rather than a make-flavored simulation of shell<br>
- nothing is provided for resolving goals; indeed this is better left to to=
ols specifically built for goal-search.<br>
<br>
A quick&#39;n&#39;dirty script building ocamp itself is provided as an exam=
ple.<br>
<br>
# Future<br>
<br>
The current release is a proof-of-concept and should be considered alpha qu=
ality.<br>
The two features planned next are a way to make the graph persistent (all d=
ata is kept in memory atm) and an interface to debug and/or observe graph c=
onstruction.<br>
<br>
Note: code is undergoing legal review and should be available soon \o/<br>
<br>
</blockquote>
<br>
<br>
-- <br>
Caml-list mailing list.=C2=A0 Subscription management and archives:<br>
<a href=3D"https://sympa.inria.fr/sympa/arc/caml-list" target=3D"_blank">ht=
tps://sympa.inria.fr/sympa/<u></u>arc/caml-list</a><br>
Beginner&#39;s list: <a href=3D"http://groups.yahoo.com/group/ocaml_beginne=
rs" target=3D"_blank">http://groups.yahoo.com/group/<u></u>ocaml_beginners<=
/a><br>
Bug reports: <a href=3D"http://caml.inria.fr/bin/caml-bugs" target=3D"_blan=
k">http://caml.inria.fr/bin/caml-<u></u>bugs</a><br>
</div></div></blockquote></div><br></div>

--bcaec53d592ffa55320512bcd761--
