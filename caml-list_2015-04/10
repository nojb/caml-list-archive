Return-Path: <frederic.bour@lakaban.net>
X-Original-To: caml-list@sympa.inria.fr
Delivered-To: caml-list@sympa.inria.fr
Received: from mail3-relais-sop.national.inria.fr (mail3-relais-sop.national.inria.fr [192.134.164.104])
	by sympa.inria.fr (Postfix) with ESMTPS id 15C077FCEF
	for <caml-list@sympa.inria.fr>; Thu,  2 Apr 2015 15:01:51 +0200 (CEST)
Received-SPF: None (mail3-smtp-sop.national.inria.fr: no sender
  authenticity information available from domain of
  frederic.bour@lakaban.net) identity=pra;
  client-ip=213.251.185.180;
  receiver=mail3-smtp-sop.national.inria.fr;
  envelope-from="frederic.bour@lakaban.net";
  x-sender="frederic.bour@lakaban.net";
  x-conformance=sidf_compatible
Received-SPF: Pass (mail3-smtp-sop.national.inria.fr: domain of
  frederic.bour@lakaban.net designates 213.251.185.180 as
  permitted sender) identity=mailfrom;
  client-ip=213.251.185.180;
  receiver=mail3-smtp-sop.national.inria.fr;
  envelope-from="frederic.bour@lakaban.net";
  x-sender="frederic.bour@lakaban.net";
  x-conformance=sidf_compatible; x-record-type="v=spf1"
Received-SPF: None (mail3-smtp-sop.national.inria.fr: no sender
  authenticity information available from domain of
  postmaster@mail.lakaban.net) identity=helo;
  client-ip=213.251.185.180;
  receiver=mail3-smtp-sop.national.inria.fr;
  envelope-from="frederic.bour@lakaban.net";
  x-sender="postmaster@mail.lakaban.net";
  x-conformance=sidf_compatible
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: A0BXBgAfPR1V/7S5+9UbATcJg1pcgk9GsjKQG4VzAoIPAQEBAQEBfoQfAQUMFx0BASwKAQEPCQIYCQQSCAMCAgkDAgECATMBEQYNAQUCAQEOiAkDFQmXZUicDHCEYgEFjXcDhU4BAQEHAQEBAQEBFgaLKYQdXAcJgl+BRYUVColBgWyEGIQKgx4RKYU3iXKDSCKDcG2CQwEBAQ
X-IPAS-Result: A0BXBgAfPR1V/7S5+9UbATcJg1pcgk9GsjKQG4VzAoIPAQEBAQEBfoQfAQUMFx0BASwKAQEPCQIYCQQSCAMCAgkDAgECATMBEQYNAQUCAQEOiAkDFQmXZUicDHCEYgEFjXcDhU4BAQEHAQEBAQEBFgaLKYQdXAcJgl+BRYUVColBgWyEGIQKgx4RKYU3iXKDSCKDcG2CQwEBAQ
X-IronPort-AV: E=Sophos;i="5.11,511,1422918000"; 
   d="scan'208,217";a="108062232"
Received: from pepper.lakaban.net (HELO mail.lakaban.net) ([213.251.185.180])
  by mail3-smtp-sop.national.inria.fr with ESMTP; 02 Apr 2015 15:01:49 +0200
Received: from [192.168.1.17] (mtg91-4-78-206-197-34.fbx.proxad.net [78.206.197.34])
	(Authenticated sender: defre@ygg-drasil.fr)
	by mail.lakaban.net (Postfix) with ESMTPSA id 1CD243CDC28;
	Thu,  2 Apr 2015 12:55:04 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=simple/simple; d=lakaban.net;
	s=default; t=1427979306;
	bh=nhpeENH9G5jiMyd+C9Mxjl4iMmcuoycg+tUFkdg0QZc=;
	h=Date:From:To:CC:Subject:References:In-Reply-To:From;
	b=jVDsoGL1ovD0DvUS3mgN3t+k9mEDywR459LW3QdprLGcVPy37cKgJmS7dnesqVxvt
	 GQDjDnBLqGFE0mAZn7XZhZ0xVisbW494eOuixfpSNDzE86jAM2edKNT3INDi14Wb0m
	 C63pGfMX8srBmc+ZbPcK/oPHnxZX/8ATjRU6evl8=
Message-ID: <551D3CF4.8050101@lakaban.net>
Date: Thu, 02 Apr 2015 14:58:28 +0200
From: =?UTF-8?B?RnLDqWTDqXJpYyBCb3Vy?= <frederic.bour@lakaban.net>
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:31.0) Gecko/20100101 Thunderbird/31.5.0
MIME-Version: 1.0
To: Anthony Tavener <anthony.tavener@gmail.com>
CC: "caml-list@inria.fr" <caml-list@inria.fr>
References: <551C55F4.5080703@lakaban.net>	<551D1C29.5010808@lakaban.net> <CAN=ouMS8GxopBUuuwn_GKR62fdL7H9o+S3LBPcA_NunX85YKrQ@mail.gmail.com>
In-Reply-To: <CAN=ouMS8GxopBUuuwn_GKR62fdL7H9o+S3LBPcA_NunX85YKrQ@mail.gmail.com>
Content-Type: multipart/alternative;
 boundary="------------030109030604030009070708"
Subject: Re: [Caml-list] [ANN] OCamp - Reactive programming in the shell

This is a multi-part message in MIME format.
--------------030109030604030009070708
Content-Type: text/plain; charset=utf-8; format=flowed
Content-Transfer-Encoding: 8bit

I am trying to specialize in /elaborate jokes/ :).

The idea and implementation started as a joke… But with some hindsight, 
this might not be completely inappropriate.
In any case the current implementation is really just a proof of 
concept, not to be trusted at all.

On 02/04/2015 14:19, Anthony Tavener wrote:
> Hah! You were serious? I thought with commands like hipp and stir, and 
> your legal review notice at the end, that this was an April Fool's 
> joke. :)
>
> On Thu, Apr 2, 2015 at 12:38 PM, Frédéric Bour 
> <frederic.bour@lakaban.net <mailto:frederic.bour@lakaban.net>> wrote:
>
>     Code is finally available at:
>     https://github.com/def-lkb/ocamp
>
>     Sorry for the little delay!
>
>
>     On 01/04/2015 22:32, Frédéric Bour wrote:
>
>         OCamp extends unix shells with constructions to express
>         memoization, sharing of computations and reactive programming.
>
>         # Subcommands
>
>         ## fire
>
>         Just wrap a unix command with "ocamp fire" to enable the
>         extension:
>           $ ocamp fire bash
>
>         This will spawn a new bash session where the following
>         subcommands are enabled.
>
>         ## hipp
>
>           $ ocamp hipp <command>
>
>         Will memoize the output and exit status of <command>.
>         Later calls to the same <command> won't lead to actual
>         execution, but just to a duplication of its previous output.
>         Concurrent calls to <command> will just share the same
>         process, the beginning of the output being replayed to later
>         callers.
>
>         The identity of a command is defined by its arguments and
>         working directory.
>
>         ## stir
>
>           $ ocamp stir <command>
>
>         Indicate potential changes in the output if <command> was rerun.
>         Later calls to `hipp` will recompute <command> as if it was
>         not yet memoized.
>
>         ## (un)follow
>
>           $ ocamp follow <command>
>
>         First, <command> is memoized if it was not the case yet.
>         Then changes to dependencies of <command> will trigger a
>         reevaluation.
>         Use `stir` to notify a change.
>
>         (to follow is an hipp/stir reactivity).
>
>         ## pull
>
>           $ ocamp pull <command>
>
>         Closely related to `hipp`, but instead of marking dependency
>         on the output of <command>, the dependency applies to the
>         "effects" of <command>.
>
>         Thus, if `stir` is used:
>         - all pullers will be reevaluated.
>         - hippers will be reevaluated only if the output is different.
>
>         ## Summary
>
>           $ ocamp fire <command> - setup a new session alive until
>         <command> exits
>                   pull <command> - mark dependency on effects of <command>
>                   hipp <command> - mark dependency on output of <command>
>                   stir <command> - notify that <command> might have
>         been updated
>                   follow <command> - eval <command>, and reactively
>         recompute it
>                                      whenever one of its dependencies
>         change.
>                   unfollow <command> - stop recomputing <command> when
>         dependencies
>                                        change
>
>         hipp and pull provide memoization.
>         stir and follow bring a flavor of reactive programming.
>
>         # Examples
>
>         ## Fibonacci
>
>           $ cat fib.sh
>           #!/bin/sh
>           ARG="$1"
>           if [ "$ARG" -le 1 ]; then
>             echo "$ARG"
>           else
>             A=`ocamp hipp ./fib.sh $((ARG-1))`
>             B=`ocamp hipp ./fib.sh $((ARG-2))`
>             echo $((A+B))
>           fi
>
>           $ time ocamp fire ./fib.sh 50
>           12586269025
>             real    0m0.391s
>           user    0m0.153s
>           sys     0m0.060s
>
>         ## Build-system
>
>         `ocamp` provides simple primitives to construct and manage a
>         dependency graph.
>
>         This might be a saner foundation to base a build-system on
>         than make(1):
>         - the command focus on one specific problem
>         - no dsl is involved; rules can be plain unix commands,
>         including a shell, rather than a make-flavored simulation of shell
>         - nothing is provided for resolving goals; indeed this is
>         better left to tools specifically built for goal-search.
>
>         A quick'n'dirty script building ocamp itself is provided as an
>         example.
>
>         # Future
>
>         The current release is a proof-of-concept and should be
>         considered alpha quality.
>         The two features planned next are a way to make the graph
>         persistent (all data is kept in memory atm) and an interface
>         to debug and/or observe graph construction.
>
>         Note: code is undergoing legal review and should be available
>         soon \o/
>
>
>
>     -- 
>     Caml-list mailing list.  Subscription management and archives:
>     https://sympa.inria.fr/sympa/arc/caml-list
>     Beginner's list: http://groups.yahoo.com/group/ocaml_beginners
>     Bug reports: http://caml.inria.fr/bin/caml-bugs
>
>


--------------030109030604030009070708
Content-Type: text/html; charset=utf-8
Content-Transfer-Encoding: 8bit

<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
  </head>
  <body text="#000000" bgcolor="#FFFFFF">
    I am trying to specialize in <i>elaborate jokes</i> :).<br>
    <br>
    The idea and implementation started as a joke… But with some
    hindsight, this might not be completely inappropriate.<br>
    In any case the current implementation is really just a proof of
    concept, not to be trusted at all.<br>
    <br>
    <div class="moz-cite-prefix">On 02/04/2015 14:19, Anthony Tavener
      wrote:<br>
    </div>
    <blockquote
cite="mid:CAN=ouMS8GxopBUuuwn_GKR62fdL7H9o+S3LBPcA_NunX85YKrQ@mail.gmail.com"
      type="cite">
      <div dir="ltr">Hah! You were serious? I thought with commands like
        hipp and stir, and your legal review notice at the end, that
        this was an April Fool's joke. :)<br>
      </div>
      <div class="gmail_extra"><br>
        <div class="gmail_quote">On Thu, Apr 2, 2015 at 12:38 PM,
          Frédéric Bour <span dir="ltr">&lt;<a moz-do-not-send="true"
              href="mailto:frederic.bour@lakaban.net" target="_blank">frederic.bour@lakaban.net</a>&gt;</span>
          wrote:<br>
          <blockquote class="gmail_quote" style="margin:0 0 0
            .8ex;border-left:1px #ccc solid;padding-left:1ex">Code is
            finally available at:<br>
                <a moz-do-not-send="true"
              href="https://github.com/def-lkb/ocamp" target="_blank">https://github.com/def-lkb/ocamp</a><br>
            <br>
            Sorry for the little delay!
            <div class="HOEnZb">
              <div class="h5"><br>
                <br>
                On 01/04/2015 22:32, Frédéric Bour wrote:<br>
                <blockquote class="gmail_quote" style="margin:0 0 0
                  .8ex;border-left:1px #ccc solid;padding-left:1ex">
                  OCamp extends unix shells with constructions to
                  express memoization, sharing of computations and
                  reactive programming.<br>
                  <br>
                  # Subcommands<br>
                  <br>
                  ## fire<br>
                  <br>
                  Just wrap a unix command with "ocamp fire" to enable
                  the extension:<br>
                    $ ocamp fire bash<br>
                  <br>
                  This will spawn a new bash session where the following
                  subcommands are enabled.<br>
                  <br>
                  ## hipp<br>
                  <br>
                    $ ocamp hipp &lt;command&gt;<br>
                  <br>
                  Will memoize the output and exit status of
                  &lt;command&gt;.<br>
                  Later calls to the same &lt;command&gt; won't lead to
                  actual execution, but just to a duplication of its
                  previous output.<br>
                  Concurrent calls to &lt;command&gt; will just share
                  the same process, the beginning of the output being
                  replayed to later callers.<br>
                  <br>
                  The identity of a command is defined by its arguments
                  and working directory.<br>
                  <br>
                  ## stir<br>
                  <br>
                    $ ocamp stir &lt;command&gt;<br>
                  <br>
                  Indicate potential changes in the output if
                  &lt;command&gt; was rerun.<br>
                  Later calls to `hipp` will recompute &lt;command&gt;
                  as if it was not yet memoized.<br>
                  <br>
                  ## (un)follow<br>
                  <br>
                    $ ocamp follow &lt;command&gt;<br>
                  <br>
                  First, &lt;command&gt; is memoized if it was not the
                  case yet.<br>
                  Then changes to dependencies of &lt;command&gt; will
                  trigger a reevaluation.<br>
                  Use `stir` to notify a change.<br>
                  <br>
                  (to follow is an hipp/stir reactivity).<br>
                  <br>
                  ## pull<br>
                  <br>
                    $ ocamp pull &lt;command&gt;<br>
                  <br>
                  Closely related to `hipp`, but instead of marking
                  dependency on the output of &lt;command&gt;, the
                  dependency applies to the "effects" of
                  &lt;command&gt;.<br>
                  <br>
                  Thus, if `stir` is used:<br>
                  - all pullers will be reevaluated.<br>
                  - hippers will be reevaluated only if the output is
                  different.<br>
                  <br>
                  ## Summary<br>
                  <br>
                    $ ocamp fire &lt;command&gt; - setup a new session
                  alive until &lt;command&gt; exits<br>
                            pull &lt;command&gt; - mark dependency on
                  effects of &lt;command&gt;<br>
                            hipp &lt;command&gt; - mark dependency on
                  output of &lt;command&gt;<br>
                            stir &lt;command&gt; - notify that
                  &lt;command&gt; might have been updated<br>
                            follow &lt;command&gt; - eval
                  &lt;command&gt;, and reactively recompute it<br>
                                               whenever one of its
                  dependencies change.<br>
                            unfollow &lt;command&gt; - stop recomputing
                  &lt;command&gt; when dependencies<br>
                                                 change<br>
                  <br>
                  hipp and pull provide memoization.<br>
                  stir and follow bring a flavor of reactive
                  programming.<br>
                  <br>
                  # Examples<br>
                  <br>
                  ## Fibonacci<br>
                  <br>
                    $ cat fib.sh<br>
                    #!/bin/sh<br>
                    ARG="$1"<br>
                    if [ "$ARG" -le 1 ]; then<br>
                      echo "$ARG"<br>
                    else<br>
                      A=`ocamp hipp ./fib.sh $((ARG-1))`<br>
                      B=`ocamp hipp ./fib.sh $((ARG-2))`<br>
                      echo $((A+B))<br>
                    fi<br>
                  <br>
                    $ time ocamp fire ./fib.sh 50<br>
                    12586269025<br>
                      real    0m0.391s<br>
                    user    0m0.153s<br>
                    sys     0m0.060s<br>
                  <br>
                  ## Build-system<br>
                  <br>
                  `ocamp` provides simple primitives to construct and
                  manage a dependency graph.<br>
                  <br>
                  This might be a saner foundation to base a
                  build-system on than make(1):<br>
                  - the command focus on one specific problem<br>
                  - no dsl is involved; rules can be plain unix
                  commands, including a shell, rather than a
                  make-flavored simulation of shell<br>
                  - nothing is provided for resolving goals; indeed this
                  is better left to tools specifically built for
                  goal-search.<br>
                  <br>
                  A quick'n'dirty script building ocamp itself is
                  provided as an example.<br>
                  <br>
                  # Future<br>
                  <br>
                  The current release is a proof-of-concept and should
                  be considered alpha quality.<br>
                  The two features planned next are a way to make the
                  graph persistent (all data is kept in memory atm) and
                  an interface to debug and/or observe graph
                  construction.<br>
                  <br>
                  Note: code is undergoing legal review and should be
                  available soon \o/<br>
                  <br>
                </blockquote>
                <br>
                <br>
                -- <br>
                Caml-list mailing list.  Subscription management and
                archives:<br>
                <a moz-do-not-send="true"
                  href="https://sympa.inria.fr/sympa/arc/caml-list"
                  target="_blank">https://sympa.inria.fr/sympa/arc/caml-list</a><br>
                Beginner's list: <a moz-do-not-send="true"
                  href="http://groups.yahoo.com/group/ocaml_beginners"
                  target="_blank">http://groups.yahoo.com/group/ocaml_beginners</a><br>
                Bug reports: <a moz-do-not-send="true"
                  href="http://caml.inria.fr/bin/caml-bugs"
                  target="_blank">http://caml.inria.fr/bin/caml-bugs</a><br>
              </div>
            </div>
          </blockquote>
        </div>
        <br>
      </div>
    </blockquote>
    <br>
  </body>
</html>

--------------030109030604030009070708--
