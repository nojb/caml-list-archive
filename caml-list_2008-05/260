Return-Path: <berke.durak@gmail.com>
X-Spam-Checker-Version: SpamAssassin 3.1.3 (2006-06-01) on yquem.inria.fr
X-Spam-Level: 
X-Spam-Status: No, score=0.2 required=5.0 tests=AWL,HTML_MESSAGE 
	autolearn=disabled version=3.1.3
X-Original-To: caml-list@yquem.inria.fr
Delivered-To: caml-list@yquem.inria.fr
Received: from mail4-relais-sop.national.inria.fr (mail4-relais-sop.national.inria.fr [192.134.164.105])
	by yquem.inria.fr (Postfix) with ESMTP id DD380BB84
	for <caml-list@yquem.inria.fr>; Mon, 19 May 2008 14:24:28 +0200 (CEST)
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: AosHAEAOMUjRVcbkY2dsb2JhbACCNzaPOBcDBAQJDpUEhB0
X-IronPort-AV: E=Sophos;i="4.27,509,1204498800"; 
   d="scan'208";a="26341082"
Received: from discorde.inria.fr ([192.93.2.38])
  by mail4-smtp-sop.national.inria.fr with ESMTP; 19 May 2008 14:24:28 +0200
Received: from mail4-relais-sop.national.inria.fr (mail4-relais-sop.national.inria.fr [192.134.164.105])
	by discorde.inria.fr (8.13.6/8.13.6) with ESMTP id m4JCOSfe017910
	(version=TLSv1/SSLv3 cipher=RC4-SHA bits=128 verify=OK)
	for <caml-list@inria.fr>; Mon, 19 May 2008 14:24:28 +0200
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: AosHAEAOMUjRVcbkY2dsb2JhbACCNzaPOBcDBAQJDpUEhB0
X-IronPort-AV: E=Sophos;i="4.27,509,1204498800"; 
   d="scan'208";a="26341078"
Received: from rv-out-0506.google.com ([209.85.198.228])
  by mail4-smtp-sop.national.inria.fr with ESMTP; 19 May 2008 14:24:26 +0200
Received: by rv-out-0506.google.com with SMTP id k40so1136460rvb.57
        for <caml-list@inria.fr>; Mon, 19 May 2008 05:24:26 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=gamma;
        h=domainkey-signature:received:received:message-id:date:from:to:subject:cc:in-reply-to:mime-version:content-type:references;
        bh=Ncc23w2cvaIsHG50jKDbiKQvzOOsFePfw33dH4JXKOU=;
        b=UWOj6LQDh8jL6l1yQmVO2gZU5htVox2C5RpTpkAlhxiihlb7liHzXS+vP1KgT4dAGHjlFYedpzoaoS9m5SgjqcT1qhRDIi9D74nvQIc+RDvDxxE7sp0NrH6wiSstxsJNhK6ROdQLwIad5/jAP6ZEXOht8SJjD4sjKRdPXeWEvD0=
DomainKey-Signature: a=rsa-sha1; c=nofws;
        d=gmail.com; s=gamma;
        h=message-id:date:from:to:subject:cc:in-reply-to:mime-version:content-type:references;
        b=IwQ8Rxc4frIW0NHLrZlQNS/U4OWAw2o9t13gSun6f5Op8qnED74cVOVXYCLrdhCIPeY9c6IenF93dlbHGDPOPaD8qte8rG77GIcXwB3t/t0gg/1wsAZf66nDfHDLjNCYPBQjPXC+zZuE2qhnLd4jMvrhfvT+0nX8IiM01Z3Lsec=
Received: by 10.141.178.5 with SMTP id f5mr3628955rvp.112.1211199866058;
        Mon, 19 May 2008 05:24:26 -0700 (PDT)
Received: by 10.140.172.2 with HTTP; Mon, 19 May 2008 05:24:26 -0700 (PDT)
Message-ID: <b903a8570805190524y64154ce0x758571764813bf79@mail.gmail.com>
Date: Mon, 19 May 2008 14:24:26 +0200
From: "Berke Durak" <berke.durak@gmail.com>
To: "Martin Berger" <M.Berger@doc.ic.ac.uk>
Subject: Re: [Caml-list] Re: Where's my non-classical shared memory concurrency technology?
Cc: caml-list@inria.fr, "Jon Harrop" <jon@ffconsultancy.com>
In-Reply-To: <4831686F.8010903@doc.ic.ac.uk>
MIME-Version: 1.0
Content-Type: multipart/alternative; 
	boundary="----=_Part_13852_12551853.1211199866050"
References: <b903a8570805180139i7dfe7526u799e82d5126c9f3@mail.gmail.com>
	 <200805181735.50621.jon@ffconsultancy.com>
	 <4831686F.8010903@doc.ic.ac.uk>
X-Miltered: at discorde with ID 4831717C.000 by Joe's j-chkmail (http://j-chkmail . ensmp . fr)!
X-Spam: no; 0.00; berke:01 durak:01 berke:01 durak:01 fairness:01 non-trivial:01 monadic:01 event-based:01 bug:01 statically:01 high-level:01 statically:01 higher-order:01 model:01 monadic:01 
X-Attachments: cset="UTF-8" cset="UTF-8" 

------=_Part_13852_12551853.1211199866050
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

On Mon, May 19, 2008 at 1:45 PM, Martin Berger <M.Berger@doc.ic.ac.uk>
wrote:

> Jon Harrop wrote:
>
>  Similarly, avoiding threads removes concurrency bugs...
>>>
>>
>  I don't believe you have removed any concurrency bugs. I think you just
>> pushed them around a bit.
>>
>
> I couldn't agree more. If you 'avoid' concurrency by writing your own
> 'sequential' event handling code, you have not removed the concurrency,
> you just face it in a slightly different form, and you have to
> program the event handling code yourself, rather than relying
> on a tried and tested library, i.e. you have an additional
> source of bugs, without removing the problems that are inherent
> in concurrency (e.g. deadlocks, livelocks, fairness ...). There
> are reasons why writing your own concurrency mechanisms might
> be the way to go, but it's a highly non-trivial endeavor.


Let's say that there are two kinds of concurrency bugs : consistency bugs
and
synchronization bugs.

- Consistency bugs arise when two or more threads mutate the same
datastructure concurrently,
leading to inconsistent data.

- Synchronization bugs occur when you have things like starvation (a queue
with waiter never gets filled),
unfairness (some code almost never gets a chance to run), deadlocking (ye
olde deadlock), livelocking
(threads spend time communicating back and forth without making progress),
etc.

Avoiding threads means to me that you're either using Lwt-style monadic
threads, or an event-based
framework (the two being similar).

Avoiding threads almost eliminates consistency bugs.

Code you write is, by default, atomic.  Concurrency must be explicitly
invoked, and
generally shows in the types of functions using concurrency (one of the
situations where monad
creep seems to be a good thing.)

If you take a data structure that was not intended for concurrency, then it
will almost certainly be
concurrency-safe unless it is some kind of structure that can store thunks
and invoke them, and
you store concurrency-producing thunks in them.

Hence, using, say, Lwt, I can have tens of thousands of lightweight threads
that happily mutate
an unprotected, possibly complex datastructure implemented in a
concurrency-agnostic module.
For instance, I can and do use a global reference to a Map module and mutate
it without any lock
of any kind.

Now let me classify synchronization bugs in two sorts :
  - Type A: Logical synchronization bugs due to algorithmic issues
(livelocks, etc.)
  - Type B: Synchronization bugs due to consistency bug avoidance
techniques,

Short of a formal system where concurrency properties are statically proven,
you probably can't
avoid type A bugs, since it's a high-level correctness issue.

Take for instance two mutually-recursive functions calling themselves using
an inter-process mechanism.
If they were supposed to terminate, it's a livelock, otherwise - if they are
some kind of persistent client-server
combination, they are running as usual.  Yet they will be using the same
primitives.

So no one expects logical synchronization bugs to be statically detected.

Type B bugs typically occur when you or someone else peppers code with
locks/unlock pairs (or "synchronized"
attributes, or "perform_under_lock" higher-order function...) and get a
deadlock.

While some type B bugs can be dynamically (and even statically) detected, or
some lock/unlock pairs be
removed by your JIT, others type B bugs will slip thru: even if you maintain
some kind of dependency graph
between locks, as you cannot model a synchronization effect conditioned on
another lock if the unlocking goes
thru a piece of unknown code.

If you avoid threads, type A bugs become much less likely.  Hence you won't
need to wrap almost
every shared datastructure with locks to prevent them, and hence you will
avoid a lot of type B bugs.

In short, with monadic threads, you can safely invoke non-concurrent code
from concurrent code.  (The inverse
can be dangerous - but you usually don't do this anyway since you will end
up optaining an 'a Lwt.t).
This means that locking is almost never needed and hence your code is
safer.  Sequential, yes, but safer.
-- 
Berke Durak

------=_Part_13852_12551853.1211199866050
Content-Type: text/html; charset=UTF-8
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

On Mon, May 19, 2008 at 1:45 PM, Martin Berger &lt;<a href="mailto:M.Berger@doc.ic.ac.uk">M.Berger@doc.ic.ac.uk</a>&gt; wrote:<br><div class="gmail_quote"><blockquote class="gmail_quote" style="border-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;">
<div class="Ih2E3d">Jon Harrop wrote:<br>
<br>
<blockquote class="gmail_quote" style="border-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;"><blockquote class="gmail_quote" style="border-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;">

Similarly, avoiding threads removes concurrency bugs...<br>
</blockquote></blockquote>
<br>
</div><div class="Ih2E3d"><blockquote class="gmail_quote" style="border-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;">
I don&#39;t believe you have removed any concurrency bugs. I think you just pushed them around a bit.<br>
</blockquote>
<br></div>
I couldn&#39;t agree more. If you &#39;avoid&#39; concurrency by writing your own<br>
&#39;sequential&#39; event handling code, you have not removed the concurrency,<br>
you just face it in a slightly different form, and you have to<br>
program the event handling code yourself, rather than relying<br>
on a tried and tested library, i.e. you have an additional<br>
source of bugs, without removing the problems that are inherent<br>
in concurrency (e.g. deadlocks, livelocks, fairness ...). There<br>
are reasons why writing your own concurrency mechanisms might<br>
be the way to go, but it&#39;s a highly non-trivial endeavor.</blockquote><div><br>Let&#39;s say that there are two kinds of concurrency bugs : consistency bugs and<br>synchronization bugs.<br><br>- Consistency bugs arise when two or more threads mutate the same datastructure concurrently,<br>
leading to inconsistent data.<br><br>- Synchronization bugs occur when you have things like starvation (a queue with waiter never gets filled),<br>unfairness (some code almost never gets a chance to run), deadlocking (ye olde deadlock), livelocking<br>
(threads spend time communicating back and forth without making progress), etc.<br><br>Avoiding threads means to me that you&#39;re either using Lwt-style monadic threads, or an event-based<br>framework (the two being similar).<br>
<br>Avoiding threads almost eliminates consistency bugs.<br><br>Code you write is, by default, atomic.&nbsp; Concurrency must be explicitly invoked, and<br>generally shows in the types of functions using concurrency (one of the situations where monad<br>
creep seems to be a good thing.)<br><br>If you take a data structure that was not intended for concurrency, then it will almost certainly be<br>concurrency-safe unless it is some kind of structure that can store thunks and invoke them, and<br>
you store concurrency-producing thunks in them.<br><br>Hence, using, say, Lwt, I can have tens of thousands of lightweight threads that happily mutate<br>an unprotected, possibly complex datastructure implemented in a concurrency-agnostic module.<br>
For instance, I can and do use a global reference to a Map module and mutate it without any lock<br>of any kind.<br><br></div><div>Now let me classify synchronization bugs in two sorts :<br>&nbsp; - Type A: Logical synchronization bugs due to algorithmic issues (livelocks, etc.)<br>
&nbsp; - Type B: Synchronization bugs due to consistency bug avoidance techniques,<br><br>Short of a formal system where concurrency properties are statically proven, you probably can&#39;t<br>avoid type A bugs, since it&#39;s a high-level correctness issue.<br>
<br>Take for instance two mutually-recursive functions calling themselves using an inter-process mechanism.<br>If they were supposed to terminate, it&#39;s a livelock, otherwise - if they are some kind of persistent client-server<br>
combination, they are running as usual.&nbsp; Yet they will be using the same primitives.<br><br>So no one expects logical synchronization bugs to be statically detected.<br><br>Type B bugs typically occur when you or someone else peppers code with locks/unlock pairs (or &quot;synchronized&quot;<br>
attributes, or &quot;perform_under_lock&quot; higher-order function...) and get a deadlock.<br><br>While some type B bugs can be dynamically (and even statically) detected, or some lock/unlock pairs be<br>removed by your JIT, others type B bugs will slip thru: even if you maintain some kind of dependency graph<br>
between locks, as you cannot model a synchronization effect conditioned on another lock if the unlocking goes<br>thru a piece of unknown code.<br><br>If you avoid threads, type A bugs become much less likely.&nbsp; Hence you won&#39;t need to wrap almost<br>
every shared datastructure with locks to prevent them, and hence you will avoid a lot of type B bugs.<br><br>In short, with monadic threads, you can safely invoke non-concurrent code from concurrent code.&nbsp; (The inverse<br>
can be dangerous - but you usually don&#39;t do this anyway since you will end up optaining an &#39;a Lwt.t).<br>This means that locking is almost never needed and hence your code is safer.&nbsp; Sequential, yes, but safer.<br>
</div></div>-- <br>Berke Durak<br><br>

------=_Part_13852_12551853.1211199866050--

