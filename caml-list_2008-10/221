Return-Path: <Tiphaine.Turpin@irisa.fr>
X-Spam-Checker-Version: SpamAssassin 3.1.3 (2006-06-01) on yquem.inria.fr
X-Spam-Level: 
X-Spam-Status: No, score=0.0 required=5.0 tests=none autolearn=disabled 
	version=3.1.3
X-Original-To: caml-list@yquem.inria.fr
Delivered-To: caml-list@yquem.inria.fr
Received: from mail1-relais-roc.national.inria.fr (mail1-relais-roc.national.inria.fr [192.134.164.82])
	by yquem.inria.fr (Postfix) with ESMTP id 3504DBBAF
	for <caml-list@yquem.inria.fr>; Fri, 17 Oct 2008 10:17:32 +0200 (CEST)
X-IronPort-AV: E=Sophos;i="4.33,430,1220220000"; 
   d="scan'208";a="18851982"
Received: from arvin.irisa.fr (HELO [131.254.11.86]) ([131.254.11.86])
  by mail1-relais-roc.national.inria.fr with ESMTP/TLS/DHE-RSA-AES256-SHA; 17 Oct 2008 10:17:32 +0200
Message-ID: <48F848CB.6060404@irisa.fr>
Date: Fri, 17 Oct 2008 10:11:55 +0200
From: Tiphaine Turpin <Tiphaine.Turpin@irisa.fr>
User-Agent: Thunderbird 1.5.0.10 (X11/20070303)
MIME-Version: 1.0
To: caml-list@yquem.inria.fr
Subject: Re: [Caml-list] Quantifier in the type
References: <48F60638.6040101@uj.edu.pl>	<200810152018.26396.fmonnier@linux-nantes.fr.eu.org> <48F75EE5.6030009@uj.edu.pl>
In-Reply-To: <48F75EE5.6030009@uj.edu.pl>
Content-Type: text/plain; charset=ISO-8859-1; format=flowed
Content-Transfer-Encoding: 8bit
X-Spam: no; 0.00; irisa:01 quantifier:01 semantics:01 val:01 semantics:01 mli:01 subtyping:01 quantified:01 quantified:01 explicitely:01 val:01 ocaml:01 mli:01 quantifier:01 plural:01 

Hi,

I will try to expose my understanding anout your worries.

First, an interface (say I), also called a module type, is something 
whose semantics is a set of fields, which can be of several kinds: type, 
module, module type, etc., and, of course, value. In this last case, the 
statement val v : t declares that I has a "value" field v of type t, 
with the intuitive semantics that "any module of type I must export a 
value v which satisfies the type t". Then, when you compile your 
implementation m.ml and interface m.mli files together (they both have 
the same name but belong to different name spaces), it's like doing:

module M = (M : M)

i.e., it expresses a subtyping. So, module M must match module type M 
(their respective fields must match, including "value" fields in 
particular) and then, module M is "redifined" so that its type is only 
assumed to be the module type M (even if the module M had a more precise 
type, for example had more fields), for subsequent use.

So, I think the word value refers to the kind of field in your error 
message. You have exactly two fields of type value, one in the module 
type, and the other one in the module. Of course, the fields of a module 
type are given a type, but no implementation.

Second, in interfaces, type variables appearing in a value declaration 
are implicitely universally quantified (at the beginning of the 
declaration). In implementations, (at least for value definitions) they 
are existentially quantified, unless (explicitely) otherwise stated.

Hope this helps,

Tiphaine


Dawid Toton a écrit :
> Thanks for your answer; now I'll try to sate my point in a clear way,
> since you misunderstood all my questions.
>
>>> I put 'a in the interface:
>>> val fu : 'a -> 'a
>>> and int in the implementation:
>>> let fu x = x + 1
>>
>> this interface doesn't reflect the implementation, ocaml will reject 
>> it in any way
>
> OK, it's all about this rejection, e.g. what does precisely mean 'to
> reflect the implementation'.
>
>>
>>> So I have universal quantification: for any type 'a function fu can
>>> consume the argument.
>>
>> No it is not universal, imagine all the types that a user can create, 
>> you cannot handle them all (except maybe with the Obj module, but 
>> it's another question)
>
> I wanted this my sentence to be about the declatation in mli interface.
> My point is: the type in the declaration in mli implicitly contains
> universal quantifier.
>
>
>>>                       So my implementation doesn't comply with that
>>> universal quatification. And the message I get is following:
>>>
>>> Values do not match: val fu : int -> int is not included in val fu : 'a
>>> -> 'a
>>
>> Yes it doesn't match at all, the type of the implementation is int, 
>> nothing else.
>
> The error message uses plural: 'Value*s* do not match'.
> So this raises few questions:
> 1) Is (fun x -> x + 1) a value?
> 2) Is (x + 1) a value?
> 3) Is the whole line " val fu : 'a -> 'a " a value?
> 4) How many values are in my example?
>
> We have to find at least two, to understand the error message!
>
> An my conlcusion is that this is just silly, unimportant mistake:
>
>>> So the declaration of value in mli file is called simply a 'value'. Is
>>> it intentional?
>>
>> It is just the word in the English language to designate this thing.
>
> What do you mean saying 'this thing'?
> The point is: *which thing*?
>
>>> I thought that value and it's declaration are separate notions?
>
> Are they separate in OCaml or not?
> (Of course, everybody knows they have to be separate, that's why I'm
> asking about the word 'value'.)
>
>> a value is handle by a identifier and has a type
>>   let ident = some_value in
>> here ident and some_value are of some type
>
> So - according to your point of view - in my example there is only one
> value, which has identifier 'fu' and its type would be " 'a -> 'a " if
> the implementation was corrent.
> But, you remember, the error message was about *two* values.
>
>
>>
>>> My reading of " val fu : 'a -> 'a " is:
>>>  some partiular value vvv that belongs to set of values that satisfy
>>> "forall 'a : (vvv can be used with ('a -> 'a) type)"
>>
>>> But if I write
>>> let (bar : 'a -> 'a ) = (fun x -> x + 1)
>>> I create a value that belongs to set "exists 'a : (vvv can be used with
>>> ('a -> 'a) type)"
>>> So it's the other quantifier.
>>
>>> I think that the quantifier has to be part of type, since a type is set
>>> of values (and the quantifier plays important role when describing some
>>> of such sets).
>>> So my question is: since we see the same string " 'a -> 'a " that 
>>> refers
>>> to different types in different contexts, what are the rules? How is
>>> type definition in OCaml translated to a type?
>>
>> type definition in OCaml are translated to actual types by inference.
>> (fun x -> x + 1) will be easily infered to (int -> int)
>
> My question was what are the rules for putting universal and
> existential quantifers into types. So we have some type definition:
> 'a -> ('b -> 'c)
> How is it translated to a type?
>
> I have an idea that this piece of code can sometimes be not a type
> definition, but rather part of type equation.
> Let's take my previous example:
> let (bar : 'a -> 'a ) = ...
>
> This " 'a -> 'a " whould not define any type (so the problem of
> quantifiers would be irrelevant here), but RHS of some type equation.
> Still I'm not sure about what does this RHS contais (precisely).
>
> So: was I wrong thinking that existnetial quantifier is involved in this
> example?
>
> Dawid
>
> _______________________________________________
> Caml-list mailing list. Subscription management:
> http://yquem.inria.fr/cgi-bin/mailman/listinfo/caml-list
> Archives: http://caml.inria.fr
> Beginner's list: http://groups.yahoo.com/group/ocaml_beginners
> Bug reports: http://caml.inria.fr/bin/caml-bugs
>

