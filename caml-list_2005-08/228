Return-Path: <mukai@ayu.ics.keio.ac.jp>
X-Original-To: caml-list@yquem.inria.fr
Delivered-To: caml-list@yquem.inria.fr
Received: from nez-perce.inria.fr (nez-perce.inria.fr [192.93.2.78])
	by yquem.inria.fr (Postfix) with ESMTP id 414F0BDD9
	for <caml-list@yquem.inria.fr>; Fri, 26 Aug 2005 13:16:10 +0200 (CEST)
Received: from orion.ayu.ics.keio.ac.jp (orion.ayu.ics.keio.ac.jp [131.113.45.32])
	by nez-perce.inria.fr (8.13.0/8.13.0) with ESMTP id j7QBG8sh007855
	for <caml-list@yquem.inria.fr>; Fri, 26 Aug 2005 13:16:09 +0200
Received: from orion.ayu.ics.keio.ac.jp.ayu.ics.keio.ac.jp (localhost [127.0.0.1])
	by orion.ayu.ics.keio.ac.jp (Postfix) with ESMTP id 262902E058
	for <caml-list@yquem.inria.fr>; Fri, 26 Aug 2005 20:16:07 +0900 (JST)
Date: Fri, 26 Aug 2005 20:16:06 +0900
Message-ID: <kk5hddd3q4p.wl%mukai@ayu.ics.keio.ac.jp>
From: Jun Mukai <mukai@ayu.ics.keio.ac.jp>
To: caml-list@yquem.inria.fr
Subject: Re: [Caml-list] lazy lists
In-Reply-To: <20050826110454.GA21632@furbychan.cocan.org>
References: <ad8cfe7e05082516566803c65a@mail.gmail.com>
	<20050826110454.GA21632@furbychan.cocan.org>
User-Agent: User-Agent: Wanderlust/2.14.0 (Africa) Emacs/21.3 Mule/5.0 (SAKAKI)
Organization: Anzai and Imai Lab., Keio University, Yokohama, Japan
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=US-ASCII
X-Miltered: at nez-perce with ID 430EF9F8.000 by Joe's j-chkmail (http://j-chkmail.ensmp.fr)!
X-Spam: no; 0.00; caml-list:01 lazy:01 lazy:01 haskell:01 val:01 abstr:01 parser:01 val:01 confuses:01 ocaml:01 ocaml:01 haskell:01 tar:01 wrote:01 exception:01 
X-Spam-Checker-Version: SpamAssassin 3.0.3 (2005-04-27) on yquem.inria.fr
X-Spam-Level: 
X-Spam-Status: No, score=0.0 required=5.0 tests=none autolearn=disabled 
	version=3.0.3

Hi, Rich

> What you probably want are Streams (in camlp4).  This thread is
> interesting:

It is true that Stream is lazy evaluated, but Stream is not functional
at all. We cannot use Streams as same as lists in Haskell. For example,
--
# let s = [< '1 >];;
val s : int Stream.t = <abstr>
# let f = parser
  | [< 'n >] -> n
  | [< >] -> raise Not_found;;
val f : 'a Stream.t -> 'a = <fun>
# f s;;
- : int = 1
# f s;;
Exception: Not_found.
--

This code confuses many users (such like me).


BTW, I wrote a lazy list implementation in pure OCaml. It uses lazy
mechanism of OCaml and has some useful functions like haskell.
If you are interested in, see 
http://www.jmuk.org/prog/lazyList.tar.gz

The implementation is so naive that its performance will be low. And
it has no camlp4 extentions.
Feel free to use, but without any warranty.

Best Regards,
--
Jun Mukai

