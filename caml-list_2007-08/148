Return-Path: <nicolas.pouillard@gmail.com>
X-Spam-Checker-Version: SpamAssassin 3.1.3 (2006-06-01) on yquem.inria.fr
X-Spam-Level: *
X-Spam-Status: No, score=1.1 required=5.0 tests=AWL,SPF_NEUTRAL 
	autolearn=disabled version=3.1.3
X-Original-To: caml-list@yquem.inria.fr
Delivered-To: caml-list@yquem.inria.fr
Received: from discorde.inria.fr (discorde.inria.fr [192.93.2.38])
	by yquem.inria.fr (Postfix) with ESMTP id 3E360BC6B
	for <caml-list@yquem.inria.fr>; Thu,  9 Aug 2007 20:35:21 +0200 (CEST)
Received: from ausone.inria.fr (peray.inria.fr [128.93.8.98])
	by discorde.inria.fr (8.13.6/8.13.6) with SMTP id l79IZHjd010809;
	Thu, 9 Aug 2007 20:35:17 +0200
Received: by ausone.inria.fr (sSMTP sendmail emulation); Thu, _d Aug 2007 20:34:55 +0200
From: "Nicolas Pouillard" <nicolas.pouillard@gmail.com>
Cc: "O'Caml Mailing List" <caml-list@yquem.inria.fr>
Subject: Re: [Caml-list] ocamlbuild and bootstrapping projects
To: Erick Tryzelaar <erickt@dslextreme.com>
References: <6b94a12183a2ab7a191d6a.20070804031527.revpxg@www.dslextreme.com> <46B6F3C4.7050408@dslextreme.com>
In-Reply-To: <46B6F3C4.7050408@dslextreme.com>
Date: Thu, 09 Aug 2007 20:34:55 +0200
Message-Id: <1186684491-sup-8651@ert.local>
User-Agent: Sup/0.1.$Revision:$
Content-Disposition: inline
Content-Type: text/plain; charset=utf-8
X-j-chkmail-Score: MSGID : 46BB5E65.000 on discorde : j-chkmail score : X : 0/20 1 0.000 -> 1
X-Miltered: at discorde with ID 46BB5E65.000 by Joe's j-chkmail (http://j-chkmail . ensmp . fr)!
X-Spam: no; 0.00; parser:01 parser:01 mli:01 deps:01 mli:01 pathname:01 ocaml:01 byte:01 iter:01 exn:01 exn:01 iter:01 wrote:01 dynamically:01 caml-list:01 

Your solution is quite good and follows ocamlbuild principles.

Excerpts from Erick Tryzelaar's message of Mon Aug 06 12:11:16 +0200 2007:
> erickt@dslextreme.com wrote:
> > I was trying to adapt the parser dypgen (http://dypgen.free.fr/)'s build
> > system to use ocamlbuild, but I ran into a problem. The final dypgen
> > grammar is generated by an internal intermediary generator called pgen.
> > The problem I'm having is that I don't know how to get ocamlbuild to
> > automatically build pgen before we can process a %.dyp file. I suppose I
> > could do this in two separate calls to ocamlbuild, but I feel like this
> > can be done using a plugin. Is this possible?
> 
> For those that are interested, here's the solution I came up with. We 
> use the "build" function we get in the rule to dynamically dispatch the 
> building of the parser if we haven't generated it yet:
> 
> myocamlbuild.ml:
> dispatch begin function
>   | After_rules ->
>       rule "dypgen: .dyp -> .ml & .mli"
>         ~deps:["%.dyp"]
>         ~prods:["%.ml"; "%.mli"]
>         begin fun env build ->
>           let dyp = env "%.dyp" in
>           let tags = tags_of_pathname dyp++"ocaml"++"parser" in
>          
>           (* Since pgen and dypgen programs use the same extension, we need
>            * to be able to switch between the two. Do this by tagging 
> the pgen
>            * files with "use_pgen".
>            * I'm not sure how we should do byte/native, so we'll just 
> use the
>            * native. *)
>           let dypgen, tags =
>             if Tags.mem "use_pgen" tags
>             then "dyp/generators/pgen/pgen.native", tags++"pgen"
>             else "dyp/generators/dypgen/dypgen.native", tags++"dypgen"
>           in
>            
>           (* try to build the parser if it doesn't exist yet *)
>           List.iter begin function
>             | Outcome.Good o -> ()
>             | Outcome.Bad exn -> raise exn
>           end (build [[dypgen]]);

You can use the Outcome.ignore_good function.

List.iter Outcome.ignore_good (build [[dypgen]])

>            
>           Cmd(S[A dypgen; T tags; Px dyp])
>         end;
>   | _ -> ()
> end;;
> 

-- 
Nicolas Pouillard aka Ertai

