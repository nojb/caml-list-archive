Return-Path: <oliver@first.in-berlin.de>
X-Spam-Checker-Version: SpamAssassin 3.1.3 (2006-06-01) on yquem.inria.fr
X-Spam-Level: 
X-Spam-Status: No, score=0.0 required=5.0 tests=AWL autolearn=disabled 
	version=3.1.3
X-Original-To: caml-list@yquem.inria.fr
Delivered-To: caml-list@yquem.inria.fr
Received: from concorde.inria.fr (concorde.inria.fr [192.93.2.39])
	by yquem.inria.fr (Postfix) with ESMTP id 6DAF3BC6B
	for <caml-list@yquem.inria.fr>; Tue, 28 Aug 2007 00:29:53 +0200 (CEST)
Received: from einhorn.in-berlin.de (einhorn.in-berlin.de [192.109.42.8])
	by concorde.inria.fr (8.13.6/8.13.6) with ESMTP id l7RMTpnb020142
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=FAIL)
	for <caml-list@inria.fr>; Tue, 28 Aug 2007 00:29:53 +0200
X-Envelope-From: oliver@first.in-berlin.de
X-Envelope-To: <caml-list@inria.fr>
Received: from einhorn.in-berlin.de (localhost [127.0.0.1])
	by einhorn.in-berlin.de (8.13.6/8.13.6/Debian-1) with ESMTP id l7RMToHk005809
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=NOT)
	for <caml-list@inria.fr>; Tue, 28 Aug 2007 00:29:51 +0200
Received: (from www-data@localhost)
	by einhorn.in-berlin.de (8.13.6/8.13.6/Submit) id l7RMToQJ005807
	for caml-list@inria.fr; Tue, 28 Aug 2007 00:29:50 +0200
X-Authentication-Warning: einhorn.in-berlin.de: www-data set sender to oliver@first.in-berlin.de using -f
Received: from dslb-088-073-116-047.pools.arcor-ip.net (dslb-088-073-116-047.pools.arcor-ip.net [88.73.116.47]) 
	by webmail.in-berlin.de (IMP) with HTTP 
	for <first@localhost>; Tue, 28 Aug 2007 00:29:50 +0200
Message-ID: <1188253790.46d3505e19c60@webmail.in-berlin.de>
Date: Tue, 28 Aug 2007 00:29:50 +0200
From: Oliver Bandel <oliver@first.in-berlin.de>
To: caml-list@inria.fr
Subject: Re: [Caml-list] On bashing the OCaml-car...
References: <1188211279.46d2aa4f77e5b@webmail.in-berlin.de> <1188214938.13927.28.camel@rosella.wigram>
In-Reply-To: <1188214938.13927.28.camel@rosella.wigram>
MIME-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
User-Agent: Internet Messaging Program (IMP) 3.2.6
X-Scanned-By: MIMEDefang_at_IN-Berlin_e.V. on 192.109.42.8
X-Miltered: at concorde with ID 46D3505F.002 by Joe's j-chkmail (http://j-chkmail . ensmp . fr)!
X-Spam: no; 0.00; bandel:01 in-berlin:01 0200,:01 bandel:01 ocaml:01 ocaml:01 syntax:01 contrarily:01 syntax:01 haskell:01 functors:01 odes:01 ocaml-core:01 complained:01 founder:98 

Zitat von skaller <skaller@users.sourceforge.net>:

> On Mon, 2007-08-27 at 12:41 +0200, Oliver Bandel wrote:
>
> > Yes. So, why do you bothering?!
> > Please, no more OCaml-bashing.
>
> I am not Ocaml bashing: I'm analysing the consequences
> of certain choices. I can write a lot of different
> languages, Ocaml is only one. I also designed my own,
> similar in some respects to Ocaml, and made some different
> choices with different consequences.

Fine.
My appreciation for this.

>
> My point is simply that the OP is right: Ocaml has a rather
> convoluted and complex syntax that is hard to grasp.

It has a steep learning curve, yes.
At least for non-FP-programmers.

But the most things in OCaml have their advantages,
which sometimes - from a certain perspective - will not be seen!

Some people say, it's ugly, because it's not purely functional.
Other people appreciate that it is not dogmatic and offers
many paradigms. You and others dislike the if-then-else way of OCaml,
but I like it.

Before I had seen that only one single expression
is allowed in the if-then-else I also was somehow confused.
But in the manual it's mentioned. And after I was used to it,
I also have seen the advantages. So, what I mean here, is: something that
might look evil or stupid, from a different viewpoint is excellent!
And OCaml as a multiparadigm language offers many ways to look at things
differently.
For example OOP: OO sometimes is a good choice, sometimes it's annoying,
if you onyl want to have one object and not use  more objects of a certain kind.
So defining a class for one object? OCaml offers immediate objects.
Others might argue this is nonsense, or is not compatible with
"the correct way of <your_favourite_paradigm_or_style>".
But it brings good possibilities.

And that's what I mean: if you have a different taste,
and insist on your viewpoint you will have to look at some
properties in the same way, and in a certain way.

If you have found your absolutely perfect language
(you are the founder / have found it /created it),
then felix might be perfect?
Or would you write it differently today?


>
> Many people think functional programming is hard to learn,
> contrarily, I think it is quite easy and takes about 1 hour,
> since any programmer already knows it (though perhaps not
> indepth techniques). When I first started using Ocaml I had
> no problem with the functional programming aspect .. it was the
> syntax I had problems with .. and clearly still do.

I'm not quite sure, if it was the syntax also,
but as far as I remember, as FP was new to me, this
also was not so easy. I didn't found scheme much easier
to learn, even if the syntax was easier.

But maybe I have a different view, coming from mostly C and Perl.
(But compared to Haskell, I found some aspects of OCaml much easier!)



>
> For example functors are a simple idea I understand from basic
> category theory ..

Fine if you know this.
My appreciation for what you know.

But the syntax is a kind of taste (and perspective).


> but simple math I can use to express the relations
> between various algebraic data structures totally elude me in Ocaml.

??

There are other languages, which would fit your needs better, I would think.


>
> I'm not the only one .. only the true masters even come close to
> understanding why,


Possibly you can explain it.
Maybe there are already languages that make it possible
the way you like it.


> in fact, it doesn't work without considerable
> extra trickery (I have seen some of these solutions .. there
> is no way in the world I could have come up with them).

? explain this, please.



What I can say is: if you like a language, use it.
If you dislike the language: don't use it.
You should never use a language that you use
voluntarily, and at the sanme moment complain about it's
uglyness.

I don't like Java, so I don't use it.
There was a time, when I preferred Perl for nearly everything,
so I used it. Now I would prefer OCaml, so it's my first choice.
when I needed C, I have used it (or when I need it today, I will use it),
but don't complain about it's deficiencies.

Sometimes things I find out might be not so good.
It's OK to mention it. But if it's too bad, it would be time to leave it
alone. The maybe it would be time to write a new language.

But using a language and always read mails about the uglyness odes not make
sense IMHO.

And it make sense to ask for features of OCaml,
but to insist that OCaml should be rewritten by the OCaml-core team
is overconfident. They make their job, we ours.
So, we can ask for features, but we don't give the core-team the commands.

Sometimes, when I read the mails here, I think, people would
like to be the chief of the OCaml core-team.

IMHO we can be happy tho have such a good language like OCaml.
Look at M$. A company that I really dislike, but look,
what they have done: they didn't complained about OCaml,
they created F#.
So, appreciation for M$, the company I dislike, because they
made it in a very constructive way.

Ciao,
   Oliver

P.S.: If the Extlib-developers as the next project would write a
      language that is so much better than OCaml?
      I think, so many people who are complaining about OCaml so often,
      should then start such a project. And if the languge would be better
      for me, I would use it. But I don't see anything that goes into this
      direction.

