Received: (from weis@localhost) by pauillac.inria.fr (8.7.6/8.7.3) id LAA27174 for caml-redistribution; Thu, 30 Dec 1999 11:44:15 +0100 (MET)
Received: from nez-perce.inria.fr (nez-perce.inria.fr [192.93.2.78]) by pauillac.inria.fr (8.7.6/8.7.3) with ESMTP id KAA16940 for <caml-list@pauillac.inria.fr>; Wed, 29 Dec 1999 10:42:05 +0100 (MET)
Received: from cepheus.azstarnet.com (cepheus.azstarnet.com [169.197.56.195])
	by nez-perce.inria.fr (8.8.7/8.8.7) with ESMTP id KAA03531
	for <caml-list@inria.fr>; Wed, 29 Dec 1999 10:42:02 +0100 (MET)
Received: from vega (dialup05ip124.tus.azstarnet.com [169.197.32.124])
	by cepheus.azstarnet.com (8.9.3+blt.Beta0/8.9.3) with SMTP id CAA08242
	for <caml-list@inria.fr>; Wed, 29 Dec 1999 02:41:53 -0700 (MST)
X-Sent-via: StarNet http://www.azstarnet.com/
Message-ID: <000c01bf51e0$ef8295a0$250148bf@vega>
From: "David McClain" <dmcclain@azstarnet.com>
To: <caml-list@inria.fr>
Subject: Threads Library
Date: Wed, 29 Dec 1999 02:41:49 -0700
MIME-Version: 1.0
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: 7bit
X-Priority: 3
X-MSMail-Priority: Normal
X-Mailer: Microsoft Outlook Express 5.00.2615.200
X-MimeOLE: Produced By Microsoft MimeOLE V5.00.2615.200
Sender: weis

I just received a copy of Reppy's new book on "Concurrent ML". I was
delighted to find that the OCAML Threads library incorporates much of his
work with channels and events.

However, unlike CML, (on Windows/NT at least) the GC does not discard
threads hung up on channels that are no longer in use by active threads.
Hence the use of speculative spawning is not safe in WinNT/OCAML. (Early
experiments generated thousands of threads before I had to kill off the
program).

Secondly, it would appear that the semantics of "with_abort" require that
the wrapper function be called ahead of all "with" functions. But
experiments where a with-function raises an exception bypass the actions of
pending "with_abort" functions on non-selected channels. So evidently, one
should not permit the use of uncaught exceptions inside of "with" functions.

Finally, where Reppy's CML uses continuations to effect tail calls, I wonder
about the use of indefinite recursion triggered by a with-function. It would
seem that one should treat composite event lists in much the same manner as
"try-with" when it comes to recursion inside a try (resp. with) clause.
Instead of tail calling from the "with" clause one should return a value to
the outer level of the "sync" or "select", and then "match" on that value
before recursing.

I have implemented a module that provides thread safety, as long as the
above protocols are followed. In effect all events generated by Event.send
and Event.receive are first wrapped in a "with_abort" where the function
spawns a thread to respond to the eventual conjugate operation on the
channel. There are unsafe versions that simply repeat Event.send and
Event.receive for use when it is known that the corresponding thread will
not be ignored forever.

Do I understand the OCAML situation properly?

TIA

David McClain,
Sr. Scientist
Raytheon Systems Co.
Tucson, AZ




