Return-Path: <yoann.padioleau@gmail.com>
X-Original-To: caml-list@sympa.inria.fr
Delivered-To: caml-list@sympa.inria.fr
Received: from mail1-relais-roc.national.inria.fr (mail1-relais-roc.national.inria.fr [192.134.164.82])
	by sympa.inria.fr (Postfix) with ESMTPS id E90B47EEEB
	for <caml-list@sympa.inria.fr>; Tue,  4 Dec 2012 02:08:55 +0100 (CET)
Received-SPF: None (mail1-smtp-roc.national.inria.fr: no sender
  authenticity information available from domain of
  yoann.padioleau@gmail.com) identity=pra;
  client-ip=209.85.216.179;
  receiver=mail1-smtp-roc.national.inria.fr;
  envelope-from="yoann.padioleau@gmail.com";
  x-sender="yoann.padioleau@gmail.com";
  x-conformance=sidf_compatible
Received-SPF: Pass (mail1-smtp-roc.national.inria.fr: domain of
  yoann.padioleau@gmail.com designates 209.85.216.179 as
  permitted sender) identity=mailfrom;
  client-ip=209.85.216.179;
  receiver=mail1-smtp-roc.national.inria.fr;
  envelope-from="yoann.padioleau@gmail.com";
  x-sender="yoann.padioleau@gmail.com";
  x-conformance=sidf_compatible; x-record-type="v=spf1"
Received-SPF: None (mail1-smtp-roc.national.inria.fr: no sender
  authenticity information available from domain of
  postmaster@mail-qc0-f179.google.com) identity=helo;
  client-ip=209.85.216.179;
  receiver=mail1-smtp-roc.national.inria.fr;
  envelope-from="yoann.padioleau@gmail.com";
  x-sender="postmaster@mail-qc0-f179.google.com";
  x-conformance=sidf_compatible
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: AtUBAE1MvVDRVdizk2dsb2JhbABEviwIFg4BAQEBCQkLCRQEI4JMGQEbHgMSEF0BEQEFAYgyAQMPnT2CbIwzgnqEeQoZJw1ZiHUBBQyNToMnA4hejSOOZxYphDQ
X-IronPort-AV: E=Sophos;i="4.84,211,1355094000"; 
   d="scan'208";a="184451895"
Received: from mail-qc0-f179.google.com ([209.85.216.179])
  by mail1-smtp-roc.national.inria.fr with ESMTP/TLS/RC4-SHA; 04 Dec 2012 02:08:45 +0100
Received: by mail-qc0-f179.google.com with SMTP id b14so1674626qcs.10
        for <caml-list@inria.fr>; Mon, 03 Dec 2012 17:08:44 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20120113;
        h=mime-version:date:message-id:subject:from:to:content-type;
        bh=+zIfFVkl+DzPB/a8o9ea2D8o8Wo7/z2RlUbOv35lWzY=;
        b=bFRo1lT/eZZGYrMzU9q6SeWpsLZMZMOJaMU55r455BjZmBUksYjSeLgbA+3Cr14s8D
         5TDFFmVDkqnnQ4FFi/kyl+/vvDrWc3GbPm7MzXPPo+5BbtG9QNbsbkCKkKnqXrcc86Il
         NkaYywYwFRTo/Xf0g706LdRw2ElCYLGd3Ov/4OtUunNRQhnoNG3Ee+3YznOC6mMXitiI
         A+1yD2L1MVQg+SfryQkK0knWUAY/osHSJYfmaJy+sq9u1XA/3TrDq6G6i10boVp5q1Hg
         gC+L/TgZ1yGIucgbZ1uYOcTAGI34hAUpi7qX6IaDNvOj7xar4jzGMakP+SwasvObP5V4
         XfAg==
MIME-Version: 1.0
Received: by 10.224.215.131 with SMTP id he3mr20125780qab.41.1354583324237;
 Mon, 03 Dec 2012 17:08:44 -0800 (PST)
Received: by 10.49.28.227 with HTTP; Mon, 3 Dec 2012 17:08:44 -0800 (PST)
Date: Mon, 3 Dec 2012 17:08:44 -0800
Message-ID: <CAFksq2_T4=ArqM+8EJONx4O_fHi78x5GqttxFNTdxss=b3RjQQ@mail.gmail.com>
From: yoann padioleau <yoann.padioleau@gmail.com>
To: caml-list@inria.fr
Content-Type: text/plain; charset=ISO-8859-1
X-Validation-by: yoann.padioleau@gmail.com
Subject: [Caml-list] Is there a typed bin-annot cmt tree with module and
 type aliases resolved?

Hi,

I want to use the .cmt files generated by -bin-annot for some
dependency analysis. The
problem is that not all names are resolved, especially module aliases
and type aliases are not
resolved. For instance on this file:

module X = Variant
open Nested_module
module Y = Nested

let use_variant = function
  | X.Constructor1 -> 1
  | _ -> 2


I got this dump for the AST/CMT file:
{
 str_items=[Tstr_module("X", (), Tmod_ident("Variant", ()));
            Tstr_open("Nested_module", ());
            Tstr_module("Y", (), Tmod_ident("Nested_module.Nested", ()));
            Tstr_value((),
              [(Tpat_var("use_variant", ()),
                Texp_function((),
                  [(Tpat_construct("X.Constructor1", (), (), [], false),
                    Texp_constant(())); (Tpat_any, Texp_constant(()))], ()))])];
 str_type=(); str_final_env=(); }

but I would really like an AST where all names are fully resolved, so
X.Constructor1 becomes
Variant.Constructor1. In the example above Nested_module.Nested is
resolved (so the open Nested_module
is handled), but not X.Constructor1.

Same for types, with this file:
type list2 = int list

type use_list2 =
  | Constructor of list2

let f = function
  | Constructor [] -> 1
  | _ -> 2


I got this dump of the AST/CMT:
{
 str_items=[Tstr_type(
              [("list2", (),
                {typ_params=[]; typ_type=(); typ_cstrs=[];
                 typ_kind=Ttype_abstract; typ_private=();
                 typ_manifest=Some(Ttyp_constr("list", (),
                                     [Ttyp_constr("int", (), [])]));
                 typ_variance=[]; typ_loc=(); })]);
            Tstr_type(
              [("use_list2", (),
                {typ_params=[]; typ_type=(); typ_cstrs=[];
                 typ_kind=Ttype_variant(
                            [("Constructor", (),
                              [Ttyp_constr("list2", (), [])], ())]);
                 typ_private=(); typ_manifest=None; typ_variance=[];
                 typ_loc=(); })]);
            Tstr_value((),
              [(Tpat_var("f", ()),
                Texp_function((),
                  [(Tpat_construct("Constructor", (), (),
                      [Tpat_construct("[]", (), (), [], false)], false),
                    Texp_constant(())); (Tpat_any, Texp_constant(()))], ()))])];
 str_type=(); str_final_env=(); }

and when I ask the type of [], it says list2, but I would really like
the final type that is int list2.

Should I use env.ml for resolving?
