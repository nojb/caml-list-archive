Return-Path: <esther.baruk@gmail.com>
X-Original-To: caml-list@sympa.inria.fr
Delivered-To: caml-list@sympa.inria.fr
Received: from mail4-relais-sop.national.inria.fr (mail4-relais-sop.national.inria.fr [192.134.164.105])
	by sympa.inria.fr (Postfix) with ESMTPS id D8A017EEEB
	for <caml-list@sympa.inria.fr>; Tue,  4 Dec 2012 09:18:34 +0100 (CET)
Received-SPF: None (mail4-smtp-sop.national.inria.fr: no sender
  authenticity information available from domain of
  esther.baruk@gmail.com) identity=pra;
  client-ip=209.85.216.47;
  receiver=mail4-smtp-sop.national.inria.fr;
  envelope-from="esther.baruk@gmail.com";
  x-sender="esther.baruk@gmail.com";
  x-conformance=sidf_compatible
Received-SPF: Pass (mail4-smtp-sop.national.inria.fr: domain of
  esther.baruk@gmail.com designates 209.85.216.47 as permitted
  sender) identity=mailfrom; client-ip=209.85.216.47;
  receiver=mail4-smtp-sop.national.inria.fr;
  envelope-from="esther.baruk@gmail.com";
  x-sender="esther.baruk@gmail.com";
  x-conformance=sidf_compatible; x-record-type="v=spf1"
Received-SPF: None (mail4-smtp-sop.national.inria.fr: no sender
  authenticity information available from domain of
  postmaster@mail-qa0-f47.google.com) identity=helo;
  client-ip=209.85.216.47;
  receiver=mail4-smtp-sop.national.inria.fr;
  envelope-from="esther.baruk@gmail.com";
  x-sender="postmaster@mail-qa0-f47.google.com";
  x-conformance=sidf_compatible
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: Aq8BABOxvVDRVdgvk2dsb2JhbABEq1uJPYkTCBYOAQEBAQkJCwkUBCOCHgEBBAEnGQEbEgsBAwELBgULGiEhAQERAQUBChIGExKHawEDCQYMoCeMM4FwgQqFFgoZJwMKWYh1AQUMi0tphEEDlC2BVYEcihuDMBYphBQ
X-IronPort-AV: E=Sophos;i="4.84,213,1355094000"; 
   d="scan'208";a="164686108"
Received: from mail-qa0-f47.google.com ([209.85.216.47])
  by mail4-smtp-sop.national.inria.fr with ESMTP/TLS/RC4-SHA; 04 Dec 2012 09:18:33 +0100
Received: by mail-qa0-f47.google.com with SMTP id a19so774314qad.6
        for <caml-list@inria.fr>; Tue, 04 Dec 2012 00:18:33 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20120113;
        h=mime-version:in-reply-to:references:from:date:message-id:subject:to
         :cc:content-type;
        bh=40zyLBx3pN5nPhr4WGchWyXplMGU0agJf26Cp9UI/Ys=;
        b=BA4VXQk4I7HOYYH4fTTr6WjR7iGfAsAv63kr6qeMLgdd5XxrCjwxnIDWl4p3jg3cP9
         3ND0VJW4mw1EyI/9yGyfvSFx2jfDhym81lt2D9/iZaYfzyvCnnAuK6iZ5PNMCibBaTvE
         Qd5i9caQbuKKISEk5ou2k1w+9/NQW5F2Mly/8I5GwQsqhBBX9jNv3LCEGCXmiYl1bfDc
         t0Q4xU/JGSRp27x9/iYC7DtnXSX74kdTbkP295/VdADCMsrOed1E+/6e1MD9gEB2fpGv
         QXuUOGOmvyQvSh7dlnYCgUsA6x8d/g/WbMRY8XltSbXUcu2kWCNRa0LTFLN4IvzP4JhW
         pQKg==
Received: by 10.224.168.80 with SMTP id t16mr21050307qay.8.1354609113054; Tue,
 04 Dec 2012 00:18:33 -0800 (PST)
MIME-Version: 1.0
Received: by 10.229.151.14 with HTTP; Tue, 4 Dec 2012 00:18:12 -0800 (PST)
In-Reply-To: <CAFksq2_T4=ArqM+8EJONx4O_fHi78x5GqttxFNTdxss=b3RjQQ@mail.gmail.com>
References: <CAFksq2_T4=ArqM+8EJONx4O_fHi78x5GqttxFNTdxss=b3RjQQ@mail.gmail.com>
From: Esther Baruk <esther.baruk@gmail.com>
Date: Tue, 4 Dec 2012 09:18:12 +0100
Message-ID: <CAFzMiE0fWcwHDxNBJ=ZFcaVT66m1q++8no23uOSuK38fJ1bkaQ@mail.gmail.com>
To: yoann padioleau <yoann.padioleau@gmail.com>
Cc: caml-list@inria.fr
Content-Type: multipart/alternative; boundary=20cf3074b298fe3e6104d00282e5
Subject: Re: [Caml-list] Is there a typed bin-annot cmt tree with module and
 type aliases resolved?


--20cf3074b298fe3e6104d00282e5
Content-Type: text/plain; charset=ISO-8859-1

Hi,

The goal of this cmt file is to reflect the AST as it is in the source file
so that explains why the aliases are not meant to be resolved.
You can perform an analysis on the tree and rewrite it while resolving
aliases. A functor will let you write just the functions you need and do
the pattern matching for you : typedtreeIter.ml. It is located in the
"typing" directory of the OCaml sources.

Esther Baruk


On Tue, Dec 4, 2012 at 2:08 AM, yoann padioleau
<yoann.padioleau@gmail.com>wrote:

> Hi,
>
> I want to use the .cmt files generated by -bin-annot for some
> dependency analysis. The
> problem is that not all names are resolved, especially module aliases
> and type aliases are not
> resolved. For instance on this file:
>
> module X = Variant
> open Nested_module
> module Y = Nested
>
> let use_variant = function
>   | X.Constructor1 -> 1
>   | _ -> 2
>
>
> I got this dump for the AST/CMT file:
> {
>  str_items=[Tstr_module("X", (), Tmod_ident("Variant", ()));
>             Tstr_open("Nested_module", ());
>             Tstr_module("Y", (), Tmod_ident("Nested_module.Nested", ()));
>             Tstr_value((),
>               [(Tpat_var("use_variant", ()),
>                 Texp_function((),
>                   [(Tpat_construct("X.Constructor1", (), (), [], false),
>                     Texp_constant(())); (Tpat_any, Texp_constant(()))],
> ()))])];
>  str_type=(); str_final_env=(); }
>
> but I would really like an AST where all names are fully resolved, so
> X.Constructor1 becomes
> Variant.Constructor1. In the example above Nested_module.Nested is
> resolved (so the open Nested_module
> is handled), but not X.Constructor1.
>
> Same for types, with this file:
> type list2 = int list
>
> type use_list2 =
>   | Constructor of list2
>
> let f = function
>   | Constructor [] -> 1
>   | _ -> 2
>
>
> I got this dump of the AST/CMT:
> {
>  str_items=[Tstr_type(
>               [("list2", (),
>                 {typ_params=[]; typ_type=(); typ_cstrs=[];
>                  typ_kind=Ttype_abstract; typ_private=();
>                  typ_manifest=Some(Ttyp_constr("list", (),
>                                      [Ttyp_constr("int", (), [])]));
>                  typ_variance=[]; typ_loc=(); })]);
>             Tstr_type(
>               [("use_list2", (),
>                 {typ_params=[]; typ_type=(); typ_cstrs=[];
>                  typ_kind=Ttype_variant(
>                             [("Constructor", (),
>                               [Ttyp_constr("list2", (), [])], ())]);
>                  typ_private=(); typ_manifest=None; typ_variance=[];
>                  typ_loc=(); })]);
>             Tstr_value((),
>               [(Tpat_var("f", ()),
>                 Texp_function((),
>                   [(Tpat_construct("Constructor", (), (),
>                       [Tpat_construct("[]", (), (), [], false)], false),
>                     Texp_constant(())); (Tpat_any, Texp_constant(()))],
> ()))])];
>  str_type=(); str_final_env=(); }
>
> and when I ask the type of [], it says list2, but I would really like
> the final type that is int list2.
>
> Should I use env.ml for resolving?
>
> --
> Caml-list mailing list.  Subscription management and archives:
> https://sympa.inria.fr/sympa/arc/caml-list
> Beginner's list: http://groups.yahoo.com/group/ocaml_beginners
> Bug reports: http://caml.inria.fr/bin/caml-bugs
>

--20cf3074b298fe3e6104d00282e5
Content-Type: text/html; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Hi,<div><br></div><div>The goal of this cmt file is to reflect the AST as i=
t is in the source file so that explains why the aliases are not meant to b=
e resolved.</div><div>You can perform an analysis on the tree and rewrite i=
t while resolving aliases. A functor will let you write just the functions =
you need and do the pattern matching for you : typedtreeIter.ml. It is loca=
ted in the &quot;typing&quot; directory of the OCaml sources.</div>

<div><br></div><div>Esther Baruk<br></div><div class=3D"gmail_extra">
<br><br><div class=3D"gmail_quote">On Tue, Dec 4, 2012 at 2:08 AM, yoann pa=
dioleau <span dir=3D"ltr">&lt;<a href=3D"mailto:yoann.padioleau@gmail.com" =
target=3D"_blank">yoann.padioleau@gmail.com</a>&gt;</span> wrote:<br><block=
quote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;border-left:1px #ccc=
 solid;padding-left:1ex">

Hi,<br>
<br>
I want to use the .cmt files generated by -bin-annot for some<br>
dependency analysis. The<br>
problem is that not all names are resolved, especially module aliases<br>
and type aliases are not<br>
resolved. For instance on this file:<br>
<br>
module X =3D Variant<br>
open Nested_module<br>
module Y =3D Nested<br>
<br>
let use_variant =3D function<br>
=A0 | X.Constructor1 -&gt; 1<br>
=A0 | _ -&gt; 2<br>
<br>
<br>
I got this dump for the AST/CMT file:<br>
{<br>
=A0str_items=3D[Tstr_module(&quot;X&quot;, (), Tmod_ident(&quot;Variant&quo=
t;, ()));<br>
=A0 =A0 =A0 =A0 =A0 =A0 Tstr_open(&quot;Nested_module&quot;, ());<br>
=A0 =A0 =A0 =A0 =A0 =A0 Tstr_module(&quot;Y&quot;, (), Tmod_ident(&quot;Nes=
ted_module.Nested&quot;, ()));<br>
=A0 =A0 =A0 =A0 =A0 =A0 Tstr_value((),<br>
=A0 =A0 =A0 =A0 =A0 =A0 =A0 [(Tpat_var(&quot;use_variant&quot;, ()),<br>
=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 Texp_function((),<br>
=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 [(Tpat_construct(&quot;X.Constructor1&q=
uot;, (), (), [], false),<br>
=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 Texp_constant(())); (Tpat_any, Texp=
_constant(()))], ()))])];<br>
=A0str_type=3D(); str_final_env=3D(); }<br>
<br>
but I would really like an AST where all names are fully resolved, so<br>
X.Constructor1 becomes<br>
Variant.Constructor1. In the example above Nested_module.Nested is<br>
resolved (so the open Nested_module<br>
is handled), but not X.Constructor1.<br>
<br>
Same for types, with this file:<br>
type list2 =3D int list<br>
<br>
type use_list2 =3D<br>
=A0 | Constructor of list2<br>
<br>
let f =3D function<br>
=A0 | Constructor [] -&gt; 1<br>
=A0 | _ -&gt; 2<br>
<br>
<br>
I got this dump of the AST/CMT:<br>
{<br>
=A0str_items=3D[Tstr_type(<br>
=A0 =A0 =A0 =A0 =A0 =A0 =A0 [(&quot;list2&quot;, (),<br>
=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 {typ_params=3D[]; typ_type=3D(); typ_cstrs=
=3D[];<br>
=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0typ_kind=3DTtype_abstract; typ_private=
=3D();<br>
=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0typ_manifest=3DSome(Ttyp_constr(&quot;li=
st&quot;, (),<br>
=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0=
[Ttyp_constr(&quot;int&quot;, (), [])]));<br>
=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0typ_variance=3D[]; typ_loc=3D(); })]);<b=
r>
=A0 =A0 =A0 =A0 =A0 =A0 Tstr_type(<br>
=A0 =A0 =A0 =A0 =A0 =A0 =A0 [(&quot;use_list2&quot;, (),<br>
=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 {typ_params=3D[]; typ_type=3D(); typ_cstrs=
=3D[];<br>
=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0typ_kind=3DTtype_variant(<br>
=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 [(&quot;Constructor=
&quot;, (),<br>
=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 [Ttyp_constr(&q=
uot;list2&quot;, (), [])], ())]);<br>
=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0typ_private=3D(); typ_manifest=3DNone; t=
yp_variance=3D[];<br>
=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0typ_loc=3D(); })]);<br>
=A0 =A0 =A0 =A0 =A0 =A0 Tstr_value((),<br>
=A0 =A0 =A0 =A0 =A0 =A0 =A0 [(Tpat_var(&quot;f&quot;, ()),<br>
=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 Texp_function((),<br>
=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 [(Tpat_construct(&quot;Constructor&quot=
;, (), (),<br>
=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 [Tpat_construct(&quot;[]&quot;,=
 (), (), [], false)], false),<br>
=A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 Texp_constant(())); (Tpat_any, Texp=
_constant(()))], ()))])];<br>
=A0str_type=3D(); str_final_env=3D(); }<br>
<br>
and when I ask the type of [], it says list2, but I would really like<br>
the final type that is int list2.<br>
<br>
Should I use <a href=3D"http://env.ml" target=3D"_blank">env.ml</a> for res=
olving?<br>
<span class=3D"HOEnZb"><font color=3D"#888888"><br>
--<br>
Caml-list mailing list. =A0Subscription management and archives:<br>
<a href=3D"https://sympa.inria.fr/sympa/arc/caml-list" target=3D"_blank">ht=
tps://sympa.inria.fr/sympa/arc/caml-list</a><br>
Beginner&#39;s list: <a href=3D"http://groups.yahoo.com/group/ocaml_beginne=
rs" target=3D"_blank">http://groups.yahoo.com/group/ocaml_beginners</a><br>
Bug reports: <a href=3D"http://caml.inria.fr/bin/caml-bugs" target=3D"_blan=
k">http://caml.inria.fr/bin/caml-bugs</a><br>
</font></span></blockquote></div><br></div>

--20cf3074b298fe3e6104d00282e5--
