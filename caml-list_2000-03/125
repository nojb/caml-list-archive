Received: (from weis@localhost) by pauillac.inria.fr (8.7.6/8.7.3) id PAA29135 for caml-redistribution@pauillac.inria.fr; Tue, 21 Mar 2000 15:16:11 +0100 (MET)
Resent-Message-Id: <200003211416.PAA29135@pauillac.inria.fr>
Received: from nez-perce.inria.fr (nez-perce.inria.fr [192.93.2.78]) by pauillac.inria.fr (8.7.6/8.7.3) with ESMTP id UAA24875 for <caml-list@pauillac.inria.fr>; Sat, 18 Mar 2000 20:17:22 +0100 (MET)
Received: from sarg.Ryerson.CA (sarg.Ryerson.CA [141.117.18.117])
	by nez-perce.inria.fr (8.8.7/8.8.7) with ESMTP id UAA27595
	for <caml-list@inria.fr>; Sat, 18 Mar 2000 20:17:21 +0100 (MET)
Received: from sarg.Ryerson.CA (dmason@localhost [127.0.0.1])
	by sarg.Ryerson.CA (8.8.7/8.8.7) with ESMTP id OAA01239
	for <caml-list@inria.fr>; Sat, 18 Mar 2000 14:17:11 -0500
Message-Id: <200003181917.OAA01239@sarg.Ryerson.CA>
To: caml-list@inria.fr
Subject: Re: multi-threaded udp resolver 
In-reply-to: Your message of "10 Mar 2000 09:34:47 +1100."
             <wxd7p33h88.fsf@suburbia.net> 
Mime-Version: 1.0 (generated by tm-edit 7.108)
Content-Type: text/plain; charset=US-ASCII
Date: Sat, 18 Mar 2000 14:17:11 -0500
From: Dave Mason <dmason@sarg.Ryerson.CA>
Resent-From: weis@pauillac.inria.fr
Resent-Date: Tue, 21 Mar 2000 15:16:11 +0100
Resent-To: caml-redistribution@pauillac.inria.fr

>>>>> On 10 Mar 2000 09:34:47 +1100, Julian Assange <proff@iq.org> said:

> While ocaml provides appropriate udp send/receive functions, the
> best mechanism for understanding the structure of dns packets is
> unknown to me. DNS packets are `loosely' structured. That is, there
>[...]
> Vixie's named/bind daemon doesn't even attempt to describe the
> structure in any sort of data form, but rather uses the code flow
> itself to describe the structure (e.g pulling 16 bits, assigning it
> to a variable, advancing the interpretation pointer by 16 bits,
> testing the variable, pulling 32 bits etc).

I would unpack the packet into a char list and then process it with something like:

let dispatch cont = function
	| t1::t2::rest -> (match (ord t1)*256+(ord t2) with
		| 1 -> type1 cont rest
		| 2 -> type2 cont rest
		| _ -> error...
		)
	| _ -> error...
and type1 cont = function
	| f1::f2::f3::...::rest] -> cont (...f1...f2...f3...) rest
	| _ -> error...
and type1 cont = function
	| f1::f2::rest] -> dispatch (fun v rest' -> cont (...f1...f2...v...) rest') rest
	| _ -> error...
;;

note that cont is a continuation, that will be used to process the
rest of the string after the current value is parsed.

You could also use an ocaml parser.

> This method is incredibly error-prone, and it's hard to see a good
> way of fitting it in with ocaml's type system. Any ideas on the best
> way to approach this problem?

Getting the types right can be a little tricky, but is doable.

../Dave


