Received: (from weis@localhost) by pauillac.inria.fr (8.7.6/8.7.3) id SAA14350 for caml-redistribution; Thu, 17 Jul 1997 18:26:06 +0200 (MET DST)
Received: from concorde.inria.fr (concorde.inria.fr [192.93.2.39]) by pauillac.inria.fr (8.7.6/8.7.3) with ESMTP id SAA14226 for <caml-list@pauillac.inria.fr>; Thu, 17 Jul 1997 18:22:37 +0200 (MET DST)
Received: from madiran.inria.fr (madiran.inria.fr [128.93.8.77]) by concorde.inria.fr (8.8.5/8.7.3) with ESMTP id SAA25253; Thu, 17 Jul 1997 18:22:36 +0200 (MET DST)
Received: from madiran.inria.fr (localhost.inria.fr [127.0.0.1]) by madiran.inria.fr (8.7.4/8.6.6) with ESMTP id SAA05148; Thu, 17 Jul 1997 18:22:34 +0200
Message-Id: <199707171622.SAA05148@madiran.inria.fr>
X-Mailer: exmh version 1.6.4 10/10/95
From: Francois Rouaix <Francois.Rouaix@inria.fr>
To: Christian Lindig <lindig@ips.cs.tu-bs.de>
cc: caml-list@pauillac.inria.fr
Subject: Re: scanning and parsing short strings 
In-reply-to: Your message of "Thu, 10 Jul 1997 16:42:52 +0200."
             <199707101442.QAA15363@infbsst5.ips.cs.tu-bs.de> 
Reply-To: Francois.Rouaix@inria.fr
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Date: Thu, 17 Jul 1997 18:22:33 +0200
Sender: weis

> many applications rely on protocols which they must parse. This can
> be either done ad hoc using regular expressions or scanner/parser
> generated by Camllex/yacc. Which method is advisable when the scanned
> items are relative short strings (< 100 Bytes)?
[...]
> The background of my question: I like to implement a CGI library.
> I already took a look at the MMM code which uses a mixed approach. 

I can't give performance comparisons, but here are some personal appreciations
on the various solutions.
* regular expressions dont scale
It's probably all right for CGI headers because these are small one-line
inputs, and their syntax is essentially trivial, but then it's also error
prone (you rarely write the correct pattern at once). Then, libstr also 
requires building custom binaries which make bigger applications (at least
with the bytecode compiler).
* camllex is easy. Besides lexical analysis, it can also handle simple
parsing strategies, such as recursive descent
* yacc (and therefore camlyacc) is a pain, and will always be. Moreover,
error handling is not that easy.

Also, streams and parsers are a possible alternative to camllex/yacc, although
here you will loose some speed.

--f







