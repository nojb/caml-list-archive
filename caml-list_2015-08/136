Return-Path: <SRS0=Yms6=I2=m4x.org=simon.cruanes.2007@bounces.m4x.org>
X-Original-To: caml-list@sympa.inria.fr
Delivered-To: caml-list@sympa.inria.fr
Received: from mail3-relais-sop.national.inria.fr (mail3-relais-sop.national.inria.fr [192.134.164.104])
	by sympa.inria.fr (Postfix) with ESMTPS id 500047EEBF
	for <caml-list@sympa.inria.fr>; Wed, 19 Aug 2015 18:05:26 +0200 (CEST)
Received-SPF: Neutral (mail3-smtp-sop.national.inria.fr: domain
  of simon.cruanes.2007@m4x.org does not assert whether or not
  129.104.30.34 is permitted sender) identity=pra;
  client-ip=129.104.30.34;
  receiver=mail3-smtp-sop.national.inria.fr;
  envelope-from="SRS0=Yms6=I2=m4x.org=simon.cruanes.2007@bounces.m4x.org";
  x-sender="simon.cruanes.2007@m4x.org";
  x-conformance=sidf_compatible; x-record-type="spf2.0"
Received-SPF: Pass (mail3-smtp-sop.national.inria.fr: domain of
  SRS0=Yms6=I2=m4x.org=simon.cruanes.2007@bounces.m4x.org
  designates 129.104.30.34 as permitted sender)
  identity=mailfrom; client-ip=129.104.30.34;
  receiver=mail3-smtp-sop.national.inria.fr;
  envelope-from="SRS0=Yms6=I2=m4x.org=simon.cruanes.2007@bounces.m4x.org";
  x-sender="SRS0=Yms6=I2=m4x.org=simon.cruanes.2007@bounces.m4x.org";
  x-conformance=sidf_compatible; x-record-type="spf2.0"
Received-SPF: Pass (mail3-smtp-sop.national.inria.fr: domain of
  postmaster@mx1.polytechnique.org designates 129.104.30.34 as
  permitted sender) identity=helo; client-ip=129.104.30.34;
  receiver=mail3-smtp-sop.national.inria.fr;
  envelope-from="SRS0=Yms6=I2=m4x.org=simon.cruanes.2007@bounces.m4x.org";
  x-sender="postmaster@mx1.polytechnique.org";
  x-conformance=sidf_compatible; x-record-type="v=spf1"
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: A0A3DQD3qNRVnCIeaIFdg29pgyWpa5AQgiuFe4FFTAEBAQEBARIBAQEBAQgUCU9BAQIBg18BBSMPATkCCAMQCxgNHQICISQSBgENBRIIAYd+AxIECbpxkDgDCoVXAQEIAQEBAQEBAQEBGYpQgQOCT4IILxSCYC+BFAWFbAyMHIMJB4UEhXyDN0aGXooMg0+DaBGCIxyBVW+CTAEBAQ
X-IPAS-Result: A0A3DQD3qNRVnCIeaIFdg29pgyWpa5AQgiuFe4FFTAEBAQEBARIBAQEBAQgUCU9BAQIBg18BBSMPATkCCAMQCxgNHQICISQSBgENBRIIAYd+AxIECbpxkDgDCoVXAQEIAQEBAQEBAQEBGYpQgQOCT4IILxSCYC+BFAWFbAyMHIMJB4UEhXyDN0aGXooMg0+DaBGCIxyBVW+CTAEBAQ
X-IronPort-AV: E=Sophos;i="5.15,710,1432591200"; 
   d="scan'208,217";a="143245983"
Received: from mx1.polytechnique.org ([129.104.30.34])
  by mail3-smtp-sop.national.inria.fr with ESMTP/TLS/ADH-AES256-SHA; 19 Aug 2015 18:05:25 +0200
Received: from [10.148.239.230] (unknown [178.251.23.111])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by ssl.polytechnique.org (Postfix) with ESMTPSA id C28EF140C7E35;
	Wed, 19 Aug 2015 18:02:57 +0200 (CEST)
User-Agent: K-9 Mail for Android
In-Reply-To: <CAN=ouMQ-=dr7FyvPTEcF0wgBDsF5xyOxBb0roerckHCs0f0WnQ@mail.gmail.com>
References: <BF0D69096EFA410695EC3AFB2CEEDABD@erratique.ch> <B52F2D68184048B39F261A5A96246437@erratique.ch> <55BF75F6.1040006@bioquant.uni-heidelberg.de> <8E1A640CE3374EB492981ADB0A2DA5C6@erratique.ch> <20150804092633.GC5689@frosties> <5C2023F4AF0549F58F3E4C9A6F8ABE84@erratique.ch> <CAJgjwegcaKqohVE0H=vO_8d+qY6rr1G8cLP38a+Vf5y8dmtM=A@mail.gmail.com> <CALdWJ+zsKtXnE9zbVTSyuRV8+jwRVP9Ahp202ncOYj7JUHcKpQ@mail.gmail.com> <20150814105551.GD31364@frosties> <55CDD0F2.1090200@zoho.com> <20150818111134.GA11154@frosties> <E51C5B015DBD1348A1D85763337FB6D9E9DCF532@Remus.metastack.local> <CAPFanBGTgsQKm0kSimaAK6nXVrBb5wKV1Awh0KsqpRL6KQAuhA@mail.gmail.com> <CAN=ouMQ-=dr7FyvPTEcF0wgBDsF5xyOxBb0roerckHCs0f0WnQ@mail.gmail.com>
MIME-Version: 1.0
Content-Type: multipart/alternative; boundary="----BC3GPUVVDHG39QSNPSIQ5BBR334DO1"
Content-Transfer-Encoding: 8bit
From: Simon Cruanes <simon.cruanes.2007@m4x.org>
Date: Wed, 19 Aug 2015 17:55:18 +0200
To: Anthony Tavener <anthony.tavener@gmail.com>,Gabriel Scherer <gabriel.scherer@gmail.com>
CC: "caml-list@inria.fr" <caml-list@inria.fr>
Message-ID: <D7CDD808-BC13-4D77-9EDD-D9F450391993@m4x.org>
X-AV-Checked: ClamAV using ClamSMTP at svoboda.polytechnique.org (Wed Aug 19 18:05:24 2015 +0200 (CEST))
X-Spam-Flag: No, tests=bogofilter, spamicity=0.290372, queueID=03A86140C7E36
X-Org-Mail: simon.cruanes.2007@polytechnique.org
Subject: Re: [Caml-list] destructive local opens

------BC3GPUVVDHG39QSNPSIQ5BBR334DO1
Content-Transfer-Encoding: 8bit
Content-Type: text/plain;
 charset=UTF-8

This whole thread makes me wonder whether local opens are worth it. I don't like global open (at all), and shadowing is harmful even in smaller scopes. Local open seems to be used for DSL that have a lot of infix operators (maths, etc.) as demonstrated by the proposal of new warnings and syntax about shadowing of infix operators.

If modules have short names (Z, Q from Zarith come to mind, but module-aliasing your favorite monad to "M" would do too), would M.+ be a reasonable infix operator? I would be ready to have slightly more verbose calls to M.>>= if it removes ambiguity and potential shadowing bugs. Of course I don't know if this is compatible with the current syntax.

Le 19 août 2015 00:26:00 UTC+02:00, Anthony Tavener <anthony.tavener@gmail.com> a écrit :
>(TL;DR: I commonly want to specify paths -uniquely- for identifiers in
>local
>scopes (function, module) which have no means to do this.)
>
>As I run into this yet again, moments ago...
>
>I do often want the ability to be clear that something is not to be
>shadowed
>by the opened scope... to specify it's from the local (usually
>function)
>scope.
>Part of the reason is for code clarity, but also to safeguard against
>possible
>later changes in the *opened* module (introducing the same identifier).
>
>  let init flags =
>   M.(init (flag1 + flag2 + flags)) (* flags is intended to be 'local',
>but it could be shadowed by a value in M *)
>
>Where M provides 'init', 'flag1', 'flag2', and '+', but 'flags' is in
>the
>local (function) context. When I do this I try to think of a way to
>make it
>self evident that 'flags' is not from M, but there is no way. Aside
>from
>bringing it outside the local-open, but then it's more difficult to
>build
>an expression.
>
>Vimscript might be one of the worst languages to use as a reference,
>but
>this
>issue does bring to mind the scope prefixes...
>
>  let init flags =
>M.(init (flag1 + flag2 + l:flags)) (* illustrative -- not a proposal!
>*)
>
>I sometimes consider using naming conventions, but I don't want to
>explicitly
>make function arguments something like l_flags, l_point, etc. That
>would be
>a
>horrible widespread style, and doesn't work nicely with named
>arguments.
>Plus, changing names to do this seems wrong -- it's at the access site
>where
>you want to disambiguate, which always leads me to think some sigil or
>prefix.
>
>There was an earlier sidetrack which went with ^ as an "unopen" prefix.
>At
>first,
>my interest was piqued. Naturally, the issue of recursive unopen came
>up...
>
>In response, Gabriel wisely remarked:
>
> "It is remarkable that programming languages have avoided introducing
> explicit weakening (the popping of a symbol out of scope) for now, and
> I think it is a property that should be preserved. We're not yet ready
>  to go there."
>
>Good advice when the thread was spinning out of control and probably
>not
>going
>to settle on anything realistic or favorable. Even though there might
>be
>merit
>in pursuing fine-grained scope-popping as its own topic.
>
>I think there is a simpler gain to be had from the idea of being able
>to
>specify
>the path of the current context. "Current context" would need to be
>something sensible, and I'm not sure yet what would be best, as there
>is a
>related issue I encounter commonly:
>
>A way to specify the path of the current module.
>
>There is no way to do this, right? If I'm in "a.ml", I can't refer to
>A.identifier, and there is no other way to uniquely specify the path to
>what
>*will become* A.identifier? As the bare "identifier" can be shadowed by
>any
>modules opened afterward. Unlike the general "scope-popping", there is
>also
>a common language feature like this: self or this.
>
>I usually want to be explicit with module paths, especially if I am
>using an
>"identifier" which could reasonably be expected to exist now or later
>in the
>other modules being used. I do keep opens to a minimum, but often an
>entire
>expression will be in a local open (to bring in operators), and there,
>again... I would like that clarity, and safeguard against changes which
>might
>happen in the other modules, leading to suprises or need to change
>*this*
>module for no good reason other than a naming conflict which ideally
>can be
>prepared against.
>
>Has there been any discussion about referring to the local module? My
>guess
>is
>that it might be a mild enough problem to not warrant any proposed
>solutions.
>But if there are ideas, maybe the same thing or something similar can
>also
>apply to this problem of "escaping" a local open? They are very
>similar, but
>one is module-scope, while I think the other would be function-scope
>(though
>module-scope might imply the "right thing" anyway)... I'm not certain,
>as
>haven't been keeping track of the cases I encounter, and others might
>have
>different use-cases.
>
>
>On Tue, Aug 18, 2015 at 7:00 AM, Gabriel Scherer
><gabriel.scherer@gmail.com>
>wrote:
>
>> Note that the dual feature does not exist for variant constructors,
>> because it is easy to define only on the constructor at the toplevel
>of the
>> pattern, and nested patterns get us in muddy waters.
>>
>> On Tue, Aug 18, 2015 at 2:52 PM, David Allsopp
><dra-news@metastack.com>
>> wrote:
>>
>>> Goswin von Brederlow wrote:
>>> > On Fri, Aug 14, 2015 at 01:28:50PM +0200, Drup wrote:
>>> > >
>>> > > >You can't qualifylocal values or values of the surrounding
>module so
>>> > > >that is a no go.
>>> > > >
>>> > > >I also often use local open to access records, as in:
>>> > > >
>>> > > >let r = M.({ x = 1; y; z = depth; }) in
>>> > >
>>> > > You can avoid the local open altogether and write it like that:
>>> > >
>>> > >     let r = {M. x = 1; y; z = depth } in
>>> > >
>>> > > It's even shorter.
>>> >
>>> > That only works because newer ocaml disambiguises (is that a
>word?)
>>> record
>>> > So it's implicitly using M.y = y and M.z = depth.
>>> > labels when it determines the record type from the first label,
>right?
>>>
>>> Only since you ask: "disambiguates" :o) That said, it's quite common
>to
>>> see words like "disambiguises" being invented by Americans!
>>>
>>> But this isn't related to the disambiguation features of OCaml
>4.01+.
>>> Those allow you to write things like:
>>>
>>> type t = {x : int}
>>> type u = {x : int; y : string}
>>>
>>> let foo = {x = 1}
>>> let bar = {x = 42; y = ""}
>>>
>>> This is actually a much older notation added in OCaml 3.08. Prior to
>>> that, if you hadn't opened a module you had to qualify each label:
>>>
>>> {M.x = 1; M.y = y; M.z = depth}
>>>
>>> but this was "silly", since it's not possible to use non-equivalent
>>> module paths for labels, so OCaml 3.08 changed it so that you only
>needed
>>> to put the module path on one label (and it doesn't have to be the
>first
>>> one, it's just a bit weird to put it in the middle!).
>>>
>>> OCaml 3.12 added, amongst other record-related goodies, the
>shorthand {y}
>>> to mean {y = y}. So while you can use local open as you're using it,
>you've
>>> been able to do it as a totally unambiguous language feature for
>quite some
>>> time.
>>>
>>>
>>> David
>>>
>>>
>>> --
>>> Caml-list mailing list.  Subscription management and archives:
>>> https://sympa.inria.fr/sympa/arc/caml-list
>>> Beginner's list: http://groups.yahoo.com/group/ocaml_beginners
>>> Bug reports: http://caml.inria.fr/bin/caml-bugs
>>>
>>
>>
>
>-- 
>Caml-list mailing list.  Subscription management and archives:
>https://sympa.inria.fr/sympa/arc/caml-list
>Beginner's list: http://groups.yahoo.com/group/ocaml_beginners
>Bug reports: http://caml.inria.fr/bin/caml-bugs

-- 
Simon
------BC3GPUVVDHG39QSNPSIQ5BBR334DO1
Content-Type: text/html;
 charset=utf-8
Content-Transfer-Encoding: 8bit

<html><head></head><body>This whole thread makes me wonder whether local opens are worth it. I don&#39;t like global open (at all), and shadowing is harmful even in smaller scopes. Local open seems to be used for DSL that have a lot of infix operators (maths, etc.) as demonstrated by the proposal of new warnings and syntax about shadowing of infix operators.<br>
<br>
If modules have short names (Z, Q from Zarith come to mind, but module-aliasing your favorite monad to &quot;M&quot; would do too), would M.+ be a reasonable infix operator? I would be ready to have slightly more verbose calls to M.&gt;&gt;= if it removes ambiguity and potential shadowing bugs. Of course I don&#39;t know if this is compatible with the current syntax.<br><br><div class="gmail_quote">Le 19 août 2015 00:26:00 UTC+02:00, Anthony Tavener &lt;anthony.tavener@gmail.com&gt; a écrit :<blockquote class="gmail_quote" style="margin: 0pt 0pt 0pt 0.8ex; border-left: 1px solid rgb(204, 204, 204); padding-left: 1ex;">
<div dir="ltr"><div>(TL;DR: I commonly want to specify paths -uniquely- for identifiers in local</div><div>scopes (function, module) which have no means to do this.)</div><div><br /></div><div>As I run into this yet again, moments ago...</div><div><br /></div><div>I do often want the ability to be clear that something is not to be shadowed</div><div>by the opened scope... to specify it&#39;s from the local (usually function) scope.</div><div>Part of the reason is for code clarity, but also to safeguard against possible</div><div>later changes in the *opened* module (introducing the same identifier).</div><div><br /></div><div>  let init flags =</div><div>    M.(init (flag1 + flag2 + flags)) (* flags is intended to be &#39;local&#39;, but it could be shadowed by a value in M *)</div><div><br /></div><div>Where M provides &#39;init&#39;, &#39;flag1&#39;, &#39;flag2&#39;, and &#39;+&#39;, but &#39;flags&#39; is in the</div><div>local (function) context. When I do this I try to think
of a way to make it</div><div>self evident that &#39;flags&#39; is not from M, but there is no way. Aside from</div><div>bringing it outside the local-open, but then it&#39;s more difficult to build</div><div>an expression.</div><div><br /></div><div>Vimscript might be one of the worst languages to use as a reference, but this</div><div>issue does bring to mind the scope prefixes...</div><div><br /></div><div>  let init flags =</div><div>    M.(init (flag1 + flag2 + l:flags)) (* illustrative -- not a proposal! *)</div><div><br /></div><div>I sometimes consider using naming conventions, but I don&#39;t want to explicitly</div><div>make function arguments something like l_flags, l_point, etc. That would be a</div><div>horrible widespread style, and doesn&#39;t work nicely with named arguments.</div><div>Plus, changing names to do this seems wrong -- it&#39;s at the access site where</div><div>you want to disambiguate, which always leads me to think some sigil or
prefix.</div><div><br /></div><div>There was an earlier sidetrack which went with ^ as an &quot;unopen&quot; prefix. At first,</div><div>my interest was piqued. Naturally, the issue of recursive unopen came up...</div><div><br /></div><div>In response, Gabriel wisely remarked:</div><div><br /></div><div> &quot;It is remarkable that programming languages have avoided introducing</div><div>  explicit weakening (the popping of a symbol out of scope) for now, and</div><div>  I think it is a property that should be preserved. We&#39;re not yet ready</div><div>  to go there.&quot;</div><div><br /></div><div>Good advice when the thread was spinning out of control and probably not going</div><div>to settle on anything realistic or favorable. Even though there might be merit</div><div>in pursuing fine-grained scope-popping as its own topic.</div><div><br /></div><div>I think there is a simpler gain to be had from the idea of being able to specify</div><div>the path of the current
context. &quot;Current context&quot; would need to be</div><div>something sensible, and I&#39;m not sure yet what would be best, as there is a</div><div>related issue I encounter commonly:</div><div><br /></div><div>A way to specify the path of the current module.</div><div><br /></div><div>There is no way to do this, right? If I&#39;m in &quot;<a href="http://a.ml">a.ml</a>&quot;, I can&#39;t refer to</div><div>A.identifier, and there is no other way to uniquely specify the path to what</div><div>*will become* A.identifier? As the bare &quot;identifier&quot; can be shadowed by any</div><div>modules opened afterward. Unlike the general &quot;scope-popping&quot;, there is also</div><div>a common language feature like this: self or this.</div><div><br /></div><div>I usually want to be explicit with module paths, especially if I am using an</div><div>&quot;identifier&quot; which could reasonably be expected to exist now or later in the</div><div>other modules being used. I do keep
opens to a minimum, but often an entire</div><div>expression will be in a local open (to bring in operators), and there,</div><div>again... I would like that clarity, and safeguard against changes which might</div><div>happen in the other modules, leading to suprises or need to change *this*</div><div>module for no good reason other than a naming conflict which ideally can be</div><div>prepared against.</div><div><br /></div><div>Has there been any discussion about referring to the local module? My guess is</div><div>that it might be a mild enough problem to not warrant any proposed solutions.</div><div>But if there are ideas, maybe the same thing or something similar can also</div><div>apply to this problem of &quot;escaping&quot; a local open? They are very similar, but</div><div>one is module-scope, while I think the other would be function-scope (though</div><div>module-scope might imply the &quot;right thing&quot; anyway)... I&#39;m not certain, as</div><div>haven&#39;t been
keeping track of the cases I encounter, and others might have</div><div>different use-cases.</div><div><br /></div></div><div class="gmail_extra"><br /><div class="gmail_quote">On Tue, Aug 18, 2015 at 7:00 AM, Gabriel Scherer <span dir="ltr">&lt;<a href="mailto:gabriel.scherer@gmail.com" target="_blank">gabriel.scherer@gmail.com</a>&gt;</span> wrote:<br /><blockquote class="gmail_quote" style="margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex"><div dir="ltr">Note that the dual feature does not exist for variant constructors, because it is easy to define only on the constructor at the toplevel of the pattern, and nested patterns get us in muddy waters.<br /></div><div class="HOEnZb"><div class="h5"><div class="gmail_extra"><br /><div class="gmail_quote">On Tue, Aug 18, 2015 at 2:52 PM, David Allsopp <span dir="ltr">&lt;<a href="mailto:dra-news@metastack.com" target="_blank">dra-news@metastack.com</a>&gt;</span> wrote:<br /><blockquote class="gmail_quote" style="margin:0 0
0 .8ex;border-left:1px #ccc solid;padding-left:1ex"><span>Goswin von Brederlow wrote:<br />
&gt; On Fri, Aug 14, 2015 at 01:28:50PM +0200, Drup wrote:<br />
&gt; &gt;<br />
&gt; &gt; &gt;You can&#39;t qualifylocal values or values of the surrounding module so<br />
&gt; &gt; &gt;that is a no go.<br />
&gt; &gt; &gt;<br />
&gt; &gt; &gt;I also often use local open to access records, as in:<br />
&gt; &gt; &gt;<br />
&gt; &gt; &gt;let r = M.({ x = 1; y; z = depth; }) in<br />
&gt; &gt;<br />
&gt; &gt; You can avoid the local open altogether and write it like that:<br />
&gt; &gt;<br />
&gt; &gt;     let r = {M. x = 1; y; z = depth } in<br />
&gt; &gt;<br />
&gt; &gt; It&#39;s even shorter.<br />
&gt;<br />
&gt; That only works because newer ocaml disambiguises (is that a word?) record<br />
</span><span>&gt; So it&#39;s implicitly using M.y = y and M.z = depth.<br />
&gt; labels when it determines the record type from the first label, right?<br />
<br />
</span>Only since you ask: &quot;disambiguates&quot; :o) That said, it&#39;s quite common to see words like &quot;disambiguises&quot; being invented by Americans!<br />
<br />
But this isn&#39;t related to the disambiguation features of OCaml 4.01+. Those allow you to write things like:<br />
<br />
type t = {x : int}<br />
type u = {x : int; y : string}<br />
<br />
let foo = {x = 1}<br />
let bar = {x = 42; y = &quot;&quot;}<br />
<br />
This is actually a much older notation added in OCaml 3.08. Prior to that, if you hadn&#39;t opened a module you had to qualify each label:<br />
<br />
{M.x = 1; M.y = y; M.z = depth}<br />
<br />
but this was &quot;silly&quot;, since it&#39;s not possible to use non-equivalent module paths for labels, so OCaml 3.08 changed it so that you only needed to put the module path on one label (and it doesn&#39;t have to be the first one, it&#39;s just a bit weird to put it in the middle!).<br />
<br />
OCaml 3.12 added, amongst other record-related goodies, the shorthand {y} to mean {y = y}. So while you can use local open as you&#39;re using it, you&#39;ve been able to do it as a totally unambiguous language feature for quite some time.<br />
<span><font color="#888888"><br />
<br />
David<br />
</font></span><div><div><br />
<br />
--<br />
Caml-list mailing list.  Subscription management and archives:<br />
<a href="https://sympa.inria.fr/sympa/arc/caml-list" rel="noreferrer" target="_blank">https://sympa.inria.fr/sympa/arc/caml-list</a><br />
Beginner&#39;s list: <a href="http://groups.yahoo.com/group/ocaml_beginners" rel="noreferrer" target="_blank">http://groups.yahoo.com/group/ocaml_beginners</a><br />
Bug reports: <a href="http://caml.inria.fr/bin/caml-bugs" rel="noreferrer" target="_blank">http://caml.inria.fr/bin/caml-bugs</a></div></div></blockquote></div><br /></div>
</div></div></blockquote></div><br /></div>
</blockquote></div><br>
-- <br>
Simon</body></html>
------BC3GPUVVDHG39QSNPSIQ5BBR334DO1--

