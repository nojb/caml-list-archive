Received: (from majordomo@localhost) by pauillac.inria.fr (8.7.6/8.7.3) id KAA00487; Tue, 1 Jul 2003 10:03:45 +0200 (MET DST)
X-Authentication-Warning: pauillac.inria.fr: majordomo set sender to owner-caml-list@pauillac.inria.fr using -f
Received: from concorde.inria.fr (concorde.inria.fr [192.93.2.39]) by pauillac.inria.fr (8.7.6/8.7.3) with ESMTP id KAA00692 for <caml-list@pauillac.inria.fr>; Tue, 1 Jul 2003 10:03:44 +0200 (MET DST)
Received: from kurims.kurims.kyoto-u.ac.jp (kurims.kurims.kyoto-u.ac.jp [130.54.16.1])
	by concorde.inria.fr (8.11.1/8.11.1) with ESMTP id h6183gj04363
	for <caml-list@inria.fr>; Tue, 1 Jul 2003 10:03:42 +0200 (MET DST)
Received: from suiren.kurims.kyoto-u.ac.jp (suiren.kurims.kyoto-u.ac.jp [130.54.16.25])
	by kurims.kurims.kyoto-u.ac.jp (8.9.3p2/3.7W) with ESMTP id RAA04033
	for <caml-list@inria.fr>; Tue, 1 Jul 2003 17:03:40 +0900 (JST)
Received: (from garrigue@localhost)
	by suiren.kurims.kyoto-u.ac.jp (8.11.7+Sun/3.7W) id h6183eW14523;
	Tue, 1 Jul 2003 17:03:40 +0900 (JST)
Newsgroups: comp.lang.functional
Subject: [Caml-list] Re: ocaml polymorphic variants and double coercion
References: <3EF9B92C.6070400@mitre.org>
From: Jacques Garrigue <see@my.signature>
Cc: caml-list@inria.fr
MIME-Version: 1.0 (generated by SEMI 1.13.7 - "Awazu")
Content-Type: text/plain; charset=US-ASCII
Date: 01 Jul 2003 17:03:33 +0900
Message-ID: <l2isqmbrmy.fsf@suiren.i-did-not-set--mail-host-address--so-shoot-me>
Organization: RIMS, Kyoto University
Lines: 57
User-Agent: T-gnus/6.14.6 (based on Gnus v5.8.8) (revision 02) SEMI/1.13.7 (Awazu) FLIM/1.13.2 (Kasanui) Emacs/21.2 (i386-pc-solaris2.8) MULE/5.0 (SAKAKI)
Posted-To: comp.lang.functional
X-Spam: no; 0.00; jacques:01 inference:01 subtyping:01 recursion:01 reuse:01 wwwfun:01 coercions:01 supertype:01 caml-list:01 ocaml:01 variants:01 garrigue:01 kyoto:01 subtype:01 coercion:01 
Sender: owner-caml-list@pauillac.inria.fr
Precedence: bulk

The following message is a courtesy copy of an article
that has been posted to comp.lang.functional as well.

Shaddin Doghmi <shaddin@mitre.org> writes:

> What is the difference between double corcion and single coersion? what 
> can double coercion do that single coercion cant?

Lots of things :-)
In a single coercion, the expected type is directly built from the
target type in a predefined way. The algorithm attempts to be clever,
but if the target type is recursive, or already has a polymorphic
structure, there is no unique most general expected type. Moreover,
there are extra restrictions to avoid a blow-up in type inference
time, namely left hand sides of arrows are not available for subtyping
(but other contravariant types are...)

Here are typical examples involving polymorphic variants

fun x -> (x :> [`Nil | `Cons of 'a * 'b] as 'b)
- : [< `Cons of 'b * ([ `Cons of 'a | `Nil ] as 'c) as 'a | `Nil ] -> 'c
Note that the expected type has only been partially open.

fun x ->
  (x : [< `Nil | `Cons of 'a * 'b] as 'b :> [`Nil | `Cons of 'a * 'c] as 'c)
With a double coercion we can get recursion on the expected side.

fun x ->
  (x : [< `Nil | `Cons of 'a * 'b] as 'b :> [> `Nil | `Cons of 'a * 'c] as 'c)
This wouldn't work with a single coercion, as the target is polymorphic.

If there is no recursion, you can get this last effect through dispatch:
function `None | `Some _ as x -> x
- : [< `None | `Some of 'a ] -> [> `None | `Some of 'a ]

> Also, there doesnt seem to be any good detailed references for 
> polymorphic variants. Both the ocaml manual and the oreilly book dont 
> mention lots of details. Anybody know of any good references?

See my publications for examples and theory with polymorphic variants.
In particular the paper on code reuse is a good introduction, and the
syntax is (almost) the current one.

http://wwwfun.kurims.kyoto-u.ac.jp/~garrigue/papers/

There is a very small bit on coercions in "Programming with ..."
(which uses an older syntax, by the way).
Basically they work just like for object types, which get a reasonably
detailed account in the reference manual. The main differences are
that (1)there is no concept of class type with variants, so you always
need double coercions to introduce recursion, and (2)with polymorphic
variants a closed type vt has both a polymorphic subtype [< vt] and a
polymorphic supertype [> vt], while an object type has only a subtype
#vt.

P.S. I forward to the caml-list to be in the logs...

---------------------------------------------------------------------------
Jacques Garrigue      Kyoto University     garrigue at kurims.kyoto-u.ac.jp
		<A HREF=http://wwwfun.kurims.kyoto-u.ac.jp/~garrigue/>JG</A>

-------------------
To unsubscribe, mail caml-list-request@inria.fr Archives: http://caml.inria.fr
Bug reports: http://caml.inria.fr/bin/caml-bugs FAQ: http://caml.inria.fr/FAQ/
Beginner's list: http://groups.yahoo.com/group/ocaml_beginners

