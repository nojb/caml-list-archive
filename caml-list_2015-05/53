Return-Path: <leo@lpw25.net>
X-Original-To: caml-list@sympa.inria.fr
Delivered-To: caml-list@sympa.inria.fr
Received: from mail3-relais-sop.national.inria.fr (mail3-relais-sop.national.inria.fr [192.134.164.104])
	by sympa.inria.fr (Postfix) with ESMTPS id 6A6997EC76
	for <caml-list@sympa.inria.fr>; Mon, 11 May 2015 19:24:57 +0200 (CEST)
Received-SPF: None (mail3-smtp-sop.national.inria.fr: no sender
  authenticity information available from domain of
  leo@lpw25.net) identity=pra; client-ip=66.111.4.28;
  receiver=mail3-smtp-sop.national.inria.fr;
  envelope-from="leo@lpw25.net"; x-sender="leo@lpw25.net";
  x-conformance=sidf_compatible
Received-SPF: None (mail3-smtp-sop.national.inria.fr: no sender
  authenticity information available from domain of
  leo@lpw25.net) identity=mailfrom; client-ip=66.111.4.28;
  receiver=mail3-smtp-sop.national.inria.fr;
  envelope-from="leo@lpw25.net"; x-sender="leo@lpw25.net";
  x-conformance=sidf_compatible
Received-SPF: None (mail3-smtp-sop.national.inria.fr: no sender
  authenticity information available from domain of
  postmaster@out4-smtp.messagingengine.com) identity=helo;
  client-ip=66.111.4.28;
  receiver=mail3-smtp-sop.national.inria.fr;
  envelope-from="leo@lpw25.net";
  x-sender="postmaster@out4-smtp.messagingengine.com";
  x-conformance=sidf_compatible
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: A0AgAQDT5FBVnBwEb0JchEGDHslAAoE2OxEBAQEBAQEBEQEBAQEBBg0JCSEuhCEBAQQjHToPCxgCAiYCAiwrNIgRs1BwhGiObwEBAQcBAQEBARcGgSGKGIRSOoItDC8SHYEWizaEWY46kV6DVYIJgi0iMYJGAQEB
X-IPAS-Result: A0AgAQDT5FBVnBwEb0JchEGDHslAAoE2OxEBAQEBAQEBEQEBAQEBBg0JCSEuhCEBAQQjHToPCxgCAiYCAiwrNIgRs1BwhGiObwEBAQcBAQEBARcGgSGKGIRSOoItDC8SHYEWizaEWY46kV6DVYIJgi0iMYJGAQEB
X-IronPort-AV: E=Sophos;i="5.13,409,1427752800"; 
   d="scan'208,217";a="117376528"
Received: from out4-smtp.messagingengine.com ([66.111.4.28])
  by mail3-smtp-sop.national.inria.fr with ESMTP/TLS/DHE-RSA-AES256-SHA; 11 May 2015 19:24:56 +0200
Received: from compute5.internal (compute5.nyi.internal [10.202.2.45])
	by mailout.nyi.internal (Postfix) with ESMTP id F263A2094B
	for <caml-list@inria.fr>; Mon, 11 May 2015 13:24:54 -0400 (EDT)
Received: from web3 ([10.202.2.213])
  by compute5.internal (MEProxy); Mon, 11 May 2015 13:24:54 -0400
DKIM-Signature: v=1; a=rsa-sha1; c=relaxed/relaxed; d=lpw25.net; h=
	content-transfer-encoding:content-type:date:from:in-reply-to
	:message-id:mime-version:references:subject:to:x-sasl-enc
	:x-sasl-enc; s=mesmtp; bh=j2CxXqF2iK90vr9f8pMXeraOUe8=; b=KObZao
	0jphN6BNnzdC+3UhQ3cy6Y/zE6VE19JsK8phFHkiNdDnXIrX+QPYrYim906ydlLj
	f7ZEPH38DLea7Z2ld3F6ChZE4ZsdgZi0S6zjuzhVKsP7mzWFEKwdVqFYuhSgtY6i
	6KcaPz/OBeFJS3njk+X1y8Xyfd6WKnDwTur3M=
DKIM-Signature: v=1; a=rsa-sha1; c=relaxed/relaxed; d=
	messagingengine.com; h=content-transfer-encoding:content-type
	:date:from:in-reply-to:message-id:mime-version:references
	:subject:to:x-sasl-enc:x-sasl-enc; s=smtpout; bh=j2CxXqF2iK90vr9
	f8pMXeraOUe8=; b=VgFGb7w/bkPw/TAVxgJNDp2FoGgmBctzWwK53e2qc5KoQ1c
	c2bI0tm9U6Kh91nnxESGJxSWCESwnDOh72vDE3YQ1dnBg07iSApolrgshkx480j1
	c51FDcn3p27CDdo9oj+iZ5F7r6G3Xn5vhStjuBfotspDDJqRkoWG1sLwtnsI=
Received: by web3.nyi.internal (Postfix, from userid 99)
	id C49BE111E9F; Mon, 11 May 2015 13:24:54 -0400 (EDT)
Message-Id: <1431365094.2461238.265829665.54F778D3@webmail.messagingengine.com>
X-Sasl-Enc: jkCgpft9tU+/IjzGuM38wgYzdpLjNXYCY7/XH5qJ7H6f 1431365094
From: Leo White <leo@lpw25.net>
To: caml-list@inria.fr
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Content-Type: multipart/alternative; boundary="_----------=_143136509424612380";
 charset="utf-8"
X-Mailer: MessagingEngine.com Webmail Interface - ajax-102d4956
Date: Mon, 11 May 2015 13:24:54 -0400
In-Reply-To: <CAPOA5_7X-wAxr8BwaUgz1u4rR00cphzgEKeQyPLwcNDT317NbQ@mail.gmail.com>
References: <CAPOA5_7X-wAxr8BwaUgz1u4rR00cphzgEKeQyPLwcNDT317NbQ@mail.gmail.com>
Subject: Re: [Caml-list] Record fields not reexported from functors.

This is a multi-part message in MIME format.

--_----------=_143136509424612380
Content-Transfer-Encoding: 7bit
Content-Type: text/plain

To expand slightly on Jacques' answer. Record fields (and variant
constructors) must be explicitly exported, using the:

type t = Foo.t = { bar : int }

syntax.

For example, the following version of your example works:

module type HasType = sig type t = { innerRecordField: int } end

module EchoModule (Input : HasType) : HasType with type t = Input.t =
struct type t = Input.t = {innerRecordField: int} end

module ClonedModuleWithRecordType = EchoModule(struct type t =
{innerRecordField: int} end)

let myRecord: ClonedModuleWithRecordType.t = {
ClonedModuleWithRecordType.innerRecordField=10; }

Of course, the `EchoModule` functor can now only operate on modules
where the type t is defined as:

type t = { innerRecordField : int }

Jacques' solution of giving the functor argument a name, and using that
name to access the field, is a much more flexible approach.

Regards,

Leo

On Sun, 10 May 2015, at 05:58 PM, Jordan W wrote:
> I believe there is an issue with record fields and functors. It
> appears that while types are correctly exported from functors, the
> corresponding record field scopes are not. Here is an example.
>
> module type HasType = sig type t end
>
> module EchoModule (Input:HasType): (HasType with type t = Input.t) =
> (struct type t = Input.t end)
>
> module ClonedModuleWithRecordType = EchoModule (struct type t =
> {innerRecordField: int} end)
>
> (* This doesn't type check, but I can't see why it shouldn't. Record
> fields' scopes should be reexported just like the types themselves.
>
> let myRecord: ClonedModuleWithRecordType.t = {
> ClonedModuleWithRecordType.innerRecordField=10; }
>
> In this case, the original "scope" of the record fields is "lost"
> because the record type was declared in an anonymous module
> expression. I believe that it *should* be "lost" as it is, but then
> reexported as an identical type in the module returned from the
> functor (identically because of the "with constraint").
>
> *)
>
> module ClonedModuleWithNonRecordType = EchoModule (struct type t =
> string list end)
>
> (* This typechecks perfectly fine! Evidence that types are reexported,
> but not the "scope" of record labels *) let myRecord:
> ClonedModuleWithNonRecordType.t = ["asdf"; "fff"]
>
>
> Is anyone aware of whether or not this issue is already being tracked?
>


--_----------=_143136509424612380
Content-Transfer-Encoding: 7bit
Content-Type: text/html

<!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body><div>To expand slightly on Jacques' answer. Record fields (and variant<br></div>
<div>constructors) must be explicitly exported, using the:<br></div>
<div>&nbsp;</div>
<div>&nbsp; type t = Foo.t = { bar : int }<br></div>
<div>&nbsp;</div>
<div>syntax.<br></div>
<div>&nbsp;</div>
<div>For example, the following version of your example works:<br></div>
<div>&nbsp;</div>
<div>&nbsp; module type HasType = sig<br></div>
<div>&nbsp; &nbsp; type t = { innerRecordField: int }<br></div>
<div>&nbsp; end<br></div>
<div>&nbsp;</div>
<div>&nbsp; module EchoModule (Input : HasType) : HasType with type t = Input.t = struct<br></div>
<div>&nbsp; &nbsp; type t = Input.t = {innerRecordField: int}<br></div>
<div>&nbsp; end<br></div>
<div>&nbsp;</div>
<div>&nbsp; module ClonedModuleWithRecordType = EchoModule(struct<br></div>
<div>&nbsp; &nbsp; type t = {innerRecordField: int}<br></div>
<div>&nbsp; end)<br></div>
<div>&nbsp;</div>
<div>&nbsp; let myRecord: ClonedModuleWithRecordType.t = {<br></div>
<div>&nbsp; &nbsp; ClonedModuleWithRecordType.innerRecordField=10;<br></div>
<div>&nbsp; }<br></div>
<div>&nbsp;</div>
<div>Of course, the `EchoModule` functor can now only operate on modules<br></div>
<div>where the type t is defined as:<br></div>
<div>&nbsp;</div>
<div>&nbsp; type t = { innerRecordField : int }<br></div>
<div>&nbsp;</div>
<div>Jacques' solution of giving the functor argument a name, and using that<br></div>
<div>name to access the field, is a much more flexible approach.<br></div>
<div>&nbsp;</div>
<div>Regards,<br></div>
<div>&nbsp;</div>
<div>Leo</div>
<div>&nbsp;</div>
<div>On Sun, 10 May 2015, at 05:58 PM, Jordan W wrote:<br></div>
<blockquote type="cite"><div dir="ltr"><div><div>I believe there is an issue with record fields and functors.<br></div>
<div>It appears that while types are correctly exported from functors, the corresponding record field scopes are not. Here is an example.<br></div>
<div>&nbsp;</div>
<div>&nbsp; &nbsp;module type HasType = sig<br></div>
<div>&nbsp; &nbsp; &nbsp; type t<br></div>
<div>&nbsp; &nbsp; end<br></div>
<div>&nbsp;</div>
<div>&nbsp; &nbsp; module EchoModule (Input:HasType): (HasType with type t = Input.t) = (struct<br></div>
<div>&nbsp; &nbsp; &nbsp; type t = Input.t<br></div>
<div>&nbsp; &nbsp; end)<br></div>
<div>&nbsp;</div>
<div>&nbsp; &nbsp; module ClonedModuleWithRecordType = EchoModule (struct<br></div>
<div>&nbsp; &nbsp; &nbsp; type t = {innerRecordField: int}<br></div>
<div>&nbsp; &nbsp; end)<br></div>
<div>&nbsp;</div>
<div>&nbsp; &nbsp; (* This doesn't type check, but I can't see why it shouldn't. Record fields'<br></div>
<div>&nbsp; &nbsp; &nbsp; &nbsp;scopes should be reexported just like the types themselves.<br></div>
<div>&nbsp;</div>
<div>&nbsp; &nbsp; &nbsp; let myRecord: ClonedModuleWithRecordType.t = {<br></div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; ClonedModuleWithRecordType.innerRecordField=10;<br></div>
<div>&nbsp; &nbsp; &nbsp; }<br></div>
<div>&nbsp;</div>
<div>&nbsp; &nbsp; &nbsp; In this case, the original "scope" of the record fields is "lost"<br></div>
<div>&nbsp; &nbsp; &nbsp; because the record type was declared in an anonymous module expression. &nbsp;I<br></div>
<div>&nbsp; &nbsp; &nbsp; believe that it *should* be "lost" as it is, but then reexported as an<br></div>
<div>&nbsp; &nbsp; &nbsp; identical type in the module returned from the functor (identically because<br></div>
<div>&nbsp; &nbsp; &nbsp; of the "with constraint").<br></div>
<div>&nbsp;</div>
<div>&nbsp; &nbsp; *)<br></div>
<div>&nbsp;</div>
<div>&nbsp; &nbsp; module ClonedModuleWithNonRecordType = EchoModule (struct<br></div>
<div>&nbsp; &nbsp; &nbsp; type t = string list<br></div>
<div>&nbsp; &nbsp; end)<br></div>
<div>&nbsp;</div>
<div>&nbsp; &nbsp; (* This typechecks perfectly fine! Evidence that types are reexported, but not<br></div>
<div>&nbsp; &nbsp; &nbsp; &nbsp;the "scope" of record labels *)<br></div>
<div>&nbsp; &nbsp; let myRecord: ClonedModuleWithNonRecordType.t = ["asdf"; "fff"]<br></div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>Is anyone aware of whether or not this issue is already being tracked?<br></div>
</div>
<div>&nbsp;</div>
</div>
</blockquote><div>&nbsp;</div>
</body>
</html>

--_----------=_143136509424612380--

