Return-Path: <dra-news@metastack.com>
X-Original-To: caml-list@sympa.inria.fr
Delivered-To: caml-list@sympa.inria.fr
Received: from mail3-relais-sop.national.inria.fr (mail3-relais-sop.national.inria.fr [192.134.164.104])
	by sympa.inria.fr (Postfix) with ESMTPS id 67B5B81792
	for <caml-list@sympa.inria.fr>; Sun, 23 Jun 2013 11:48:47 +0200 (CEST)
Received-SPF: None (mail3-smtp-sop.national.inria.fr: no sender
  authenticity information available from domain of
  dra-news@metastack.com) identity=pra;
  client-ip=81.103.221.48;
  receiver=mail3-smtp-sop.national.inria.fr;
  envelope-from="dra-news@metastack.com";
  x-sender="dra-news@metastack.com";
  x-conformance=sidf_compatible
Received-SPF: Neutral (mail3-smtp-sop.national.inria.fr: domain
  of dra-news@metastack.com does not assert whether or not
  81.103.221.48 is permitted sender) identity=mailfrom;
  client-ip=81.103.221.48;
  receiver=mail3-smtp-sop.national.inria.fr;
  envelope-from="dra-news@metastack.com";
  x-sender="dra-news@metastack.com";
  x-conformance=sidf_compatible; x-record-type="v=spf1"
Received-SPF: None (mail3-smtp-sop.national.inria.fr: no sender
  authenticity information available from domain of
  postmaster@mtaout02-winn.ispmail.ntl.com) identity=helo;
  client-ip=81.103.221.48;
  receiver=mail3-smtp-sop.national.inria.fr;
  envelope-from="dra-news@metastack.com";
  x-sender="postmaster@mtaout02-winn.ispmail.ntl.com";
  x-conformance=sidf_compatible
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: AsIAAK3DxlFRZ90wlGdsb2JhbABagkUjwFF7Fg4BAQEBBw0JCRQDJYIjAQEEAX4LAgEIPwcyFBECBBOICAcDuF+PVoMCYQOsFw
X-IPAS-Result: AsIAAK3DxlFRZ90wlGdsb2JhbABagkUjwFF7Fg4BAQEBBw0JCRQDJYIjAQEEAX4LAgEIPwcyFBECBBOICAcDuF+PVoMCYQOsFw
X-IronPort-AV: E=Sophos;i="4.87,922,1363129200"; 
   d="scan'208,217";a="18680998"
Received: from mtaout02-winn.ispmail.ntl.com ([81.103.221.48])
  by mail3-smtp-sop.national.inria.fr with ESMTP; 23 Jun 2013 11:48:46 +0200
Received: from aamtaout02-winn.ispmail.ntl.com ([81.103.221.35])
          by mtaout02-winn.ispmail.ntl.com
          (InterMail vM.7.08.04.00 201-2186-134-20080326) with ESMTP
          id <20130623094845.PPUY23282.mtaout02-winn.ispmail.ntl.com@aamtaout02-winn.ispmail.ntl.com>
          for <caml-list@inria.fr>; Sun, 23 Jun 2013 10:48:45 +0100
Received: from romulus.metastack.com ([81.102.132.77])
          by aamtaout02-winn.ispmail.ntl.com
          (InterMail vG.3.00.04.00 201-2196-133-20080908) with ESMTP
          id <20130623094845.GPMG6472.aamtaout02-winn.ispmail.ntl.com@romulus.metastack.com>
          for <caml-list@inria.fr>; Sun, 23 Jun 2013 10:48:45 +0100
Received: from remus.metastack.local (remus.metastack.com [172.16.0.1])
	by romulus.metastack.com (8.14.2/8.14.2) with ESMTP id r5N9mhsG008793
	(version=TLSv1/SSLv3 cipher=AES128-SHA bits=128 verify=FAIL)
	for <caml-list@inria.fr>; Sun, 23 Jun 2013 10:48:43 +0100
Received: from Remus.metastack.local ([fe80::547c:3c42:e1da:eda2]) by
 Remus.metastack.local ([fe80::547c:3c42:e1da:eda2%10]) with mapi id
 14.03.0123.003; Sun, 23 Jun 2013 10:48:42 +0100
From: David Allsopp <dra-news@metastack.com>
To: OCaml List <caml-list@inria.fr>
Thread-Topic: [Caml-list] Anonymous sum types in functors
Thread-Index: AQHOb/HiFRXNb/EAR2+F06vEU1G49ZlDDcx2
Date: Sun, 23 Jun 2013 09:48:42 +0000
Message-ID: <77CD1AA4-BDA5-4CE3-A563-E78BE8BABDF3@metastack.com>
References: <563607038852382852@orange.fr>
In-Reply-To: <563607038852382852@orange.fr>
Accept-Language: en-GB, en-US
Content-Language: en-GB
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
Content-Type: multipart/alternative;
	boundary="_000_77CD1AA4BDA54CE3A563E78BE8BABDF3metastackcom_"
MIME-Version: 1.0
Organization: MetaStack Solutions Ltd.
X-Scanned-By: MIMEDefang 2.65 on 172.16.0.20
X-Cloudmark-Analysis: v=1.1 cv=AUhbpHVS+xhHrj9wLCYAQoYnFLYUZdbP8UM0GmH2jwk= c=1 sm=0 a=SCxkbrXfzrIA:10 a=cTs9vV391PwA:10 a=xqWC_Br6kY4A:10 a=a7T1oGHex7gNXYlfKEUA:9 a=CjuIK1q_8ugA:10 a=ff08PU3xNlFlHJDDEp4A:9 a=_W_S_7VecoQA:10 a=GukhTqdkQ_j5e2mZ:21 a=HpAAvcLHHh0Zw7uRqdWCyQ==:117
Subject: Re: [Caml-list] Anonymous sum types in functors


--_000_77CD1AA4BDA54CE3A563E78BE8BABDF3metastackcom_
Content-Type: text/plain; charset="us-ascii"
Content-Transfer-Encoding: quoted-printable

On 23 Jun 2013, at 10:13, "Damien Guichard" <alphablock@orange.fr<mailto:al=
phablock@orange.fr>> wrote:




> a) Is there a way to do it where you can end up with type elt =3D A | B (=
I think the answer is no?)

> b) Is there a syntactically lighter way to write the module definition?



My own quick & dirty hack :

module FlagSet =3D Set.Make(struct type t =3D [`A | `B] let compare =3D com=
pare end)

Sadly not - the values are in use with C bindings and polymorphic variants =
would rather defeat the point of what I'm doing!

What would be nice would be an equivalent 'immediate' syntax for variant ty=
pes - but its only use would be this context, I expect!


David


- damien


I couldn't think of a better way to describe what I'm trying to do, so forg=
ive the possibly strange subject!



In:



module IntSet =3D Set.Make(struct type t =3D int let compare =3D compare en=
d)



the resulting signature is:



sig

  type elt =3D int

  type t

  ...



but in:



module FlagSet =3D Set.Make(struct type t =3D A | B let compare =3D compare=
 end)



the resulting signature is:



sig

  type elt

  type t

  ...



i.e. the constructors are hidden (I can see why, but presumably it is a spe=
cial case in the type checker?) and the module is essentially useless. I do=
n't want to define the type external to the module - the idea is that I'd b=
e able to write Flag1Set.add Flag1Set.CommonFlag Flag1Set.empty and Flag2Se=
t.add Flag2Set.CommonFlag Flag2Set.empty, etc.



I can work around this by writing:



module FlagSet =3D

  struct

    type flag =3D A | B

    include Set.Make(struct type t =3D flag let compare =3D compare end)

  end



where the resulting signature is:



sig

  type flag =3D A | B

  type elt =3D flag

  type t

  ...



but I'm wondering:



a) Is there a way to do it where you can end up with type elt =3D A | B (I =
think the answer is no?)

b) Is there a syntactically lighter way to write the module definition?





David


--_000_77CD1AA4BDA54CE3A563E78BE8BABDF3metastackcom_
Content-Type: text/html; charset="us-ascii"
Content-Transfer-Encoding: quoted-printable

<html>
<head>
<meta http-equiv=3D"Content-Type" content=3D"text/html; charset=3Dus-ascii">
</head>
<body dir=3D"auto">
<div>On 23 Jun 2013, at 10:13, &quot;Damien Guichard&quot; &lt;<a href=3D"m=
ailto:alphablock@orange.fr">alphablock@orange.fr</a>&gt; wrote:</div>
<div><br>
</div>
<blockquote type=3D"cite">
<div>
<title></title>
<style>
@font-face {
	font-family: Cambria Math;
}
@font-face {
	font-family: Calibri;
}
@font-face {
	font-family: Consolas;
}
@page WordSection1 {size: 612.0pt 792.0pt; margin: 72.0pt 72.0pt 72.0pt 72.=
0pt; }
P.MsoNormal {
	FONT-SIZE: 11pt; MARGIN: 0cm 0cm 0pt; FONT-FAMILY: "Calibri","sans-serif";=
 mso-fareast-language: EN-US
}
LI.MsoNormal {
	FONT-SIZE: 11pt; MARGIN: 0cm 0cm 0pt; FONT-FAMILY: "Calibri","sans-serif";=
 mso-fareast-language: EN-US
}
DIV.MsoNormal {
	FONT-SIZE: 11pt; MARGIN: 0cm 0cm 0pt; FONT-FAMILY: "Calibri","sans-serif";=
 mso-fareast-language: EN-US
}
A:link {
	COLOR: blue; TEXT-DECORATION: underline; mso-style-priority: 99
}
SPAN.MsoHyperlink {
	COLOR: blue; TEXT-DECORATION: underline; mso-style-priority: 99
}
A:visited {
	COLOR: purple; TEXT-DECORATION: underline; mso-style-priority: 99
}
SPAN.MsoHyperlinkFollowed {
	COLOR: purple; TEXT-DECORATION: underline; mso-style-priority: 99
}
P.MsoPlainText {
	FONT-SIZE: 11pt; MARGIN: 0cm 0cm 0pt; FONT-FAMILY: Consolas; mso-fareast-l=
anguage: EN-US; mso-style-priority: 99; mso-style-link: "Plain Text Char"
}
LI.MsoPlainText {
	FONT-SIZE: 11pt; MARGIN: 0cm 0cm 0pt; FONT-FAMILY: Consolas; mso-fareast-l=
anguage: EN-US; mso-style-priority: 99; mso-style-link: "Plain Text Char"
}
DIV.MsoPlainText {
	FONT-SIZE: 11pt; MARGIN: 0cm 0cm 0pt; FONT-FAMILY: Consolas; mso-fareast-l=
anguage: EN-US; mso-style-priority: 99; mso-style-link: "Plain Text Char"
}
SPAN.EmailStyle17 {
	COLOR: windowtext; FONT-FAMILY: "Calibri","sans-serif"; mso-style-type: pe=
rsonal
}
SPAN.PlainTextChar {
	FONT-FAMILY: Consolas; mso-style-priority: 99; mso-style-link: "Plain Text=
"; mso-style-name: "Plain Text Char"
}
.MsoChpDefault {
	FONT-FAMILY: "Calibri","sans-serif"; mso-fareast-language: EN-US; mso-styl=
e-type: export-only
}
DIV.WordSection1 {
	page: WordSection1
}
    </style><font style=3D"background-color: #fffbf0">&nbsp;</font>
<div><font face=3D"Arial">
<div class=3D"MsoPlainText">&nbsp;</div>
</font>
<p class=3D"MsoPlainText">&gt; a) Is there a way to do it where you can end=
 up with type elt =3D A | B (I think the answer is no?)</p>
<p class=3D"MsoPlainText">&gt; b) Is there a syntactically lighter way to w=
rite the module definition?&nbsp;</p>
<p>&nbsp;</p>
<div><font face=3D"Arial" size=3D"2">My own quick &amp; dirty hack :</font>=
</div>
<div>&nbsp;</div>
<div>module FlagSet =3D Set.Make(struct type t =3D [`A | `B] let compare =
=3D compare end)</div>
</div>
</div>
</blockquote>
<div><br>
</div>
<div>Sadly not - the values are in use with C bindings and polymorphic vari=
ants would rather defeat the point of what I'm doing!</div>
<div><br>
</div>
<div>What would be nice would be an equivalent 'immediate' syntax for varia=
nt types - but its only use would be this context, I expect!</div>
<div><br>
</div>
<div><br>
</div>
<div>David</div>
<br>
<blockquote type=3D"cite">
<div>
<div>
<div>&nbsp;</div>
<div><font face=3D"Arial" size=3D"2">- damien</font></div>
<div><font face=3D"Arial" size=3D"2"><br>
</font></div>
<blockquote style=3D"padding-right: 0px; padding-left: 5px; margin-left: 5p=
x; border-left: #0000ff 2px solid; margin-right: 0px">
<div class=3D"WordSection1">
<p class=3D"MsoPlainText">I couldn't think of a better way to describe what=
 I'm trying to do, so forgive the possibly strange subject!</p>
<p class=3D"MsoPlainText">&nbsp;</p>
<p class=3D"MsoPlainText">In:</p>
<p class=3D"MsoPlainText">&nbsp;</p>
<p class=3D"MsoPlainText">module IntSet =3D Set.Make(struct type t =3D int =
let compare =3D compare end)</p>
<p class=3D"MsoPlainText">&nbsp;</p>
<p class=3D"MsoPlainText">the resulting signature is:</p>
<p class=3D"MsoPlainText">&nbsp;</p>
<p class=3D"MsoPlainText">sig</p>
<p class=3D"MsoPlainText">&nbsp; type elt =3D int</p>
<p class=3D"MsoPlainText">&nbsp; type t</p>
<p class=3D"MsoPlainText">&nbsp; ...</p>
<p class=3D"MsoPlainText">&nbsp;</p>
<p class=3D"MsoPlainText">but in:</p>
<p class=3D"MsoPlainText">&nbsp;</p>
<p class=3D"MsoPlainText">module FlagSet =3D Set.Make(struct type t =3D A |=
 B let compare =3D compare end)</p>
<p class=3D"MsoPlainText">&nbsp;</p>
<p class=3D"MsoPlainText">the resulting signature is:</p>
<p class=3D"MsoPlainText">&nbsp;</p>
<p class=3D"MsoPlainText">sig</p>
<p class=3D"MsoPlainText">&nbsp; type elt</p>
<p class=3D"MsoPlainText">&nbsp; type t</p>
<p class=3D"MsoPlainText">&nbsp; ...</p>
<p class=3D"MsoPlainText">&nbsp;</p>
<p class=3D"MsoPlainText">i.e. the constructors are hidden (I can see why, =
but presumably it is a special case in the type checker?) and the module is=
 essentially useless. I don't want to define the type external to the modul=
e - the idea is that I'd be able to
 write Flag1Set.add Flag1Set.CommonFlag Flag1Set.empty and Flag2Set.add Fla=
g2Set.CommonFlag Flag2Set.empty, etc.</p>
<p class=3D"MsoPlainText">&nbsp;</p>
<p class=3D"MsoPlainText">I can work around this by writing:</p>
<p class=3D"MsoPlainText">&nbsp;</p>
<p class=3D"MsoPlainText">module FlagSet =3D</p>
<p class=3D"MsoPlainText">&nbsp; struct</p>
<p class=3D"MsoPlainText">&nbsp;&nbsp;&nbsp; type flag =3D A | B</p>
<p class=3D"MsoPlainText">&nbsp;&nbsp;&nbsp; include Set.Make(struct type t=
 =3D flag let compare =3D compare end)</p>
<p class=3D"MsoPlainText">&nbsp; end</p>
<p class=3D"MsoPlainText">&nbsp;</p>
<p class=3D"MsoPlainText">where the resulting signature is:</p>
<p class=3D"MsoPlainText">&nbsp;</p>
<p class=3D"MsoPlainText">sig</p>
<p class=3D"MsoPlainText">&nbsp; type flag =3D A | B</p>
<p class=3D"MsoPlainText">&nbsp; type elt =3D flag</p>
<p class=3D"MsoPlainText">&nbsp; type t</p>
<p class=3D"MsoPlainText">&nbsp; ...</p>
<p class=3D"MsoPlainText">&nbsp;</p>
<p class=3D"MsoPlainText">but I'm wondering:</p>
<p class=3D"MsoPlainText">&nbsp;</p>
<p class=3D"MsoPlainText">a) Is there a way to do it where you can end up w=
ith type elt =3D A | B (I think the answer is no?)</p>
<p class=3D"MsoPlainText">b) Is there a syntactically lighter way to write =
the module definition?</p>
<p class=3D"MsoPlainText">&nbsp;</p>
<p class=3D"MsoPlainText">&nbsp;</p>
<p class=3D"MsoPlainText">David</p>
</div>
</blockquote>
<br>
</div>
</div>
</blockquote>
</body>
</html>

--_000_77CD1AA4BDA54CE3A563E78BE8BABDF3metastackcom_--
